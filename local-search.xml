<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql优化02</title>
    <link href="/2021/08/26/14.2%20mysql%E4%BC%98%E5%8C%9602/"/>
    <url>/2021/08/26/14.2%20mysql%E4%BC%98%E5%8C%9602/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql高级-day03"><a href="#Mysql高级-day03" class="headerlink" title="Mysql高级-day03"></a>Mysql高级-day03</h1><h3 id="1-应用优化"><a href="#1-应用优化" class="headerlink" title="1. 应用优化"></a>1. 应用优化</h3><p>前面章节，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p><h4 id="1-1-使用连接池"><a href="#1-1-使用连接池" class="headerlink" title="1.1 使用连接池"></a>1.1 使用连接池</h4><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p><h4 id="1-2-减少对MySQL的访问"><a href="#1-2-减少对MySQL的访问" class="headerlink" title="1.2 减少对MySQL的访问"></a>1.2 减少对MySQL的访问</h4><h5 id="1-2-1-避免对数据进行重复检索"><a href="#1-2-1-避免对数据进行重复检索" class="headerlink" title="1.2.1 避免对数据进行重复检索"></a>1.2.1 避免对数据进行重复检索</h5><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p><p>比如 ，需要获取书籍的id 和name字段 ， 则查询如下： </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span> , <span class="hljs-built_in">name</span> <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span> , status <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span>, <span class="hljs-built_in">name</span> , status <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><h5 id="1-2-2-增加cache层"><a href="#1-2-2-增加cache层" class="headerlink" title="1.2.2 增加cache层"></a>1.2.2 增加cache层</h5><p>在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p><p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。</p><h4 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p><h5 id="1-3-1-利用MySQL复制分流查询"><a href="#1-3-1-利用MySQL复制分流查询" class="headerlink" title="1.3.1 利用MySQL复制分流查询"></a>1.3.1 利用MySQL复制分流查询</h5><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p><p><img src="/images/1.jpg" alt="1"> </p><h5 id="1-3-2-采用分布式数据库架构"><a href="#1-3-2-采用分布式数据库架构" class="headerlink" title="1.3.2 采用分布式数据库架构"></a>1.3.2 采用分布式数据库架构</h5><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p><h3 id="2-Mysql中查询缓存优化"><a href="#2-Mysql中查询缓存优化" class="headerlink" title="2. Mysql中查询缓存优化"></a>2. Mysql中查询缓存优化</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p><h4 id="2-2-操作流程"><a href="#2-2-操作流程" class="headerlink" title="2.2 操作流程"></a>2.2 操作流程</h4><p> <img src="/images/20180919131632347.png" alt="20180919131632347"> </p><ol><li>客户端发送一条查询给服务器；</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回给客户端。</li></ol><h4 id="2-3-查询缓存配置"><a href="#2-3-查询缓存配置" class="headerlink" title="2.3 查询缓存配置"></a>2.3 查询缓存配置</h4><ol><li><p>查看当前的MySQL数据库是否支持查询缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;have_query_cache&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1555249929012.png" alt="1555249929012"> </p></li><li><p>查看当前MySQL是否开启了查询缓存 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;query_cache_type&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1555250015377.png" alt="1555250015377"> </p></li><li><p>查看查询缓存的占用大小 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;query_cache_size&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1555250142451.png" alt="1555250142451">      </p></li><li><p>查看查询缓存的状态变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Qcache%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1555250443958.png" alt="1555250443958"> </p><p>各个变量的含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>查询缓存中的可用内存块数</td></tr><tr><td>Qcache_free_memory</td><td>查询缓存的可用内存量</td></tr><tr><td>Qcache_hits</td><td>查询缓存命中数</td></tr><tr><td>Qcache_inserts</td><td>添加到查询缓存的查询数</td></tr><tr><td>Qcache_lowmen_prunes</td><td>由于内存不足而从查询缓存中删除的查询数</td></tr><tr><td>Qcache_not_cached</td><td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td></tr><tr><td>Qcache_queries_in_cache</td><td>查询缓存中注册的查询数</td></tr><tr><td>Qcache_total_blocks</td><td>查询缓存中的块总数</td></tr></tbody></table></li></ol><h4 id="2-4-开启查询缓存"><a href="#2-4-开启查询缓存" class="headerlink" title="2.4 开启查询缓存"></a>2.4 开启查询缓存</h4><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>OFF 或 0</td><td>查询缓存功能关闭</td></tr><tr><td>ON 或 1</td><td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td></tr><tr><td>DEMAND 或 2</td><td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td></tr></tbody></table><p>在 /usr/my.cnf 配置中，增加以下配置 ： </p><p><img src="/images/1555251383805.png" alt="1555251383805">         </p><p>配置完毕之后，重启服务既可生效 ；</p><p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p><h4 id="2-5-查询缓存SELECT选项"><a href="#2-5-查询缓存SELECT选项" class="headerlink" title="2.5 查询缓存SELECT选项"></a>2.5 查询缓存SELECT选项</h4><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p><p>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</p><p>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> SQL_CACHE id, name <span class="hljs-keyword">FROM</span> customer;<br><span class="hljs-keyword">SELECT</span> SQL_NO_CACHE id, name <span class="hljs-keyword">FROM</span> customer;<br></code></pre></td></tr></table></figure><p>​    </p><h4 id="2-6-查询缓存失效的情况"><a href="#2-6-查询缓存失效的情况" class="headerlink" title="2.6 查询缓存失效的情况"></a>2.6 查询缓存失效的情况</h4><p>1） SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL">SQL1 : <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br>SQL2 : <span class="hljs-keyword">Select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br></code></pre></td></tr></table></figure><p>2） 当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL">SQL1 : <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> updatetime <span class="hljs-operator">&lt;</span> now() limit <span class="hljs-number">1</span>;<br>SQL2 : <span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>();<br>SQL3 : <span class="hljs-keyword">select</span> database();<br></code></pre></td></tr></table></figure><p>3） 不使用任何表查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>4）  查询 mysql， information_schema或  performance_schema 数据库中的表时，不会走查询缓存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.engines;<br></code></pre></td></tr></table></figure><p>5） 在存储的函数，触发器或事件的主体内执行的查询。</p><p>6） 如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p><h3 id="3-Mysql内存管理及优化"><a href="#3-Mysql内存管理及优化" class="headerlink" title="3. Mysql内存管理及优化"></a>3. Mysql内存管理及优化</h3><h4 id="3-1-内存优化原则"><a href="#3-1-内存优化原则" class="headerlink" title="3.1 内存优化原则"></a>3.1 内存优化原则</h4><p>1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p><p>2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p><p>3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p><h4 id="3-2-MyISAM-内存优化"><a href="#3-2-MyISAM-内存优化" class="headerlink" title="3.2 MyISAM 内存优化"></a>3.2 MyISAM 内存优化</h4><p>myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p><h5 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h5><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1/4可用内存分配给key_buffer_size。</p><p>在/usr/my.cnf 中做如下配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">key_buffer_size</span>=<span class="hljs-number">512</span>M<br></code></pre></td></tr></table></figure><h5 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h5><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h5 id="read-rnd-buffer-size"><a href="#read-rnd-buffer-size" class="headerlink" title="read_rnd_buffer_size"></a>read_rnd_buffer_size</h5><p>对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p><h4 id="3-3-InnoDB-内存优化"><a href="#3-3-InnoDB-内存优化" class="headerlink" title="3.3 InnoDB 内存优化"></a>3.3 InnoDB 内存优化</h4><p>innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p><h5 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h5><p>该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O 就越少，性能也就越高。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_buffer_pool_size</span>=<span class="hljs-number">512</span>M<br></code></pre></td></tr></table></figure><h5 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h5><p>决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">innodb_log_buffer_size</span>=<span class="hljs-number">10</span>M<br></code></pre></td></tr></table></figure><h3 id="4-Mysql并发参数调整"><a href="#4-Mysql并发参数调整" class="headerlink" title="4. Mysql并发参数调整"></a>4. Mysql并发参数调整</h3><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p><h4 id="4-1-max-connections"><a href="#4-1-max-connections" class="headerlink" title="4.1 max_connections"></a>4.1 max_connections</h4><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。</p><p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p><h4 id="4-2-back-log"><a href="#4-2-back-log" class="headerlink" title="4.2 back_log"></a>4.2 back_log</h4><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 但最大不超过900。</p><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p><h4 id="4-3-table-open-cache"><a href="#4-3-table-open-cache" class="headerlink" title="4.3 table_open_cache"></a>4.3 table_open_cache</h4><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p><p>​    max_connections x N ；</p><h4 id="4-4-thread-cache-size"><a href="#4-4-thread-cache-size" class="headerlink" title="4.4 thread_cache_size"></a>4.4 thread_cache_size</h4><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。</p><h4 id="4-5-innodb-lock-wait-timeout"><a href="#4-5-innodb-lock-wait-timeout" class="headerlink" title="4.5 innodb_lock_wait_timeout"></a>4.5 innodb_lock_wait_timeout</h4><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50ms ， 可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</p><h3 id="5-Mysql锁问题"><a href="#5-Mysql锁问题" class="headerlink" title="5. Mysql锁问题"></a>5. Mysql锁问题</h3><h4 id="5-1-锁概述"><a href="#5-1-锁概述" class="headerlink" title="5.1 锁概述"></a>5.1 锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p><p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><h4 id="5-2-锁分类"><a href="#5-2-锁分类" class="headerlink" title="5.2 锁分类"></a>5.2 锁分类</h4><p>从对数据操作的粒度分 ： </p><p>1） 表锁：操作时，会锁定整个表。</p><p>2） 行锁：操作时，会锁定当前操作行。</p><p>从对数据操作的类型分：</p><p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p><h4 id="5-3-Mysql-锁"><a href="#5-3-Mysql-锁" class="headerlink" title="5.3 Mysql 锁"></a>5.3 Mysql 锁</h4><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页面锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p><h4 id="5-2-MyISAM-表锁"><a href="#5-2-MyISAM-表锁" class="headerlink" title="5.2 MyISAM 表锁"></a>5.2 MyISAM 表锁</h4><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p><h5 id="5-2-1-如何加表锁"><a href="#5-2-1-如何加表锁" class="headerlink" title="5.2.1 如何加表锁"></a>5.2.1 如何加表锁</h5><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p><p>显示加表锁语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL">加读锁 ： lock <span class="hljs-keyword">table</span> table_name read;<br><br>加写锁 ： lock <span class="hljs-keyword">table</span> table_name write；<br></code></pre></td></tr></table></figure><h5 id="5-2-2-读锁案例"><a href="#5-2-2-读锁案例" class="headerlink" title="5.2.2 读锁案例"></a>5.2.2 读锁案例</h5><p>准备环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database demo_03 <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4;<br><br>use demo_03;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_book` (<br>  `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) auto_increment,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `publish_time` <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;java编程思想&#x27;</span>,<span class="hljs-string">&#x27;2088-08-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;solr编程思想&#x27;</span>,<span class="hljs-string">&#x27;2088-08-08&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user` (<br>  `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) auto_increment,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user (id, name) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;令狐冲&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user (id, name) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;田伯光&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>客户端 一 ：</p><p>1）获得tb_book 表的读锁 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> tb_book <span class="hljs-keyword">read</span>;<br></code></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p><img src="/images/1553906896564.png" alt="1553906896564"> </p><p>可以正常执行 ， 查询出数据。</p><p>客户端 二 ：</p><p>3） 执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book;<br></code></pre></td></tr></table></figure><p><img src="/images/1553907044500.png" alt="1553907044500"> </p><p>客户端 一 ：</p><p>4）查询未锁定的表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_seller;<br></code></pre></td></tr></table></figure><p><img src="/images/1553908913515.png" alt="1553908913515"> </p><p>客户端 二 ：</p><p>5）查询未锁定的表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_seller;<br></code></pre></td></tr></table></figure><p><img src="/images/1553908973840.png" alt="1553908973840"> </p><p>可以正常查询出未锁定的表；</p><p>客户端 一 ：</p><p>6） 执行插入操作 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Mysql高级&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/1553907198462.png" alt="1553907198462"> </p><p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。</p><p>客户端 二 ：</p><p>7） 执行插入操作 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_book <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Mysql高级&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/1553907403957.png" alt="1553907403957"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；</p><h5 id="5-2-3-写锁案例"><a href="#5-2-3-写锁案例" class="headerlink" title="5.2.3 写锁案例"></a>5.2.3 写锁案例</h5><p>客户端 一 :</p><p>1）获得tb_book 表的写锁 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> tb_book <span class="hljs-keyword">write</span> ;<br></code></pre></td></tr></table></figure><p>2）执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book ;<br></code></pre></td></tr></table></figure><p><img src="/images/1553907849829.png" alt="1553907849829"> </p><p>查询操作执行成功；</p><p>3）执行更新操作</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> tb_book <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;java编程思想（第二版）&#x27;</span> <span class="hljs-keyword">where</span> id = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1553907875221.png" alt="1553907875221"> </p><p>更新操作执行成功 ；</p><p>客户端 二 :</p><p>4）执行查询操作</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_book ;<br></code></pre></td></tr></table></figure><p><img src="/images/1553908019755.png" alt="1553908019755"> </p><p>当在客户端一中释放锁指令 unlock tables  后 ， 客户端二中的 select 语句 ， 立即执行 ；</p><p><img src="/images/1553908131373.png" alt="1553908131373"> </p><h5 id="5-2-4-结论"><a href="#5-2-4-结论" class="headerlink" title="5.2.4 结论"></a>5.2.4 结论</h5><p>锁模式的相互兼容性如表中所示：</p><p><img src="/images/image-20210826171632964.png" alt="image-20210826171632964"></p><p>由上表可见： </p><p>​    1） 对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</p><p>​    2） 对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</p><p>​    简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h5 id="5-2-5-查看锁的争用情况"><a href="#5-2-5-查看锁的争用情况" class="headerlink" title="5.2.5 查看锁的争用情况"></a>5.2.5 查看锁的争用情况</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">tables</span>；<br></code></pre></td></tr></table></figure><p><img src="/images/1556443073322.png" alt="1556443073322"> </p><p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p><p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Table_locks%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/image-20210826171837934.png" alt="image-20210826171837934"></p><p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p><p>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</p><h4 id="5-3-InnoDB-行锁"><a href="#5-3-InnoDB-行锁" class="headerlink" title="5.3 InnoDB 行锁"></a>5.3 InnoDB 行锁</h4><h5 id="5-3-1-行锁介绍"><a href="#5-3-1-行锁介绍" class="headerlink" title="5.3.1 行锁介绍"></a>5.3.1 行锁介绍</h5><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p><h5 id="5-3-2-背景知识"><a href="#5-3-2-背景知识" class="headerlink" title="5.3.2 背景知识"></a>5.3.2 背景知识</h5><p><strong>事务及其ACID属性</strong></p><p>事务是由一组SQL语句组成的逻辑处理单元。</p><p>事务具有以下4个特性，简称为事务ACID属性。</p><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><p><strong>并发事务处理带来的问题</strong></p><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>不可重复读（Non-Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td></tr></tbody></table><p><strong>事务隔离级别</strong></p><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。 </p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>备注 ： √  代表可能出现 ， × 代表不会出现 。</p><p>Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;tx_isolation&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1554331600009.png" alt="1554331600009">  </p><h5 id="5-3-3-InnoDB-的行锁模式"><a href="#5-3-3-InnoDB-的行锁模式" class="headerlink" title="5.3.3 InnoDB 的行锁模式"></a>5.3.3 InnoDB 的行锁模式</h5><p>InnoDB  实现了以下两种类型的行锁。</p><ul><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li></ul><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p><p>对于普通SELECT语句，InnoDB不会加任何锁；</p><p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">共享锁（S）：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... LOCK <span class="hljs-keyword">IN</span> SHARE MODE<br><br>排他锁（X) ：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br></code></pre></td></tr></table></figure><h5 id="5-3-4-案例准备工作"><a href="#5-3-4-案例准备工作" class="headerlink" title="5.3.4 案例准备工作"></a>5.3.4 案例准备工作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_innodb_lock(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>),<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>),<br>sex <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>)<br>)engine <span class="hljs-operator">=</span> innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;100&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;400&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;500&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;600&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;700&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;800&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;900&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_innodb_lock <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;200&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>);<br><br><span class="hljs-keyword">create</span> index idx_test_innodb_lock_id <span class="hljs-keyword">on</span> test_innodb_lock(id);<br><span class="hljs-keyword">create</span> index idx_test_innodb_lock_name <span class="hljs-keyword">on</span> test_innodb_lock(name);<br></code></pre></td></tr></table></figure><h5 id="5-3-5-行锁基本演示"><a href="#5-3-5-行锁基本演示" class="headerlink" title="5.3.5 行锁基本演示"></a>5.3.5 行锁基本演示</h5><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="/images/1554354615030.png" alt="1554354615030">      关闭自动提交功能</td><td><img src="/images/1554354601867.png" alt="1554354601867">  关闭自动提交功能</td></tr><tr><td><img src="/images/1554354713628.png" alt="1554354713628"> 可以正常的查询出全部的数据</td><td><img src="/images/1554354717336-1629969611627.png" alt="1554354717336"> 可以正常的查询出全部的数据</td></tr><tr><td><img src="/images/1554354830589-1629969614531.png" alt="1554354830589">查询id 为3的数据 ；</td><td><img src="/images/1554354832708-1629969617124.png" alt="1554354832708">获取id为3的数据 ；</td></tr><tr><td><img src="images/1554382789984-1629969620016.png" alt="1554382789984"> 更新id为3的数据，但是不提交；</td><td><img src="images/1554382905352-1629969624182.png" alt="1554382905352"> 更新id为3 的数据， 出于等待状态</td></tr><tr><td><img src="/images/1554382977653-1629969627677.png" alt="1554382977653"> 通过commit， 提交事务</td><td><img src="/images/1554383044542-1629969629930.png" alt="1554383044542"> 解除阻塞，更新正常进行</td></tr><tr><td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td><td></td></tr><tr><td><img src="/images/1554385220580-1629969633484.png" alt="1554385220580"> 更新id为3数据，正常的获取到行锁 ， 执行更新 ；</td><td><img src="/images/1554385236768-1629969636545.png" alt="1554385236768"> 由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td></tr></tbody></table><h5 id="5-3-6-无索引行锁升级为表锁"><a href="#5-3-6-无索引行锁升级为表锁" class="headerlink" title="5.3.6 无索引行锁升级为表锁"></a>5.3.6 无索引行锁升级为表锁</h5><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p><p>查看当前表的索引 ： show  index  from test_innodb_lock ;</p><p><img src="/images/1554385956215.png" alt="1554385956215"> </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务的自动提交<img src="/images/1554386287454-1629969665144.png" alt="1554386287454"></td><td>关闭事务的自动提交<img src="/images/1554386312524-1629969675945.png" alt="1554386312524"></td></tr><tr><td>执行更新语句 ：<img src="/images/1554386654793.png" alt="1554386654793"></td><td>执行更新语句， 但处于阻塞状态：<img src="/images/1554386685610-1629969697119.png" alt="1554386685610"></td></tr><tr><td>提交事务：<img src="/images/1554386721653-1629969709659.png" alt="1554386721653"></td><td>解除阻塞，执行更新成功 ：<img src="/images/1554386750004-1629969717127.png" alt="1554386750004"></td></tr><tr><td></td><td>执行提交操作 ：<img src="/images/1554386804807-1629969723290.png" alt="1554386804807"></td></tr></tbody></table><p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；</p><h5 id="5-3-7-间隙锁危害"><a href="#5-3-7-间隙锁危害" class="headerlink" title="5.3.7 间隙锁危害"></a>5.3.7 间隙锁危害</h5><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p><p>示例 ： </p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td>关闭事务自动提交 <img src="/images/1554387987130-1629969736407.png" alt="1554387987130"></td><td>关闭事务自动提交<img src="/images/1554387994533-1629969745354.png" alt="1554387994533"></td></tr><tr><td>根据id范围更新数据<img src="/images/1554388492478-1629969754855.png" alt="1554388492478"></td><td></td></tr><tr><td></td><td>插入id为2的记录， 出于阻塞状态<img src="/images/1554388515936-1629969761117.png" alt="1554388515936"></td></tr><tr><td>提交事务 ；<img src="/images/1554388149305-1629969767101.png" alt="1554388149305"></td><td></td></tr><tr><td></td><td>解除阻塞 ， 执行插入操作 ：<img src="/images/1554388548562-1629969773506.png" alt="1554388548562"></td></tr><tr><td></td><td>提交事务 ：</td></tr></tbody></table><h5 id="5-3-8-InnoDB-行锁争用情况"><a href="#5-3-8-InnoDB-行锁争用情况" class="headerlink" title="5.3.8 InnoDB 行锁争用情况"></a>5.3.8 InnoDB 行锁争用情况</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span>  status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556455943670.png" alt="1556455943670"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Innodb_row_lock_current_waits:</span> 当前正在等待锁定的数量<br><br><span class="hljs-symbol">Innodb_row_lock_time:</span> 从系统启动到现在锁定总时间长度<br><br><span class="hljs-symbol">Innodb_row_lock_time_avg:</span>每次等待所花平均时长<br><br><span class="hljs-symbol">Innodb_row_lock_time_max:</span>从系统启动到现在等待最长的一次所花的时间<br><br><span class="hljs-symbol">Innodb_row_lock_waits:</span> 系统启动后到现在总共等待的次数<br><br><br>当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。<br><br></code></pre></td></tr></table></figure><h5 id="5-3-9-总结"><a href="#5-3-9-总结" class="headerlink" title="5.3.9 总结"></a>5.3.9 总结</h5><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p><p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（但是需要业务层面满足需求）</li></ul><h3 id="6-常用SQL技巧"><a href="#6-常用SQL技巧" class="headerlink" title="6. 常用SQL技巧"></a>6. 常用SQL技巧</h3><h4 id="6-1-SQL执行顺序"><a href="#6-1-SQL执行顺序" class="headerlink" title="6.1 SQL执行顺序"></a>6.1 SQL执行顺序</h4><p>编写顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">JOIN</span><br><span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">HAVING</span><br><span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br><span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br>LIMIT<br><span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>执行顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">FROM</span><span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span><span class="hljs-keyword">JOIN</span><span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">WHERE</span><span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">HAVING</span><span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> list<span class="hljs-operator">&gt;</span><br><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br><br>LIMIT<span class="hljs-operator">&lt;</span>limit_params<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="6-2-正则表达式使用"><a href="#6-2-正则表达式使用" class="headerlink" title="6.2 正则表达式使用"></a>6.2 正则表达式使用</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>在字符串开始处进行匹配</td></tr><tr><td>$</td><td>在字符串末尾处进行匹配</td></tr><tr><td>.</td><td>匹配任意单个字符, 包括换行符</td></tr><tr><td>[…]</td><td>匹配出括号内的任意字符</td></tr><tr><td>[^…]</td><td>匹配不出括号内的任意字符</td></tr><tr><td>a*</td><td>匹配零个或者多个a(包括空串)</td></tr><tr><td>a+</td><td>匹配一个或者多个a(不包括空串)</td></tr><tr><td>a?</td><td>匹配零个或者一个a</td></tr><tr><td>a1|a2</td><td>匹配a1或a2</td></tr><tr><td>a(m)</td><td>匹配m个a</td></tr><tr><td>a(m,)</td><td>至少匹配m个a</td></tr><tr><td>a(m,n)</td><td>匹配m个a 到 n个a</td></tr><tr><td>a(,n)</td><td>匹配0到n个a</td></tr><tr><td>(…)</td><td>将模式元素组成单一元素</td></tr></tbody></table><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;^T&#x27;</span>;<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;2$&#x27;</span>;<br><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> regexp <span class="hljs-string">&#x27;[uvw]&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="6-3-MySQL-常用函数"><a href="#6-3-MySQL-常用函数" class="headerlink" title="6.3 MySQL 常用函数"></a>6.3 MySQL 常用函数</h4><p>数字函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>ABS</td><td>求绝对值</td></tr><tr><td>SQRT</td><td>求二次方根</td></tr><tr><td>MOD</td><td>求余数</td></tr><tr><td>CEIL 和 CEILING</td><td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td></tr><tr><td>FLOOR</td><td>向下取整，返回值转化为一个BIGINT</td></tr><tr><td>RAND</td><td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td></tr><tr><td>ROUND</td><td>对所传参数进行四舍五入</td></tr><tr><td>SIGN</td><td>返回参数的符号</td></tr><tr><td>POW 和 POWER</td><td>两个函数的功能相同，都是所传参数的次方的结果值</td></tr><tr><td>SIN</td><td>求正弦值</td></tr><tr><td>ASIN</td><td>求反正弦值，与函数 SIN 互为反函数</td></tr><tr><td>COS</td><td>求余弦值</td></tr><tr><td>ACOS</td><td>求反余弦值，与函数 COS 互为反函数</td></tr><tr><td>TAN</td><td>求正切值</td></tr><tr><td>ATAN</td><td>求反正切值，与函数 TAN 互为反函数</td></tr><tr><td>COT</td><td>求余切值</td></tr></tbody></table><p>字符串函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>LENGTH</td><td>计算字符串长度函数，返回字符串的字节长度</td></tr><tr><td>CONCAT</td><td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td></tr><tr><td>INSERT</td><td>替换字符串函数</td></tr><tr><td>LOWER</td><td>将字符串中的字母转换为小写</td></tr><tr><td>UPPER</td><td>将字符串中的字母转换为大写</td></tr><tr><td>LEFT</td><td>从左侧字截取符串，返回字符串左边的若干个字符</td></tr><tr><td>RIGHT</td><td>从右侧字截取符串，返回字符串右边的若干个字符</td></tr><tr><td>TRIM</td><td>删除字符串左右两侧的空格</td></tr><tr><td>REPLACE</td><td>字符串替换函数，返回替换后的新字符串</td></tr><tr><td>SUBSTRING</td><td>截取字符串，返回从指定位置开始的指定长度的字符换</td></tr><tr><td>REVERSE</td><td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td></tr></tbody></table><p>日期函数</p><table><thead><tr><th>函数名称</th><th>作 用</th></tr></thead><tbody><tr><td>CURDATE 和 CURRENT_DATE</td><td>两个函数作用相同，返回当前系统的日期值</td></tr><tr><td>CURTIME 和 CURRENT_TIME</td><td>两个函数作用相同，返回当前系统的时间值</td></tr><tr><td>NOW 和  SYSDATE</td><td>两个函数作用相同，返回当前系统的日期和时间值</td></tr><tr><td>MONTH</td><td>获取指定日期中的月份</td></tr><tr><td>MONTHNAME</td><td>获取指定日期中的月份英文名称</td></tr><tr><td>DAYNAME</td><td>获取指定曰期对应的星期几的英文名称</td></tr><tr><td>DAYOFWEEK</td><td>获取指定日期对应的一周的索引位置值</td></tr><tr><td>WEEK</td><td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td></tr><tr><td>DAYOFYEAR</td><td>获取指定曰期是一年中的第几天，返回值范围是1~366</td></tr><tr><td>DAYOFMONTH</td><td>获取指定日期是一个月中是第几天，返回值范围是1~31</td></tr><tr><td>YEAR</td><td>获取年份，返回值范围是 1970〜2069</td></tr><tr><td>TIME_TO_SEC</td><td>将时间参数转换为秒数</td></tr><tr><td>SEC_TO_TIME</td><td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td></tr><tr><td>DATE_ADD 和 ADDDATE</td><td>两个函数功能相同，都是向日期添加指定的时间间隔</td></tr><tr><td>DATE_SUB 和 SUBDATE</td><td>两个函数功能相同，都是向日期减去指定的时间间隔</td></tr><tr><td>ADDTIME</td><td>时间加法运算，在原始时间上添加指定的时间</td></tr><tr><td>SUBTIME</td><td>时间减法运算，在原始时间上减去指定的时间</td></tr><tr><td>DATEDIFF</td><td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td></tr><tr><td>DATE_FORMAT</td><td>格式化指定的日期，根据参数返回指定格式的值</td></tr><tr><td>WEEKDAY</td><td>获取指定日期在一周内的对应的工作日索引</td></tr></tbody></table><p>聚合函数</p><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>MAX</td><td>查询指定列的最大值</td></tr><tr><td>MIN</td><td>查询指定列的最小值</td></tr><tr><td>COUNT</td><td>统计查询结果的行数</td></tr><tr><td>SUM</td><td>求和，返回指定列的总和</td></tr><tr><td>AVG</td><td>求平均值，返回指定列数据的平均值</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql优化</title>
    <link href="/2021/08/26/14.1%20mysql%E4%BC%98%E5%8C%9601/"/>
    <url>/2021/08/26/14.1%20mysql%E4%BC%98%E5%8C%9601/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql高级-day02"><a href="#Mysql高级-day02" class="headerlink" title="Mysql高级-day02"></a>Mysql高级-day02</h1><h3 id="1-Mysql的体系结构概览"><a href="#1-Mysql的体系结构概览" class="headerlink" title="1. Mysql的体系结构概览"></a>1. Mysql的体系结构概览</h3><p><img src="/images/000001.jpg" alt="171214401286615"> </p><p>整个MySQL Server由以下组成</p><ul><li>Connection Pool : 连接池组件</li><li>Management Services &amp; Utilities : 管理服务和工具组件</li><li>SQL Interface : SQL接口组件</li><li>Parser : 查询分析器组件</li><li>Optimizer : 优化器组件</li><li>Caches &amp; Buffers : 缓冲池组件</li><li>Pluggable Storage Engines : 存储引擎</li><li>File System : 文件系统</li></ul><p>1） 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2） 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3） 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p><p>4）存储层</p><p>数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h3 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h3><h4 id="2-1-存储引擎概述"><a href="#2-1-存储引擎概述" class="headerlink" title="2.1 存储引擎概述"></a>2.1 存储引擎概述</h4><p>​    和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p><p>​    存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</p><p>​    Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p><p>​    MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p><p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： </p><p><img src="/images/1551186043529.png" alt="1551186043529"> </p><p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p><p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&#x27;%storage_engine%&#x27;</span> ； <br></code></pre></td></tr></table></figure><p><img src="/images/1556086372754.png" alt="1556086372754">       </p><h4 id="2-2-各种存储引擎特性"><a href="#2-2-各种存储引擎特性" class="headerlink" title="2.2 各种存储引擎特性"></a>2.2 各种存储引擎特性</h4><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： </p><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th><th>MERGE</th><th>NDB</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td><td>没有</td><td>有</td></tr><tr><td>事务安全</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr><tr><td>锁机制</td><td>==行锁(适合高并发)==</td><td>==表锁==</td><td>表锁</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td></td><td></td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>数据索引</td><td>支持</td><td></td><td>支持</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td></td><td>支持</td><td></td><td></td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>==支持==</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p><h5 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h5><p>​    InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p><p>InnoDB存储引擎不同于其他存储引擎的特点 ： </p><p><strong>事务控制</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods_innodb(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(id)<br>)ENGINE<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> goods_innodb(id,<span class="hljs-type">name</span>)<span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Meta20&#x27;</span>);<br><br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556075130115.png" alt="1556075130115"> </p><p>测试，发现在InnoDB中是存在事务的 ；</p><p><strong>外键约束</strong></p><p>​    MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p><p>​    下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> country_innodb(<br>country_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    country_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(country_id)<br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> city_innodb(<br>city_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    city_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    country_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(city_id),<br>    key idx_fk_country_id(country_id),<br>    <span class="hljs-keyword">CONSTRAINT</span> `fk_city_country` <span class="hljs-keyword">FOREIGN</span> KEY(country_id) <span class="hljs-keyword">REFERENCES</span> country_innodb(country_id) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> RESTRICT <span class="hljs-keyword">ON</span> UPDATE CASCADE<br>)ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> country_innodb <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;China&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;America&#x27;</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Japan&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> city_innodb <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Xian&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;NewYork&#x27;</span>,<span class="hljs-number">2</span>),(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;BeiJing&#x27;</span>,<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</p><p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p><p>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</p><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p><p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p><p>表中数据如下图所示 ： </p><p><img src="/images/1556087540767.png" alt="1556087540767"> </p><p>外键信息可以使用如下两种方式查看 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> city_innodb ;<br></code></pre></td></tr></table></figure><p><img src="/images/1556087611295.png" alt="1556087611295">     </p><p>删除country_id为1 的country数据： </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> country_innodb <span class="hljs-keyword">where</span> country_id = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556087719145.png" alt="1556087719145"> </p><p>更新主表country表的字段 country_id : </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> country_innodb <span class="hljs-keyword">set</span> country_id = <span class="hljs-number">100</span> <span class="hljs-keyword">where</span> country_id = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556087759615.png" alt="1556087759615">  </p><p>更新后， 子表的数据信息为 ： </p><p><img src="/images/1556087793738.png" alt="1556087793738">  </p><p><strong>存储方式</strong>    </p><p>InnoDB 存储表和索引有以下两种方式 ： </p><p>①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p><p>②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p><p><img src="/images/1556075336630.png" alt="1556075336630"> </p><h5 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h5><p>​    MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： </p><p><strong>不支持事务</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> goods_myisam(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key(id)<br>)ENGINE<span class="hljs-operator">=</span>myisam <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><img src="/images/1551347590309.png" alt="1551347590309"> </p><p>通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；</p><p><strong>文件存储方式</strong></p><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p><p>.frm (存储表定义)；</p><p>.MYD(MYData , 存储数据)；</p><p>.MYI(MYIndex , 存储索引)；</p><p><img src="/images/1556075073836.png" alt="1556075073836"> </p><h5 id="2-2-3-MEMORY"><a href="#2-2-3-MEMORY" class="headerlink" title="2.2.3 MEMORY"></a>2.2.3 MEMORY</h5><p>​    Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p><h5 id="2-2-4-MERGE"><a href="#2-2-4-MERGE" class="headerlink" title="2.2.4 MERGE"></a>2.2.4 MERGE</h5><p>​    MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p><p>​    对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p><p>​    可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p><p><img src="/images/1556076359503.png" alt="1556076359503"> </p><p>下面是一个创建和使用MERGE表的示例 ： </p><p>1）. 创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_1990(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> myisam <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_1991(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> myisam <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_all(<br>order_id <span class="hljs-type">int</span> ,<br>order_money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>order_address <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">primary</span> key (order_id)<br>)engine <span class="hljs-operator">=</span> <span class="hljs-keyword">merge</span> <span class="hljs-keyword">union</span> <span class="hljs-operator">=</span> (order_1990,order_1991) INSERT_METHOD<span class="hljs-operator">=</span><span class="hljs-keyword">LAST</span> <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><br></code></pre></td></tr></table></figure><p>2）. 分别向两张表中插入记录 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1990 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100.0</span>,<span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1990 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">100.0</span>,<span class="hljs-string">&#x27;上海&#x27;</span>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1991 <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-number">200.0</span>,<span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_1991 <span class="hljs-keyword">values</span>(<span class="hljs-number">11</span>,<span class="hljs-number">200.0</span>,<span class="hljs-string">&#x27;上海&#x27;</span>);<br></code></pre></td></tr></table></figure><p>3）. 查询3张表中的数据。</p><p>order_1990中的数据 ： </p><p><img src="/images/1551408083254.png" alt="1551408083254"> </p><p>order_1991中的数据 ： </p><p><img src="/images/1551408133323.png" alt="1551408133323">  </p><p>order_all中的数据 ：</p><p><img src="/images/1551408216185.png" alt="1551408216185"> </p><p>​     </p><p>4）. 往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_all <span class="hljs-keyword">values</span>(<span class="hljs-number">100</span>,<span class="hljs-number">10000.0</span>,<span class="hljs-string">&#x27;西安&#x27;</span>)；<br></code></pre></td></tr></table></figure><p><img src="/images/1551408519889.png" alt="1551408519889">          </p><h4 id="2-3-存储引擎的选择"><a href="#2-3-存储引擎的选择" class="headerlink" title="2.3 存储引擎的选择"></a>2.3 存储引擎的选择</h4><p>​    在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p><ul><li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li><li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li></ul><h3 id="3-优化SQL步骤"><a href="#3-优化SQL步骤" class="headerlink" title="3. 优化SQL步骤"></a>3. 优化SQL步骤</h3><p>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p><h4 id="3-1-查看SQL执行频率"><a href="#3-1-查看SQL执行频率" class="headerlink" title="3.1 查看SQL执行频率"></a>3.1 查看SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p><p>下面的命令显示了当前 session 中所有统计参数的值：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1552487172501.png" alt="1552487172501">  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Innodb_rows_%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1552487245859.png" alt="1552487245859"></p><p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p><table><thead><tr><th align="left">参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">Com_select</td><td>执行 select 操作的次数，一次查询只累加 1。</td></tr><tr><td align="left">Com_insert</td><td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td></tr><tr><td align="left">Com_update</td><td>执行 UPDATE 操作的次数。</td></tr><tr><td align="left">Com_delete</td><td>执行 DELETE 操作的次数。</td></tr><tr><td align="left">Innodb_rows_read</td><td>select 查询返回的行数。</td></tr><tr><td align="left">Innodb_rows_inserted</td><td>执行 INSERT 操作插入的行数。</td></tr><tr><td align="left">Innodb_rows_updated</td><td>执行 UPDATE 操作更新的行数。</td></tr><tr><td align="left">Innodb_rows_deleted</td><td>执行 DELETE 操作删除的行数。</td></tr><tr><td align="left">Connections</td><td>试图连接 MySQL 服务器的次数。</td></tr><tr><td align="left">Uptime</td><td>服务器工作时间。</td></tr><tr><td align="left">Slow_queries</td><td>慢查询的次数。</td></tr></tbody></table><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p><h4 id="3-2-定位低效率执行SQL"><a href="#3-2-定位低效率执行SQL" class="headerlink" title="3.2 定位低效率执行SQL"></a>3.2 定位低效率执行SQL</h4><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</li><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p><img src="/images/1556098544349.png" alt="1556098544349"> </p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-number">1</span>） id列，用户登录mysql时，系统分配的<span class="hljs-string">&quot;connection_id&quot;</span>，可以使用函数connection_id()查看<br><br><span class="hljs-number">2</span>） <span class="hljs-keyword">user</span>列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句<br><br><span class="hljs-number">3</span>） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户<br><br><span class="hljs-number">4</span>） db列，显示这个进程目前连接的是哪个数据库<br><br><span class="hljs-number">5</span>） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等<br><br><span class="hljs-number">6</span>） time列，显示这个状态持续的时间，单位是秒<br><br><span class="hljs-number">7</span>） <span class="hljs-keyword">state</span>列，显示使用当前连接的sql语句的状态，很重要的列。<span class="hljs-keyword">state</span>描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying <span class="hljs-keyword">to</span> tmp <span class="hljs-built_in">table</span>、sorting result、sending data等状态才可以完成<br><br><span class="hljs-number">8</span>） info列，显示这个sql语句，是判断问题语句的一个重要依据<br></code></pre></td></tr></table></figure><h4 id="3-3-explain分析执行计划"><a href="#3-3-explain分析执行计划" class="headerlink" title="3.3 explain分析执行计划"></a>3.3 explain分析执行计划</h4><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><p>查询SQL语句的执行计划 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1552487489859.png" alt="1552487489859"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain  <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;阿尔卡特 (OT-979) 冰川白 联通3G手机3&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1552487526919.png" alt="1552487526919">  </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>type</td><td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>rows</td><td>扫描行的数量</td></tr><tr><td>extra</td><td>执行情况的说明和描述</td></tr></tbody></table><h5 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h5><p><img src="/images/1556122799330.png" alt="1556122799330"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_role` (<br>  `id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_role` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> auto_increment ,<br>  `user_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `role_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `fk_ur_user_id` (`user_id`),<br>  KEY `fk_ur_role_id` (`role_id`),<br>  <span class="hljs-keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="hljs-keyword">FOREIGN</span> KEY (`role_id`) <span class="hljs-keyword">REFERENCES</span> `t_role` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-keyword">ON</span> UPDATE <span class="hljs-keyword">NO</span> ACTION,<br>  <span class="hljs-keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="hljs-keyword">FOREIGN</span> KEY (`user_id`) <span class="hljs-keyword">REFERENCES</span> `t_user` (`id`) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">NO</span> ACTION <span class="hljs-keyword">ON</span> UPDATE <span class="hljs-keyword">NO</span> ACTION<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><br><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;super&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;系统管理员&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;itcast&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="hljs-string">&#x27;test02&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;stu1&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="hljs-string">&#x27;学生1&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;stu2&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="hljs-string">&#x27;学生2&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;t1&#x27;</span>,<span class="hljs-string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="hljs-string">&#x27;老师1&#x27;</span>);<br><br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;学生&#x27;</span>,<span class="hljs-string">&#x27;student&#x27;</span>,<span class="hljs-string">&#x27;学生&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;老师&#x27;</span>,<span class="hljs-string">&#x27;teacher&#x27;</span>,<span class="hljs-string">&#x27;老师&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;教学管理员&#x27;</span>,<span class="hljs-string">&#x27;teachmanager&#x27;</span>,<span class="hljs-string">&#x27;教学管理员&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;管理员&#x27;</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;管理员&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>,<span class="hljs-string">&#x27;super&#x27;</span>,<span class="hljs-string">&#x27;超级管理员&#x27;</span>);<br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_role(id,user_id,role_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>) ;<br><br><br></code></pre></td></tr></table></figure><h5 id="3-3-2-explain-之-id"><a href="#3-3-2-explain-之-id" class="headerlink" title="3.3.2 explain 之 id"></a>3.3.2 explain 之 id</h5><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p><p>1） id 相同表示加载表的顺序是从上到下。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">explain select * <span class="hljs-keyword">from</span> t_role r, t_user u, user_role ur <span class="hljs-keyword">where</span> r.<span class="hljs-built_in">id</span> = ur.role_id <span class="hljs-keyword">and</span> u.<span class="hljs-built_in">id</span> = ur.user_id ;<br></code></pre></td></tr></table></figure><p><img src="/images/1556102471304.png" alt="1556102471304"></p><p>2） id 不同id值越大，优先级越高，越先被执行。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_role <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> role_id <span class="hljs-keyword">FROM</span> user_role <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;stu1&#x27;</span>))<br></code></pre></td></tr></table></figure><p><img src="/images/1556103009534.png" alt="1556103009534"> </p><p>3） id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_role r , (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_role ur <span class="hljs-keyword">WHERE</span> ur.`user_id` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2&#x27;</span>) a <span class="hljs-keyword">WHERE</span> r.id <span class="hljs-operator">=</span> a.role_id ; <br></code></pre></td></tr></table></figure><p><img src="/images/1556103294182.png" alt="1556103294182"> </p><h5 id="3-3-3-explain-之-select-type"><a href="#3-3-3-explain-之-select-type" class="headerlink" title="3.3.3 explain 之 select_type"></a>3.3.3 explain 之 select_type</h5><p> 表示 SELECT 的类型，常见的取值，如下表所示：</p><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单的select查询，查询中不包含子查询或者UNION</td></tr><tr><td>PRIMARY</td><td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td></tr><tr><td>SUBQUERY</td><td>在SELECT 或 WHERE 列表中包含了子查询</td></tr><tr><td>DERIVED</td><td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td></tr><tr><td>UNION</td><td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td></tr><tr><td>UNION RESULT</td><td>从UNION表获取结果的SELECT</td></tr></tbody></table><h5 id="3-3-4-explain-之-table"><a href="#3-3-4-explain-之-table" class="headerlink" title="3.3.4 explain 之 table"></a>3.3.4 explain 之 table</h5><p>展示这一行的数据是关于哪一张表的 </p><h5 id="3-3-5-explain-之-type"><a href="#3-3-5-explain-之-type" class="headerlink" title="3.3.5 explain 之 type"></a>3.3.5 explain 之 type</h5><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>MySQL不访问任何表，索引，直接返回结果</td></tr><tr><td>system</td><td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td></tr><tr><td>const</td><td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td></tr><tr><td>eq_ref</td><td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td></tr><tr><td>range</td><td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td></tr><tr><td>index</td><td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td></tr><tr><td>all</td><td>将遍历全表以找到匹配的行</td></tr></tbody></table><p>结果值从最好到最坏以此是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">NULL</span> &gt; <span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span><br><br><br><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>==一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。==</p><h5 id="3-3-6-explain-之-key"><a href="#3-3-6-explain-之-key" class="headerlink" title="3.3.6 explain 之  key"></a>3.3.6 explain 之  key</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 <br><br>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。<br><br>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。<br></code></pre></td></tr></table></figure><h5 id="3-3-7-explain-之-rows"><a href="#3-3-7-explain-之-rows" class="headerlink" title="3.3.7 explain 之 rows"></a>3.3.7 explain 之 rows</h5><p>扫描行的数量。</p><h5 id="3-3-8-explain-之-extra"><a href="#3-3-8-explain-之-extra" class="headerlink" title="3.3.8 explain 之 extra"></a>3.3.8 explain 之 extra</h5><p>其他的额外的执行计划信息，在该列展示 。</p><table><thead><tr><th>extra</th><th>含义</th></tr></thead><tbody><tr><td>using  filesort</td><td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td></tr><tr><td>using  temporary</td><td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td></tr><tr><td>using  index</td><td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td></tr></tbody></table><h4 id="3-4-show-profile分析SQL"><a href="#3-4-show-profile分析SQL" class="headerlink" title="3.4 show profile分析SQL"></a>3.4 show profile分析SQL</h4><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p><p><img src="/images/1552488401999.png" alt="1552488401999"> </p><p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p><p><img src="/images/1552488372405.png" alt="1552488372405"> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>开启profiling 开关；<br></code></pre></td></tr></table></figure><p>通过profile，我们能够更清楚地了解SQL执行的过程。</p><p>首先，我们可以执行一系列的操作，如下图所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br><br>use db01;<br><br><span class="hljs-keyword">show</span> tables;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_item;<br></code></pre></td></tr></table></figure><p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p><p><img src="/images/1552489017940.png" alt="1552489017940">  </p><p>通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p><p><img src="/images/1552489053763.png" alt="1552489053763"> </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">TIP ：<br>Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。<br></code></pre></td></tr></table></figure><p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</p><p><img src="/images/1552489671119.png" alt="1552489671119"> </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Status</td><td>sql 语句执行的状态</td></tr><tr><td>Duration</td><td>sql 执行过程中每一个步骤的耗时</td></tr><tr><td>CPU_user</td><td>当前用户占有的cpu</td></tr><tr><td>CPU_system</td><td>系统占有的cpu</td></tr></tbody></table><h4 id="3-5-trace分析优化器执行计划"><a href="#3-5-trace分析优化器执行计划" class="headerlink" title="3.5 trace分析优化器执行计划"></a>3.5 trace分析优化器执行计划</h4><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br><span class="hljs-keyword">set</span> optimizer_trace_max_mem_size<span class="hljs-operator">=</span><span class="hljs-number">1000000</span>;<br></code></pre></td></tr></table></figure><p>执行SQL语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs json">*************************** <span class="hljs-number">1.</span> row ***************************<br>QUERY: select * from tb_item where id &lt; <span class="hljs-number">4</span><br>TRACE: &#123;<br>  <span class="hljs-attr">&quot;steps&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;join_preparation&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;select#&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">&quot;steps&quot;</span>: [<br>          &#123;<br>            <span class="hljs-attr">&quot;expanded_query&quot;</span>: <span class="hljs-string">&quot;/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)&quot;</span><br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; <span class="hljs-comment">/* join_preparation */</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;join_optimization&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;select#&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">&quot;steps&quot;</span>: [<br>          &#123;<br>            <span class="hljs-attr">&quot;condition_processing&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;condition&quot;</span>: <span class="hljs-string">&quot;WHERE&quot;</span>,<br>              <span class="hljs-attr">&quot;original_condition&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span>,<br>              <span class="hljs-attr">&quot;steps&quot;</span>: [<br>                &#123;<br>                  <span class="hljs-attr">&quot;transformation&quot;</span>: <span class="hljs-string">&quot;equality_propagation&quot;</span>,<br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                &#125;,<br>                &#123;<br>                  <span class="hljs-attr">&quot;transformation&quot;</span>: <span class="hljs-string">&quot;constant_propagation&quot;</span>,<br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                &#125;,<br>                &#123;<br>                  <span class="hljs-attr">&quot;transformation&quot;</span>: <span class="hljs-string">&quot;trivial_condition_removal&quot;</span>,<br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                &#125;<br>              ] <span class="hljs-comment">/* steps */</span><br>            &#125; <span class="hljs-comment">/* condition_processing */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;table_dependencies&quot;</span>: [<br>              &#123;<br>                <span class="hljs-attr">&quot;table&quot;</span>: <span class="hljs-string">&quot;`tb_item`&quot;</span>,<br>                <span class="hljs-attr">&quot;row_may_be_null&quot;</span>: <span class="hljs-literal">false</span>,<br>                <span class="hljs-attr">&quot;map_bit&quot;</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-attr">&quot;depends_on_map_bits&quot;</span>: [<br>                ] <span class="hljs-comment">/* depends_on_map_bits */</span><br>              &#125;<br>            ] <span class="hljs-comment">/* table_dependencies */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;ref_optimizer_key_uses&quot;</span>: [<br>            ] <span class="hljs-comment">/* ref_optimizer_key_uses */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;rows_estimation&quot;</span>: [<br>              &#123;<br>                <span class="hljs-attr">&quot;table&quot;</span>: <span class="hljs-string">&quot;`tb_item`&quot;</span>,<br>                <span class="hljs-attr">&quot;range_analysis&quot;</span>: &#123;<br>                  <span class="hljs-attr">&quot;table_scan&quot;</span>: &#123;<br>                    <span class="hljs-attr">&quot;rows&quot;</span>: <span class="hljs-number">9816098</span>,<br>                    <span class="hljs-attr">&quot;cost&quot;</span>: <span class="hljs-number">2.04e6</span><br>                  &#125; <span class="hljs-comment">/* table_scan */</span>,<br>                  <span class="hljs-attr">&quot;potential_range_indices&quot;</span>: [<br>                    &#123;<br>                      <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;PRIMARY&quot;</span>,<br>                      <span class="hljs-attr">&quot;usable&quot;</span>: <span class="hljs-literal">true</span>,<br>                      <span class="hljs-attr">&quot;key_parts&quot;</span>: [<br>                        <span class="hljs-string">&quot;id&quot;</span><br>                      ] <span class="hljs-comment">/* key_parts */</span><br>                    &#125;<br>                  ] <span class="hljs-comment">/* potential_range_indices */</span>,<br>                  <span class="hljs-attr">&quot;setup_range_conditions&quot;</span>: [<br>                  ] <span class="hljs-comment">/* setup_range_conditions */</span>,<br>                  <span class="hljs-attr">&quot;group_index_range&quot;</span>: &#123;<br>                    <span class="hljs-attr">&quot;chosen&quot;</span>: <span class="hljs-literal">false</span>,<br>                    <span class="hljs-attr">&quot;cause&quot;</span>: <span class="hljs-string">&quot;not_group_by_or_distinct&quot;</span><br>                  &#125; <span class="hljs-comment">/* group_index_range */</span>,<br>                  <span class="hljs-attr">&quot;analyzing_range_alternatives&quot;</span>: &#123;<br>                    <span class="hljs-attr">&quot;range_scan_alternatives&quot;</span>: [<br>                      &#123;<br>                        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;PRIMARY&quot;</span>,<br>                        <span class="hljs-attr">&quot;ranges&quot;</span>: [<br>                          <span class="hljs-string">&quot;id &lt; 4&quot;</span><br>                        ] <span class="hljs-comment">/* ranges */</span>,<br>                        <span class="hljs-attr">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="hljs-literal">true</span>,<br>                        <span class="hljs-attr">&quot;rowid_ordered&quot;</span>: <span class="hljs-literal">true</span>,<br>                        <span class="hljs-attr">&quot;using_mrr&quot;</span>: <span class="hljs-literal">false</span>,<br>                        <span class="hljs-attr">&quot;index_only&quot;</span>: <span class="hljs-literal">false</span>,<br>                        <span class="hljs-attr">&quot;rows&quot;</span>: <span class="hljs-number">3</span>,<br>                        <span class="hljs-attr">&quot;cost&quot;</span>: <span class="hljs-number">1.6154</span>,<br>                        <span class="hljs-attr">&quot;chosen&quot;</span>: <span class="hljs-literal">true</span><br>                      &#125;<br>                    ] <span class="hljs-comment">/* range_scan_alternatives */</span>,<br>                    <span class="hljs-attr">&quot;analyzing_roworder_intersect&quot;</span>: &#123;<br>                      <span class="hljs-attr">&quot;usable&quot;</span>: <span class="hljs-literal">false</span>,<br>                      <span class="hljs-attr">&quot;cause&quot;</span>: <span class="hljs-string">&quot;too_few_roworder_scans&quot;</span><br>                    &#125; <span class="hljs-comment">/* analyzing_roworder_intersect */</span><br>                  &#125; <span class="hljs-comment">/* analyzing_range_alternatives */</span>,<br>                  <span class="hljs-attr">&quot;chosen_range_access_summary&quot;</span>: &#123;<br>                    <span class="hljs-attr">&quot;range_access_plan&quot;</span>: &#123;<br>                      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;range_scan&quot;</span>,<br>                      <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;PRIMARY&quot;</span>,<br>                      <span class="hljs-attr">&quot;rows&quot;</span>: <span class="hljs-number">3</span>,<br>                      <span class="hljs-attr">&quot;ranges&quot;</span>: [<br>                        <span class="hljs-string">&quot;id &lt; 4&quot;</span><br>                      ] <span class="hljs-comment">/* ranges */</span><br>                    &#125; <span class="hljs-comment">/* range_access_plan */</span>,<br>                    <span class="hljs-attr">&quot;rows_for_plan&quot;</span>: <span class="hljs-number">3</span>,<br>                    <span class="hljs-attr">&quot;cost_for_plan&quot;</span>: <span class="hljs-number">1.6154</span>,<br>                    <span class="hljs-attr">&quot;chosen&quot;</span>: <span class="hljs-literal">true</span><br>                  &#125; <span class="hljs-comment">/* chosen_range_access_summary */</span><br>                &#125; <span class="hljs-comment">/* range_analysis */</span><br>              &#125;<br>            ] <span class="hljs-comment">/* rows_estimation */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;considered_execution_plans&quot;</span>: [<br>              &#123;<br>                <span class="hljs-attr">&quot;plan_prefix&quot;</span>: [<br>                ] <span class="hljs-comment">/* plan_prefix */</span>,<br>                <span class="hljs-attr">&quot;table&quot;</span>: <span class="hljs-string">&quot;`tb_item`&quot;</span>,<br>                <span class="hljs-attr">&quot;best_access_path&quot;</span>: &#123;<br>                  <span class="hljs-attr">&quot;considered_access_paths&quot;</span>: [<br>                    &#123;<br>                      <span class="hljs-attr">&quot;access_type&quot;</span>: <span class="hljs-string">&quot;range&quot;</span>,<br>                      <span class="hljs-attr">&quot;rows&quot;</span>: <span class="hljs-number">3</span>,<br>                      <span class="hljs-attr">&quot;cost&quot;</span>: <span class="hljs-number">2.2154</span>,<br>                      <span class="hljs-attr">&quot;chosen&quot;</span>: <span class="hljs-literal">true</span><br>                    &#125;<br>                  ] <span class="hljs-comment">/* considered_access_paths */</span><br>                &#125; <span class="hljs-comment">/* best_access_path */</span>,<br>                <span class="hljs-attr">&quot;cost_for_plan&quot;</span>: <span class="hljs-number">2.2154</span>,<br>                <span class="hljs-attr">&quot;rows_for_plan&quot;</span>: <span class="hljs-number">3</span>,<br>                <span class="hljs-attr">&quot;chosen&quot;</span>: <span class="hljs-literal">true</span><br>              &#125;<br>            ] <span class="hljs-comment">/* considered_execution_plans */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;attaching_conditions_to_tables&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;original_condition&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span>,<br>              <span class="hljs-attr">&quot;attached_conditions_computation&quot;</span>: [<br>              ] <span class="hljs-comment">/* attached_conditions_computation */</span>,<br>              <span class="hljs-attr">&quot;attached_conditions_summary&quot;</span>: [<br>                &#123;<br>                  <span class="hljs-attr">&quot;table&quot;</span>: <span class="hljs-string">&quot;`tb_item`&quot;</span>,<br>                  <span class="hljs-attr">&quot;attached&quot;</span>: <span class="hljs-string">&quot;(`tb_item`.`id` &lt; 4)&quot;</span><br>                &#125;<br>              ] <span class="hljs-comment">/* attached_conditions_summary */</span><br>            &#125; <span class="hljs-comment">/* attaching_conditions_to_tables */</span><br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">&quot;refine_plan&quot;</span>: [<br>              &#123;<br>                <span class="hljs-attr">&quot;table&quot;</span>: <span class="hljs-string">&quot;`tb_item`&quot;</span>,<br>                <span class="hljs-attr">&quot;access_type&quot;</span>: <span class="hljs-string">&quot;range&quot;</span><br>              &#125;<br>            ] <span class="hljs-comment">/* refine_plan */</span><br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; <span class="hljs-comment">/* join_optimization */</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;join_execution&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;select#&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">&quot;steps&quot;</span>: [<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; <span class="hljs-comment">/* join_execution */</span><br>    &#125;<br>  ] <span class="hljs-comment">/* steps */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h3><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p><h4 id="4-1-验证索引提升查询效率"><a href="#4-1-验证索引提升查询效率" class="headerlink" title="4.1 验证索引提升查询效率"></a>4.1 验证索引提升查询效率</h4><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p><p>A. 根据ID查询 </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> = <span class="hljs-number">1999</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/1553261992653.png" alt="1553261992653"> </p><p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p><p><img src="/images/1553262044466.png" alt="1553262044466"> </p><p>2). 根据 title 进行精确查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_item <span class="hljs-keyword">where</span> title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;iphoneX 移动3G 32G941&#x27;</span>\G; <br></code></pre></td></tr></table></figure><p><img src="/images/1553262215900.png" alt="1553262215900"> </p><p>查看SQL语句的执行计划 ： </p><p><img src="/images/1553262469785.png" alt="1553262469785"> </p><p>处理方案 ， 针对title字段， 创建索引 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_item_title <span class="hljs-keyword">on</span> tb_item(title);<br></code></pre></td></tr></table></figure><p><img src="/images/1553263229523.png" alt="1553263229523"> </p><p>索引创建完成之后，再次进行查询 ： </p><p><img src="/images/1553263302706.png" alt="1553263302706"> </p><p>通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 </p><p><img src="/images/1553263355262.png" alt="1553263355262"> </p><h4 id="4-2-索引的使用"><a href="#4-2-索引的使用" class="headerlink" title="4.2 索引的使用"></a>4.2 索引的使用</h4><h5 id="4-2-1-准备环境"><a href="#4-2-1-准备环境" class="headerlink" title="4.2.1 准备环境"></a>4.2.1 准备环境</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `tb_seller` (<br>`sellerid` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`name` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`nickname` <span class="hljs-type">varchar</span> (<span class="hljs-number">50</span>),<br>`password` <span class="hljs-type">varchar</span> (<span class="hljs-number">60</span>),<br>`status` <span class="hljs-type">varchar</span> (<span class="hljs-number">1</span>),<br>`address` <span class="hljs-type">varchar</span> (<span class="hljs-number">100</span>),<br>`createtime` datetime,<br>    <span class="hljs-keyword">primary</span> key(`sellerid`)<br>)engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8mb4; <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;alibaba&#x27;</span>,<span class="hljs-string">&#x27;阿里巴巴&#x27;</span>,<span class="hljs-string">&#x27;阿里小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;baidu&#x27;</span>,<span class="hljs-string">&#x27;百度科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;百度小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;huawei&#x27;</span>,<span class="hljs-string">&#x27;华为科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;华为小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;itcast&#x27;</span>,<span class="hljs-string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;传智播客&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;itheima&#x27;</span>,<span class="hljs-string">&#x27;黑马程序员&#x27;</span>,<span class="hljs-string">&#x27;黑马程序员&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;luoji&#x27;</span>,<span class="hljs-string">&#x27;罗技科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;罗技小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;oppo&#x27;</span>,<span class="hljs-string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;ourpalm&#x27;</span>,<span class="hljs-string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="hljs-string">&#x27;掌趣小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;qiandu&#x27;</span>,<span class="hljs-string">&#x27;千度科技&#x27;</span>,<span class="hljs-string">&#x27;千度小店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;sina&#x27;</span>,<span class="hljs-string">&#x27;新浪科技有限公司&#x27;</span>,<span class="hljs-string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;xiaomi&#x27;</span>,<span class="hljs-string">&#x27;小米科技&#x27;</span>,<span class="hljs-string">&#x27;小米官方旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;西安市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;yijia&#x27;</span>,<span class="hljs-string">&#x27;宜家家居&#x27;</span>,<span class="hljs-string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="hljs-string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;北京市&#x27;</span>,<span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>);<br><br><br><span class="hljs-keyword">create</span> index idx_seller_name_sta_addr <span class="hljs-keyword">on</span> tb_seller(name,status,address);<br></code></pre></td></tr></table></figure><h5 id="4-2-2-避免索引失效"><a href="#4-2-2-避免索引失效" class="headerlink" title="4.2.2 避免索引失效"></a>4.2.2 避免索引失效</h5><p>1).  全值匹配 ，对索引中所有列都指定具体值。</p><p>改情况下，索引生效，执行效率高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;小米科技&#x27;</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;北京市&#x27;</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/1556170997921.png" alt="1556170997921"> </p><p>2). 最左前缀法则</p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p><p>匹配最左前缀法则，走索引：</p><p><img src="/images/1556171348995.png" alt="1556171348995">  </p><p>违法最左前缀法则 ， 索引失效：</p><p><img src="/images/1556171428140.png" alt="1556171428140"> </p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p><p><img src="/images/1556171662203.png" alt="1556171662203"> </p><p>3). 范围查询右边的列，不能使用索引 。</p><p><img src="/images/1556172256791.png" alt="1556172256791"> </p><p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p><p>4). 不要在索引列上进行运算操作， 索引将失效。</p><p><img src="/images/1556172813715.png" alt="1556172813715"> </p><p>5). 字符串不加单引号，造成索引失效。</p><p><img src="/images/1556172967493.png" alt="1556172967493"> </p><p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p><p>6). 尽量使用覆盖索引，避免select *</p><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p><p><img src="/images/1556173928299.png" alt="1556173928299"> </p><p>如果查询列，超出索引列，也会降低性能。</p><p><img src="/images/1556173986068.png" alt="1556173986068"> </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">TIP : <br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> ：使用覆盖索引的时候就会出现<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> condition：查找使用了索引，但是需要回表查询数据<br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">index</span> ; <span class="hljs-keyword">using</span> <span class="hljs-keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据<br></code></pre></td></tr></table></figure><p>7). 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;黑马程序员&#x27;</span> <span class="hljs-keyword">or</span> createtime <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2088-01-01 12:00:00&#x27;</span>\G;<br></code></pre></td></tr></table></figure><p><img src="/images/1556174994440.png" alt="1556174994440"> </p><p>8).  以%开头的Like模糊查询，索引失效。</p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p><img src="/images/1556175114369.png" alt="1556175114369"> </p><p>解决方案 ： </p><p>通过覆盖索引来解决 </p><p><img src="/images/1556247686483.png" alt="1556247686483"> </p><p>9). 如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><img src="/images/1556175445210.png" alt="1556175445210"> </p><p>10). is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效。</p><p><img src="/images/1556180634889.png" alt="1556180634889">  </p><p>11). in 走索引， not in 索引失效。</p><p><img src="/images/1556249602732.png" alt="1556249602732">  </p><p>12). 单列索引和复合索引。</p><p>尽量使用复合索引，而少使用单列索引 。</p><p>创建复合索引 </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">create <span class="hljs-built_in">index</span> idx_name_sta_address on tb_seller(<span class="hljs-keyword">name</span>, <span class="hljs-keyword">status</span>, address);<br><br>就相当于创建了三个索引 ： <br><span class="hljs-keyword">name</span><br><span class="hljs-keyword">name</span> + <span class="hljs-keyword">status</span><br><span class="hljs-keyword">name</span> + <span class="hljs-keyword">status</span> + address<br><br></code></pre></td></tr></table></figure><p>创建单列索引 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_name <span class="hljs-keyword">on</span> tb_seller(<span class="hljs-type">name</span>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_status <span class="hljs-keyword">on</span> tb_seller(status);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_address <span class="hljs-keyword">on</span> tb_seller(address);<br></code></pre></td></tr></table></figure><p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p><h4 id="4-3-查看索引使用情况"><a href="#4-3-查看索引使用情况" class="headerlink" title="4.3 查看索引使用情况"></a>4.3 查看索引使用情况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Handler_read%&#x27;</span>;<br><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Handler_read%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1552885364563.png" alt="1552885364563"> </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。<br><br>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。<br><br>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。<br><br>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化<span class="hljs-keyword">ORDER</span> <span class="hljs-title">BY</span> ... DESC。<br><br>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。<br><br>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。<br></code></pre></td></tr></table></figure><h3 id="5-SQL优化"><a href="#5-SQL优化" class="headerlink" title="5. SQL优化"></a>5. SQL优化</h3><h4 id="5-1-大批量插入数据"><a href="#5-1-大批量插入数据" class="headerlink" title="5.1 大批量插入数据"></a>5.1 大批量插入数据</h4><p>环境准备 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user_2` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `birthday` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `sex` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `qq` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `status` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户状态&#x27;</span>,<br>  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br></code></pre></td></tr></table></figure><p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p><p><img src="/images/1556269346488.png" alt="1556269346488"> </p><p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p><p>1） 主键顺序插入</p><p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">脚本文件介绍 :<br><span class="hljs-function"><span class="hljs-title">sql1</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键有序<br><span class="hljs-function"><span class="hljs-title">sql2</span>.<span class="hljs-built_in">log</span>  ----&gt;</span> 主键无序<br></code></pre></td></tr></table></figure><p>插入ID顺序排列数据：</p><p><img src="/images/1555771750567.png" alt="1555771750567"></p><p>插入ID无序排列数据：</p><p><img src="/images/1555771959734.png" alt="1555771959734"> </p><p>2） 关闭唯一性校验</p><p>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p><p><img src="/images/1555772132736.png" alt="1555772132736"> </p><p>3） 手动提交事务</p><p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p><p><img src="/images/1555772351208.png" alt="1555772351208"></p><h4 id="5-2-优化insert语句"><a href="#5-2-优化insert语句" class="headerlink" title="5.2 优化insert语句"></a>5.2 优化insert语句</h4><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p><ul><li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p><p>示例， 原始方式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化后的方案为 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>)，(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>在事务中进行数据插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></li><li><p>数据有序插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tim&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tim&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Rose&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-3-优化order-by语句"><a href="#5-3-优化order-by语句" class="headerlink" title="5.3 优化order by语句"></a>5.3 优化order by语句</h4><h5 id="5-3-1-环境准备"><a href="#5-3-1-环境准备" class="headerlink" title="5.3.1 环境准备"></a>5.3.1 环境准备</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `emp` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `salary` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB  <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;25&#x27;</span>,<span class="hljs-string">&#x27;2300&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>,<span class="hljs-string">&#x27;30&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;Luci&#x27;</span>,<span class="hljs-string">&#x27;25&#x27;</span>,<span class="hljs-string">&#x27;2800&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-string">&#x27;36&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;Tom2&#x27;</span>,<span class="hljs-string">&#x27;21&#x27;</span>,<span class="hljs-string">&#x27;2200&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;Jerry2&#x27;</span>,<span class="hljs-string">&#x27;31&#x27;</span>,<span class="hljs-string">&#x27;3300&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;Luci2&#x27;</span>,<span class="hljs-string">&#x27;26&#x27;</span>,<span class="hljs-string">&#x27;2700&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;Jay2&#x27;</span>,<span class="hljs-string">&#x27;33&#x27;</span>,<span class="hljs-string">&#x27;3500&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&#x27;Tom3&#x27;</span>,<span class="hljs-string">&#x27;23&#x27;</span>,<span class="hljs-string">&#x27;2400&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;Jerry3&#x27;</span>,<span class="hljs-string">&#x27;32&#x27;</span>,<span class="hljs-string">&#x27;3100&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;11&#x27;</span>,<span class="hljs-string">&#x27;Luci3&#x27;</span>,<span class="hljs-string">&#x27;26&#x27;</span>,<span class="hljs-string">&#x27;2900&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;12&#x27;</span>,<span class="hljs-string">&#x27;Jay3&#x27;</span>,<span class="hljs-string">&#x27;37&#x27;</span>,<span class="hljs-string">&#x27;4500&#x27;</span>);<br><br><span class="hljs-keyword">create</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp(age,salary);<br></code></pre></td></tr></table></figure><h5 id="5-3-2-两种排序方式"><a href="#5-3-2-两种排序方式" class="headerlink" title="5.3.2 两种排序方式"></a>5.3.2 两种排序方式</h5><p>1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p><img src="/images/1556335817763.png" alt="1556335817763"> </p><p>2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p><p><img src="/images/1556335866539.png" alt="1556335866539"> </p><p>多字段排序</p><p><img src="/images/1556336352061.png" alt="1556336352061"> </p><p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order  by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p><h5 id="5-3-3-Filesort-的优化"><a href="#5-3-3-Filesort-的优化" class="headerlink" title="5.3.3 Filesort 的优化"></a>5.3.3 Filesort 的优化</h5><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p><p>1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</p><p>2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。</p><p><img src="/images/1556338367593.png" alt="1556338367593"> </p><h4 id="5-4-优化group-by-语句"><a href="#5-4-优化group-by-语句" class="headerlink" title="5.4 优化group by 语句"></a>5.4 优化group by 语句</h4><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p><p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">drop</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp;<br><br>explain <span class="hljs-keyword">select</span> age,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure><p><img src="/images/1556339573979.png" alt="1556339573979">  </p><p>优化后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> age,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556339633161.png" alt="1556339633161">  </p><p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order  by  null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p><p>创建索引 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_emp_age_salary <span class="hljs-keyword">on</span> emp(age,salary)；<br></code></pre></td></tr></table></figure><p><img src="/images/1556339688158.png" alt="1556339688158"> </p><h4 id="5-5-优化嵌套查询"><a href="#5-5-优化嵌套查询" class="headerlink" title="5.5 优化嵌套查询"></a>5.5 优化嵌套查询</h4><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p><p>示例 ，查找有角色的所有的用户信息 : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> user_id <span class="hljs-keyword">from</span> user_role );<br></code></pre></td></tr></table></figure><p>执行计划为 : </p><p><img src="/images/1556359399199.png" alt="1556359399199">   </p><p>优化后 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_user u , user_role ur <span class="hljs-keyword">where</span> u.id <span class="hljs-operator">=</span> ur.user_id;<br></code></pre></td></tr></table></figure><p><img src="/images/1556359482142.png" alt="1556359482142">   </p><p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p><h4 id="5-6-优化OR条件"><a href="#5-6-优化OR条件" class="headerlink" title="5.6 优化OR条件"></a>5.6 优化OR条件</h4><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</p><p>获取 emp 表中的所有的索引 ： </p><p><img src="/images/1556354464657.png" alt="1556354464657">  </p><p>示例 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556354887509.png" alt="1556354887509"></p><p><img src="/images/1556354920964.png" alt="1556354920964">  </p><p>建议使用 union 替换 or ： </p><p><img src="/images/1556355027728.png" alt="1556355027728"> </p><p>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</p><p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">system</span> &gt; const &gt; eq_ref &gt; <span class="hljs-keyword">ref</span> &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; <span class="hljs-keyword">index</span> &gt; <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p><p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p><p>这两项的差距就说明了 UNION 要优于 OR 。</p><h4 id="5-7-优化分页查询"><a href="#5-7-优化分页查询" class="headerlink" title="5.7 优化分页查询"></a>5.7 优化分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p><img src="/images/1556361314783.png" alt="1556361314783"> </p><h5 id="5-7-1-优化思路一"><a href="#5-7-1-优化思路一" class="headerlink" title="5.7.1 优化思路一"></a>5.7.1 优化思路一</h5><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><p><img src="/images/1556416102800.png" alt="1556416102800"> </p><h5 id="5-7-2-优化思路二"><a href="#5-7-2-优化思路二" class="headerlink" title="5.7.2 优化思路二"></a>5.7.2 优化思路二</h5><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p><p><img src="/images/1556363928151.png" alt="1556363928151"> </p><h4 id="5-8-使用SQL提示"><a href="#5-8-使用SQL提示" class="headerlink" title="5.8 使用SQL提示"></a>5.8 使用SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><h5 id="5-8-1-USE-INDEX"><a href="#5-8-1-USE-INDEX" class="headerlink" title="5.8.1 USE INDEX"></a>5.8.1 USE INDEX</h5><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_seller_name <span class="hljs-keyword">on</span> tb_seller(<span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/1556370971576.png" alt="1556370971576"> </p><h5 id="5-8-2-IGNORE-INDEX"><a href="#5-8-2-IGNORE-INDEX" class="headerlink" title="5.8.2 IGNORE INDEX"></a>5.8.2 IGNORE INDEX</h5><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_seller <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">index</span>(idx_seller_name) <span class="hljs-keyword">where</span> name = <span class="hljs-string">&#x27;小米科技&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/images/1556371004594.png" alt="1556371004594"> </p><h5 id="5-8-3-FORCE-INDEX"><a href="#5-8-3-FORCE-INDEX" class="headerlink" title="5.8.3 FORCE INDEX"></a>5.8.3 FORCE INDEX</h5><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> index idx_seller_address <span class="hljs-keyword">on</span> tb_seller(address);<br></code></pre></td></tr></table></figure><p><img src="/images/1556371355788.png" alt="1556371355788"> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库刷题详解</title>
    <link href="/2021/08/25/13.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98/"/>
    <url>/2021/08/25/13.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="001-第二高的薪水"><a href="#001-第二高的薪水" class="headerlink" title="001 第二高的薪水"></a>001 第二高的薪水</h1><p><img src="/images/image-20210825224036107.png" alt="image-20210825224036107"></p><p>注意：</p><ul><li>关于为什么要加一个子查询而不是仅用一个SELECT查询。是因为如果表中只有一条数据或者没有数据，他的查询结果为空，就不会返回一个字段名为SecondHighestSalary的表。</li><li>SELECT…AS…  既可给表取别名，也可给字段名取别名</li><li><code>LIMIT 1 OFFSET 1</code>限制返回结果只有一条数据，而且需要进行一次偏移</li><li><code>DISTINCT</code>关键字是为了避免字段记录值一样，而重复计算的情况。比如有两个100， 那么第二就会返回100，但实际他俩并列第一没有第二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT (<br>    SELECT DISTINCT Salary <br>    FROM Employee<br>    ORDER BY Salary DESC<br>    LIMIT 1 OFFSET 1<br>) AS SecondHighestSalary;<br></code></pre></td></tr></table></figure><h1 id="002-组合两个表"><a href="#002-组合两个表" class="headerlink" title="002 组合两个表"></a>002 组合两个表</h1><p><img src="/images/image-20210825230143885.png" alt="image-20210825230143885"></p><p>注意：</p><ul><li><p>这里要用到外连接查询 (分为左外连接和右外连接)</p><p>以左外连接为例，他显示的数据是左表的全部数据以及和右表有交集的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>字段名<br>FROM <br>    表名<br>LEFT (outer) JOIN <br>    表名<br>ON <br>    条件;<br></code></pre></td></tr></table></figure></li><li><p>与外连接相对应的是内连接查询 (只显示这两张表的交集)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>字段名<br>FROM <br>    表名<br>(inner) JOIN <br>    表名<br>ON <br>    条件;<br></code></pre></td></tr></table></figure></li><li><p>给表起别名的方式，下面给的是最简单的一种，省略了关键词 AS</p></li><li><p>注意下面调用表中的字段值的用法<code>p.PersonId</code>，<code>a.PersonId</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT <br>    FirstName, <br>    LastName, <br>    City, State<br>FROM <br>    Person p <br>LEFT JOIN <br>    Address a<br>ON <br>    p.PersonId = a.PersonId;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用集合概述</title>
    <link href="/2021/08/21/12.%20%E9%9B%86%E5%90%88/"/>
    <url>/2021/08/21/12.%20%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Collection-集合"><a href="#1-Collection-集合" class="headerlink" title="1. Collection 集合"></a>1. Collection 集合</h1><h2 id="1-1-数组和集合的区别"><a href="#1-1-数组和集合的区别" class="headerlink" title="1.1 数组和集合的区别"></a>1.1 数组和集合的区别</h2><ul><li><p>相同点</p><p>都是容器,可以存储多个数据</p></li><li><p>不同点</p><ul><li>数组的长度是不可变的,集合的长度是可变的</li><li>数组可以存基本数据类型和引用数据类型，集合只能存引用数据类型, 如果要存基本数据类型, 需要存对应的包装类</li></ul></li></ul><h2 id="1-2-集合类体系结构"><a href="#1-2-集合类体系结构" class="headerlink" title="1.2 集合类体系结构"></a>1.2 集合类体系结构</h2><p><img src="/images/image-20210821190159801.png" alt="image-20210821190159801"></p><h2 id="1-3-集合的遍历"><a href="#1-3-集合的遍历" class="headerlink" title="1.3 集合的遍历"></a>1.3 集合的遍历</h2><p>增强for循环</p><ul><li>它是JDK5之后出现的,其内部原理是一个Iterator迭代器</li><li>实现Iterable接口的类才可以使用迭代器和增强for</li><li>简化数组和Collection集合的遍历</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollectonDemo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;c&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;d&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;e&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;f&quot;</span>);<br><br>        <span class="hljs-comment">//1,数据类型一定是集合或者数组中元素的类型</span><br>        <span class="hljs-comment">//2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素</span><br>        <span class="hljs-comment">//3,list就是要遍历的集合或者数组</span><br>        <span class="hljs-keyword">for</span>(String str : list)&#123;<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-List集合"><a href="#1-4-List集合" class="headerlink" title="1.4 List集合"></a>1.4 List集合</h2><h3 id="1-4-1-List集合的特点"><a href="#1-4-1-List集合的特点" class="headerlink" title="1.4.1 List集合的特点"></a>1.4.1 List集合的特点</h3><p>List集合的特点</p><ul><li>存取有序</li><li>可以重复</li><li>有索引</li></ul><h3 id="1-4-2-List集合的方法"><a href="#1-4-2-List集合的方法" class="headerlink" title="1.4.2 List集合的方法"></a>1.4.2 List集合的方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void add(int index, E   element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int   index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index, E   element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int   index)</td><td>返回指定索引处的元素</td></tr></tbody></table><h3 id="1-4-3-List集合子类的特点"><a href="#1-4-3-List集合子类的特点" class="headerlink" title="1.4.3 List集合子类的特点"></a>1.4.3 List集合子类的特点</h3><ol><li><p>ArrayList集合</p><p>底层是数组结构实现，查询快、增删慢</p></li><li><p>LinkedList集合</p><p>底层是链表结构实现，查询慢、增删快</p></li></ol><h2 id="1-6-Set集合"><a href="#1-6-Set集合" class="headerlink" title="1.6 Set集合"></a>1.6 Set集合</h2><h3 id="1-6-1-Set集合概述和特点"><a href="#1-6-1-Set集合概述和特点" class="headerlink" title="1.6.1 Set集合概述和特点"></a>1.6.1 Set集合概述和特点</h3><ul><li>不可以存储重复元素</li><li>没有索引,不能使用普通for循环遍历，只能用增强for</li></ul><h3 id="1-6-2-Set集合子类TreeSet集合"><a href="#1-6-2-Set集合子类TreeSet集合" class="headerlink" title="1.6.2 Set集合子类TreeSet集合"></a>1.6.2 Set集合子类TreeSet集合</h3><ul><li>不可以存储重复元素</li><li>没有索引</li><li>可以将元素按照规则进行排序</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSetDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建集合对象</span><br>        TreeSet&lt;Integer&gt; ts = <span class="hljs-keyword">new</span> TreeSet&lt;Integer&gt;();<br><br>        <span class="hljs-comment">//添加元素</span><br>        ts.add(<span class="hljs-number">10</span>);<br>        ts.add(<span class="hljs-number">40</span>);<br>        ts.add(<span class="hljs-number">30</span>);<br>        ts.add(<span class="hljs-number">50</span>);<br>        ts.add(<span class="hljs-number">20</span>);<br><br>        ts.add(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">//遍历集合</span><br>        <span class="hljs-keyword">for</span>(Integer i : ts) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">30</span><br><span class="hljs-number">40</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h3 id="1-6-3-Set集合子类HashSet集合"><a href="#1-6-3-Set集合子类HashSet集合" class="headerlink" title="1.6.3 Set集合子类HashSet集合"></a>1.6.3 Set集合子类HashSet集合</h3><ul><li>底层数据结构是哈希表</li><li>存取无序</li><li>不可以存储重复元素</li><li>没有索引,不能使用普通for循环遍历，只能用增强for循环</li></ul><h1 id="2-Map-集合"><a href="#2-Map-集合" class="headerlink" title="2. Map 集合"></a>2. Map 集合</h1><h2 id="2-1-Map集合概述和特点"><a href="#2-1-Map集合概述和特点" class="headerlink" title="2.1 Map集合概述和特点"></a>2.1 Map集合概述和特点</h2><p>Map集合的特点</p><ul><li>双列集合,一个键对应一个值</li><li>键不可以重复,值可以重复</li></ul><p>Map集合的基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapDemo01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建集合对象</span><br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br><br>        <span class="hljs-comment">//V put(K key, V value) 将指定的值与该映射中的指定键相关联</span><br>        map.put(<span class="hljs-string">&quot;001&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;002&quot;</span>,<span class="hljs-string">&quot;rose&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;003&quot;</span>,<span class="hljs-string">&quot;lsh&quot;</span>);<br><br><br>        <span class="hljs-comment">//输出集合对象</span><br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">001</span>=jack, <span class="hljs-number">002</span>=rose, <span class="hljs-number">003</span>=lsh&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-Map集合的基本功能"><a href="#2-2-Map集合的基本功能" class="headerlink" title="2.2 Map集合的基本功能"></a>2.2 Map集合的基本功能</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V   put(K key, V   value)</td><td>添加元素</td></tr><tr><td>V   remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void   clear()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度，也就是集合中键值对的个数</td></tr><tr><td>V   get(Object key)</td><td>根据键获取值</td></tr><tr><td>Set<K>   keySet()</td><td>获取所有键的集合</td></tr><tr><td>Collection<V>   values()</td><td>获取所有值的集合</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;   entrySet()</td><td>获取所有键值对对象的集合</td></tr></tbody></table><h2 id="2-3-Map集合的遍历"><a href="#2-3-Map集合的遍历" class="headerlink" title="2.3 Map集合的遍历"></a>2.3 Map集合的遍历</h2><p>方法一</p><p>步骤分析</p><ul><li>获取所有键的集合。用keySet()方法实现</li><li>遍历键的集合，获取到每一个键。用增强for实现  </li><li>根据键去找值。用get(Object key)方法实现</li></ul><p>方法二</p><p>步骤分析</p><ul><li>获取所有键值对对象的集合</li><li>遍历键值对对象的集合，得到每一个键值对对象</li><li>根据键值对对象获取键和值<ul><li>用getKey()得到键</li><li>用getValue()得到值</li></ul></li></ul><h2 id="2-4-Map集合子类HashMap集合"><a href="#2-4-Map集合子类HashMap集合" class="headerlink" title="2.4 Map集合子类HashMap集合"></a>2.4 Map集合子类HashMap集合</h2><h3 id="2-4-1-HashMap集合概述和特点"><a href="#2-4-1-HashMap集合概述和特点" class="headerlink" title="2.4.1 HashMap集合概述和特点"></a>2.4.1 HashMap集合概述和特点</h3><ul><li>HashMap底层是哈希表结构</li><li>依赖hashCode方法和equals方法保证键的唯一</li><li>如果键要存储的是自定义对象，需要重写hashCode和equals方法</li></ul><h2 id="2-5-Map集合子类TreeMap集合"><a href="#2-5-Map集合子类TreeMap集合" class="headerlink" title="2.5 Map集合子类TreeMap集合"></a>2.5 Map集合子类TreeMap集合</h2><h3 id="2-5-1-TreeMap集合概述和特点"><a href="#2-5-1-TreeMap集合概述和特点" class="headerlink" title="2.5.1 TreeMap集合概述和特点"></a>2.5.1 TreeMap集合概述和特点</h3><ul><li>TreeMap底层是红黑树结构</li><li>依赖自然排序或者比较器排序,对键进行排序</li><li>如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer2 题解</title>
    <link href="/2021/08/19/11.%20%E5%89%91%E6%8C%87offer2/"/>
    <url>/2021/08/19/11.%20%E5%89%91%E6%8C%87offer2/</url>
    
    <content type="html"><![CDATA[<h1 id="part-01-整数"><a href="#part-01-整数" class="headerlink" title="part-01 整数"></a>part-01 整数</h1><h2 id="001-整数除法"><a href="#001-整数除法" class="headerlink" title="001 整数除法"></a>001 整数除法</h2><p><img src="/images/image-20210819123251826.png" alt="image-20210819123251826"></p><p>注意的点：</p><ul><li>记住int基本类型的最大整数和最小整数是通过<code>Integer.MIN_VALUE</code>和<code>Integer.MAX_VALUE</code>来得到的。</li><li>这里面的symbol初始值设置为0，两个数里面只要有正数就让他为1，并且把他的值转为负数。如果最后symbol的值为1,说明他俩符号相异，最后在返回的结果上加上负号。</li><li>关于为什么把正数变为负数，而不是反过来，是因为复数的表示范围比正数大1，转换为负数不会溢出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span>(a == Integer.MIN_VALUE &amp;&amp; b == -<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> symbol = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>) &#123;<br>        symbol++;<br>        a=-a;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(b&gt;<span class="hljs-number">0</span>) &#123;<br>        symbol++;<br>        b = -b;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a &lt;= b)&#123;<br>        a -= b;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = symbol == <span class="hljs-number">1</span> ? (-i) : i;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="002-二进制加法"><a href="#002-二进制加法" class="headerlink" title="002 二进制加法"></a>002 二进制加法</h2><p><img src="/images/image-20210819123329534.png" alt="image-20210819123329534"></p><p>注意：</p><ul><li>字符串拼接用<code>StringBuffer</code>这个类，拼接用<code>append()</code>方法，反转用<code>reverse()</code>方法</li><li>获取字符串特定索引处的字符用<code>charAt()</code>方法</li><li>字符串索引的最大值比字符串长度小1</li><li>add 表示进位的值，求进位的值用<code>/</code>取商，求本位的值用<code>%</code>取余数（模）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBinary</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br><br>    StringBuffer res = <span class="hljs-keyword">new</span> StringBuffer();<br>    <span class="hljs-keyword">int</span> l1 = a.length() -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> l2 = b.length()-<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> x, y, sum, add=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(l1&gt;=<span class="hljs-number">0</span> || l2&gt;=<span class="hljs-number">0</span>)&#123;<br>        x = l1&gt;=<span class="hljs-number">0</span>?a.charAt(l1)-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br>        y = l2&gt;=<span class="hljs-number">0</span>?b.charAt(l2)-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br><br>        res.append((x+y+add)%<span class="hljs-number">2</span>);<br>        add = (x+y+add)/<span class="hljs-number">2</span>;<br><br>        l1--;<br>        l2--;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(add != <span class="hljs-number">0</span>) res.append(add);<br><br>    <span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="003-前-n-个数字二进制中-1-的个数"><a href="#003-前-n-个数字二进制中-1-的个数" class="headerlink" title="003 前 n 个数字二进制中 1 的个数"></a>003 前 n 个数字二进制中 1 的个数</h2><p><img src="/images/image-20210819122014317.png" alt="image-20210819122014317"></p><p>注意：</p><ul><li>整型数组如果不赋初值的话，里面每个元素的默认值为0</li><li><code>j &amp;(j-1)</code>会消掉元素j的二进制表示中的一个1</li><li>不用把j转换为二进制再运算，因为计算机本来就是计算二进制的，他自己在运算的时候会自动转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> n) &#123;<br><br>    <span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i++) &#123;<br>        <span class="hljs-keyword">int</span> j=i;<br>        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>)&#123;<br>            j = j &amp;(j-<span class="hljs-number">1</span>);  <br>            a[i]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="004-只出现一次的数字"><a href="#004-只出现一次的数字" class="headerlink" title="004 只出现一次的数字"></a>004 只出现一次的数字</h2><p><img src="/images/image-20210819141406843.png" alt="image-20210819141406843"></p><p>注意：</p><ul><li>判断map集合中是否有该键值对，用<code>containsKey</code>方法</li><li><code>map.get(key)</code>获得的是该键对应的值</li><li><code>map.keySet()</code>是获得键的集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(nums[i]))&#123;<br>            map.put(nums[i], <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Integer value = map.get(nums[i]) + <span class="hljs-number">1</span>;<br>            map.put(nums[i], value);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>        <span class="hljs-keyword">if</span>(map.get(key) == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>这里要用到位运算，先不深入学</p><h2 id="005-单词长度的最大乘积"><a href="#005-单词长度的最大乘积" class="headerlink" title="005 单词长度的最大乘积"></a>005 单词长度的最大乘积</h2><p><img src="/images/image-20210819145141723.png" alt="image-20210819145141723"></p><p>注意：</p><ul><li>字符串不能直接遍历，要么用for循环按照下标来，要么把它转换成字符数组用foreach遍历</li><li>比较两者中的最大值并返回用<code>Math.max()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(String[] words)</span> </span>&#123;<br><br>    <span class="hljs-comment">//将words的每个单词是否出现记录到二维数组中</span><br>    <span class="hljs-keyword">boolean</span>[][] flags = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[words.length][<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : words[i].toCharArray()) &#123;<br>           flags[i][ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//判断每对单词是否有相同字符</span><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; words.length; j++) &#123;<br>            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(; k&lt;<span class="hljs-number">26</span>; k++)&#123;<br>                <span class="hljs-keyword">if</span>(flags[i][k] &amp;&amp; flags[j][k])&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">26</span>)&#123;<br>                <span class="hljs-keyword">int</span> prod = words[i].length() * words[j].length();<br>                result = Math.max(result, prod);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="006-排序数组中两个数字之和"><a href="#006-排序数组中两个数字之和" class="headerlink" title="006 排序数组中两个数字之和"></a>006 排序数组中两个数字之和</h2><p><img src="/images/image-20210819151734545.png" alt="image-20210819151734545"></p><p>注意：</p><ul><li>两数之和有固定的做法，就是双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> sum;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        sum = numbers[left]+numbers[right];<br><br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left, right&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="part-02-数组"><a href="#part-02-数组" class="headerlink" title="part-02 数组"></a>part-02 数组</h1><h2 id="007-数组中和为-0-的三个数"><a href="#007-数组中和为-0-的三个数" class="headerlink" title="007 数组中和为 0 的三个数"></a>007 数组中和为 0 的三个数</h2><p><img src="/images/image-20210820131539822.png" alt="image-20210820131539822"></p><p>注意：</p><ul><li>碰到求几个数之和的，首先想到双指针做法，并且需要将数组排好序</li><li>对数组进行排序用<code>Arrays.sort()</code>这个方法</li><li>对于本题中的三数之和为0，可以让第二个和第三个数等于第一个数的负数就行了</li><li>set集合里面不允许存放重复元素，所以可以把list存放在里面不用考虑重复问题</li><li><code>new ArrayList&lt;&gt;(set)</code>这个构造方法可以将一个set集合转换成list集合</li><li><code>Arrays.asList()</code>可以将若干个整数作为参数，返回的是一个list集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    HashSet&lt;List&lt;Integer&gt;&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-comment">//给数组先排好序</span><br>    Arrays.sort(nums);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> target = -nums[i];<br>        <span class="hljs-keyword">int</span> left = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>            <span class="hljs-keyword">int</span> sum = nums[left]+nums[right];<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                set.add(Arrays.asList(nums[i],nums[left], nums[right]));<br>                left++;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;target)&#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(set);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="008-和大于等于-target-的最短子数组"><a href="#008-和大于等于-target-的最短子数组" class="headerlink" title="008 和大于等于 target 的最短子数组"></a>008 和大于等于 target 的最短子数组</h2><p><img src="/images/image-20210820141536629.png" alt="image-20210820141536629"></p><p>注意：</p><ul><li>关于设置<code>res=Integer.MAX_VALUE</code>这一语句，是为了后面用<code>Math.min()</code>来对满足题目的子数组进行长度比较，如果值仍为<code>Integer.MAX_VALUE</code>，说明没有满足题意的子数组，按照要求返回0</li><li>由题目的连续子数组这一要求可以知道采用滑动窗口这一办法，值比目标值小，向右移动右指针，值大于等于目标值，向右移动左指针</li><li>数组的长度等于右指针减去左指针再加一</li><li>注意while循环<code>left&lt;=right</code>这个条件可以取等号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res=Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>        sum += nums[right];<br>        <span class="hljs-keyword">while</span>(left&lt;=right &amp;&amp; sum&gt;=target)&#123;<br>            res = Math.min(res, right-left+<span class="hljs-number">1</span>);<br>            sum -= nums[left++];<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//res==Integer.MAX_VALUE说明数组右指针走完了，没找到符合要求的子数组，按照要求输出0</span><br>    <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE?<span class="hljs-number">0</span>:res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="009-乘积小于-K-的子数组"><a href="#009-乘积小于-K-的子数组" class="headerlink" title="009 乘积小于 K 的子数组"></a>009 乘积小于 K 的子数组</h2><p><img src="/images/image-20210820151155653.png" alt="image-20210820151155653"></p><p>注意：</p><ul><li>while循环里的<code>left&lt;=right</code>这个条件的 = 要留着</li><li>滑动窗口问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> prod = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>        prod *= nums[right];<br><br>        <span class="hljs-keyword">while</span>(left&lt;=right &amp;&amp; prod&gt;=k)&#123;<br>            prod /= nums[left++];<br>        &#125;<br><br>        <span class="hljs-comment">//为什么每次都加right-left+1，</span><br>        <span class="hljs-comment">// 这里的原理还没搞清楚，先记着</span><br>        <span class="hljs-keyword">if</span> (left&lt;=right) &#123;<br>            res += right-left+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="010-和为-k-的子数组"><a href="#010-和为-k-的子数组" class="headerlink" title="010 和为 k 的子数组"></a>010 和为 k 的子数组</h2><p>不会</p><p>要用到哈希表和前缀和</p><p>前缀和：</p><p>比如有一个数组a = [a1, a2, a3, a4, a5]</p><p>前缀和就为：</p><p>sum[0] = a[0];</p><p>sum[1] = a[1] + a[0];</p><p>以此类推：</p><p>sum[4] = a[4] + a[3] + a[2] + a[1] + a[0]</p><h2 id="011-0-和-1-个数相同的子数组"><a href="#011-0-和-1-个数相同的子数组" class="headerlink" title="011 0 和 1 个数相同的子数组"></a>011 0 和 1 个数相同的子数组</h2><p>不会</p><h2 id="012-左右两边子数组的和相等"><a href="#012-左右两边子数组的和相等" class="headerlink" title="012 左右两边子数组的和相等"></a>012 左右两边子数组的和相等</h2><p><img src="/images/image-20210820220636558.png" alt="image-20210820220636558"></p><p>注意：</p><ul><li>先用一个循环求出整个数组的前缀和</li><li>找中心下标的时候通过这个条件<code>sum-t == t-nums[i]</code>，<code>sum-t</code>表示t下标右边的值的和，<code>t-nums[i]</code>表示t下标左边的和</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        sum+=nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        t+=nums[i];<br>        <span class="hljs-keyword">if</span>(sum-t == t-nums[i])<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="013-二维子矩阵的和"><a href="#013-二维子矩阵的和" class="headerlink" title="013 二维子矩阵的和"></a>013 二维子矩阵的和</h2><p>不会</p><h1 id="part-03-字符串"><a href="#part-03-字符串" class="headerlink" title="part-03 字符串"></a>part-03 字符串</h1><p>字符串的题目一般要用到<strong>哈希表</strong>，<strong>双指针</strong>，<strong>滑动窗口</strong>，<strong>贪心</strong>，<strong>动态规划</strong>等来解决</p><h2 id="014-字符串中的变位词"><a href="#014-字符串中的变位词" class="headerlink" title="014 字符串中的变位词"></a>014 字符串中的变位词</h2><p>方法：固定大小的滑动窗口</p><p><img src="/images/image-20210821133901416.png" alt="image-20210821133901416"></p><p>注意：</p><ul><li><p>counts数组碰到s1中存在的字符就+，碰到s2中的字符就减，如果最后刚好为0，说明s1和s2中的子数组包含的字符相同</p></li><li><p>每一次比较不成功的话，<code>counts[s2.charAt(i - s1.length()) - &#39;a&#39;]++</code>把刚刚走出滑动窗口减过的的值再加回来</p></li><li><p>前后两个for循环可以囊括整个s2字符串</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s2.length() &lt; s1.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; s1.length(); i++) &#123;<br>        counts[s1.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        counts[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (areAllZero(counts)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;<br>        counts[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        counts[s2.charAt(i - s1.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (areAllZero(counts)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areAllZero</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] counts)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count : counts) &#123;<br>        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="015-字符串中的所有变位词"><a href="#015-字符串中的所有变位词" class="headerlink" title="015 字符串中的所有变位词"></a>015 字符串中的所有变位词</h2><p>方法：固定大小的滑动窗口</p><p><img src="/images/image-20210821140517437.png" alt="image-20210821140517437"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>    <span class="hljs-keyword">if</span> (s.length() &lt; p.length())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        counts[p.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        counts[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (areAllZero(counts))&#123;<br>        <span class="hljs-comment">//这里直接写0是因为这里是第一次判断，如果为true, 第一个子串的索引是从0开始的</span><br>        list.add(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = p.length(); i &lt; s.length(); i++) &#123;<br>        counts[s.charAt(i-p.length())-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        counts[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>        <span class="hljs-keyword">if</span> (areAllZero(counts))&#123;<br>            <span class="hljs-comment">//每次判定的时候，索引i都走到了子串的最后一位，如果判定为true的话，子串首位索引为(i-(p.length()-1))</span><br>            list.add(i-p.length()+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areAllZero</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] counts)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count : counts) &#123;<br>        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="016-不含重复字符的最长子字符串"><a href="#016-不含重复字符的最长子字符串" class="headerlink" title="016 不含重复字符的最长子字符串"></a>016 不含重复字符的最长子字符串</h2><p>方法：不固定长度的滑动窗口，哈希表</p><p><img src="/images/image-20210821152336548.png" alt="image-20210821152336548"></p><p>注意：</p><ul><li><code>map.getOrDefault(c, 0)+1</code>表示map集合里如果有键为c，则在它的基础上把值加1，如果没有把它的值设置为0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) &#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br><br>        map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (map.get(c) &gt; <span class="hljs-number">1</span>)&#123;<br>            map.put(s.charAt(left), map.get(s.charAt(left))-<span class="hljs-number">1</span>);<br>            left++;<br>        &#125;<br><br>        res = Math.max(res, right-left+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="017-含有所有字符的最短字符串"><a href="#017-含有所有字符的最短字符串" class="headerlink" title="017 含有所有字符的最短字符串"></a>017 含有所有字符的最短字符串</h2><p>这题是困难题，先不做</p><h2 id="018-有效的回文"><a href="#018-有效的回文" class="headerlink" title="018 有效的回文"></a>018 有效的回文</h2><p>方法：双指针</p><p><img src="/images/image-20210822192255799.png" alt="image-20210822192255799"></p><p>注意：</p><ul><li>字符串转换为小写用<code>toLowerCase()</code>这个方法</li><li><code>Character.isDigit()</code>用来判断，字符是否为数字</li><li><code>Character.isLetter()</code>用来判断字符是否是字母</li><li>拼接新字符串可以新建一个StringBuffer对象，也可以建立一个空串然后用 + 来拼接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span></span><br><span class="hljs-function"></span>&#123;<br>    String lowerStr = s.toLowerCase();<br>    <span class="hljs-keyword">int</span> length = lowerStr.length();<br><br>    String newStr = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i ++) &#123;<br>        <span class="hljs-keyword">char</span> c = lowerStr.charAt(i);<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c) == <span class="hljs-keyword">true</span> || Character.isLetter(c) == <span class="hljs-keyword">true</span>)<br>            newStr  += c;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> n = newStr.length();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (newStr.charAt(left) != newStr.charAt(right))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        left ++;<br>        right --;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="019-最多删除一个字符得到回文"><a href="#019-最多删除一个字符得到回文" class="headerlink" title="019 最多删除一个字符得到回文"></a>019 最多删除一个字符得到回文</h2><p>方法：双指针</p><p><img src="/images/image-20210822194624708.png" alt="image-20210822194624708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(String s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right))<br>            <span class="hljs-comment">//将剩下的子串在这一步进行判定，如果去掉左边一个元素返回false,</span><br>            <span class="hljs-comment">// 去掉右边一个元素也返回false，则说明不是回文串，直接返回false，</span><br>            <span class="hljs-comment">// 否则返回true</span><br>            <span class="hljs-keyword">return</span> isPalindromeString(s, left + <span class="hljs-number">1</span>, right) || isPalindromeString(s, left, right - <span class="hljs-number">1</span>);<br><br>        left ++;<br>        right --;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindromeString</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(low) != s.charAt(high))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        low ++;<br>        high --;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="020-回文子字符串的个数"><a href="#020-回文子字符串的个数" class="headerlink" title="020 回文子字符串的个数"></a>020 回文子字符串的个数</h2><p>方法：双指针</p><p><img src="/images/image-20210822195149642.png" alt="image-20210822195149642"></p><p>注意：</p><ul><li>抓住回文串的中心要不是一个数，要不是两个数这一重要特征</li><li>从回文串中心向两边展开</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//字符串的每个字符都作为回文中心进行判断，中心是一个字符或两个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>        count += countPalindrome(s, i, i);<br>        count += countPalindrome(s, i, i+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//从字符串的第start位置向左，end位置向右，比较是否为回文并计数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPalindrome</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;<br>        count++;<br>        start--;<br>        end++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="prat-04-链表"><a href="#prat-04-链表" class="headerlink" title="prat-04 链表"></a>prat-04 链表</h1><h2 id="021-删除链表的倒数第-n-个结点"><a href="#021-删除链表的倒数第-n-个结点" class="headerlink" title="021 删除链表的倒数第 n 个结点"></a>021 删除链表的倒数第 n 个结点</h2><p>方法：快慢指针</p><p><img src="/images/image-20210822201521634.png" alt="image-20210822201521634"></p><p>注意：</p><ul><li>dummy（假的）节点是一个虚拟创建的节点，放在链表的最前面，指向头节点</li><li>使用dummy可以避免很多由于头节点特殊性产生的坑，让代码更优雅</li><li>让快指针先走指定步数，然后快慢指针按照相同步长一起走，最后快指针走到最后一个结点，此时慢指针的下一个就是要删除的结点</li><li>返回头节点直接用<code>return dummy.next</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//dummy结点的定义</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br><br>    ListNode slow = dummy;<br>    ListNode fast = dummy;<br><br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>        fast = fast.next;<br>        n --;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>)&#123;<br>        slow = slow.next;<br>        fast = fast.next;<br>    &#125;<br>    slow.next = slow.next.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="022-链表中环的入口节点"><a href="#022-链表中环的入口节点" class="headerlink" title="022 链表中环的入口节点"></a>022 链表中环的入口节点</h2><p>方法：快慢指针</p><p><img src="/images/image-20210822235333083.png" alt="image-20210822235333083"></p><p>注意：</p><ul><li>找环的入口固定解法，定义一个快指针从头结点开始每次走两步，定义一个慢指针从头结点开始每次走一步，他俩相遇的地方开始，慢指针从头开始走，快指针改为每次走一步，最终这俩相遇的地方就是环的入口。这个其实就是一个简单的数学题，具体过程如果需要可以自己推一下。</li><li>注意快指针每次走两步时循环条件的设置：<code>fast != null &amp;&amp; fast.next != null</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode slow = head;<br>    ListNode fast = head;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>        slow  = slow .next;<br>        fast = fast.next.next;<br>        <span class="hljs-keyword">if</span>(slow  == fast) &#123;<br>            flag = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">//无环</span><br>    <br>    slow  = head;<br>    <br>    <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>        slow  = slow .next;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="023-两个链表的第一个重合节点"><a href="#023-两个链表的第一个重合节点" class="headerlink" title="023 两个链表的第一个重合节点"></a>023 两个链表的第一个重合节点</h2><p>方法：没有特殊方法，就是分别用一个指针记录每个链表的当前节点</p><p><img src="/images/image-20210823001155967.png" alt="image-20210823001155967"></p><p>注意：</p><ul><li>a指针走完A链表后转而走向B链表，b指针走完B链表后转而走向A链表，它们最终会在交叉结点遇到，此时返回即是所求结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode a = headA;<br>    ListNode b = headB;<br>    <br>    <span class="hljs-keyword">while</span> (a != b)<br>    &#123;<br>        a = (a != <span class="hljs-keyword">null</span> ? a.next : headB);<br>        b = (b != <span class="hljs-keyword">null</span> ? b.next : headA);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="024-反转链表"><a href="#024-反转链表" class="headerlink" title="024 反转链表"></a>024 反转链表</h2><p>方法：递归或者迭代均可，这里先掌握递归</p><p><img src="/images/image-20210823001757628.png" alt="image-20210823001757628"></p><p>注意：</p><ul><li>根据递归终止条件可知，最后返回的head是最后一个结点</li><li>这个递归有点难理解，就记住最后两个节点的操作过程就行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;<br>    ListNode() &#123;&#125;<br>    ListNode(<span class="hljs-keyword">int</span> val) &#123; <span class="hljs-keyword">this</span>.val = val; &#125;<br>    ListNode(<span class="hljs-keyword">int</span> val, ListNode next) &#123; <span class="hljs-keyword">this</span>.val = val; <span class="hljs-keyword">this</span>.next = next; &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    ListNode p = reverseList(head.next); <span class="hljs-comment">//当head.next是最后一个结点的时候，head此时表示的是倒数第二个结点</span><br>    head.next.next = head; <span class="hljs-comment">//表示最后一个结点指向倒数第二个结点</span><br>    head.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//将倒数第二个结点的下一个结点置空</span><br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">// 返回头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="025-链表中的两数相加"><a href="#025-链表中的两数相加" class="headerlink" title="025 链表中的两数相加"></a>025 链表中的两数相加</h2><p>方法：用栈求解 （或者反转链表在求解也可，这里给出的是用栈求解的）</p><p><img src="/images/image-20210823123821814.png" alt="image-20210823123821814"></p><p>注意：</p><ul><li>把结点的值放入栈中，这样可以弹出后面的元素来先进行运算</li><li>注意10进制本位和进位用代码是怎么求的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>        stack1.push(l1.val);<br>        l1 = l1.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>        stack2.push(l2.val);<br>        l2 = l2.next;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>    ListNode head = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> sum = carry;<br>        sum += stack1.isEmpty()? <span class="hljs-number">0</span>: stack1.pop();<br>        sum += stack2.isEmpty()? <span class="hljs-number">0</span>: stack2.pop();<br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>        carry = sum / <span class="hljs-number">10</span>;<br>        <br>        node.next = head;<br>        head = node;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="026-重排链表"><a href="#026-重排链表" class="headerlink" title="026 重排链表"></a>026 重排链表</h2><p>方法：快慢指针，反转链表</p><p>还可以把链表转换为集合 + 双指针来做</p><p><img src="/images/image-20210823191301222.png" alt="image-20210823191301222"></p><p>注意：</p><ul><li>对于一个链表，有dummy的快指针每次走两步，慢指针每次走一步，对于链表长度为奇数的，慢指针刚好指到中间节点，对于链表长度为偶数的，慢指针刚好指到左中间结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">//1、链表平分为两半</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br>    ListNode fast = dummy;<br>    ListNode slow = dummy;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    ListNode temp = slow.next;<br>    slow.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//2、反转后半部分链表</span><br>    temp = reverseList(temp);<br>    <span class="hljs-comment">//3、合并链表</span><br>    link(head,temp,dummy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">link</span><span class="hljs-params">(ListNode node1, ListNode node2, ListNode head)</span> </span>&#123;<br>    ListNode prev = head;<br>    <span class="hljs-keyword">while</span> (node1 != <span class="hljs-keyword">null</span> &amp;&amp; node2 != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode temp = node1.next;<br><br>        prev.next = node1;<br>        node1.next = node2;<br>        prev = node2;<br><br>        node1 = temp;<br>        node2 = node2.next;<br>    &#125;<br><br>    <span class="hljs-comment">//这里还要判断是因为左边子链表长度一定是大于等于右边子链表的</span><br>    <span class="hljs-keyword">if</span> (node1 != <span class="hljs-keyword">null</span>) &#123;<br>        prev.next = node1;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    ListNode p = reverseList(head.next); <span class="hljs-comment">//当head.next是最后一个结点的时候，head此时表示的是倒数第二个结点</span><br>    head.next.next = head; <span class="hljs-comment">//表示最后一个结点指向倒数第二个结点</span><br>    head.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//将倒数第二个结点的下一个结点置空</span><br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">// 返回头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="027-回文链表"><a href="#027-回文链表" class="headerlink" title="027 回文链表"></a>027 回文链表</h2><p>做法和上一题一样</p><ol><li>数组 + 双指针</li><li>找中点+右半段翻转+比较</li></ol><p><img src="/images/image-20210823191924383.png" alt="image-20210823191924383"></p><p>注意：</p><ul><li>ArrayList里根据索引取数的方法是<code>get()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ListNode node = head;<br>    <br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>        list.add(node.val);<br>        node = node.next;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> n = list.size();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-keyword">if</span> (list.get(left) != list.get(right))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        left ++;<br>        right --;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="028-展平多级双向链表"><a href="#028-展平多级双向链表" class="headerlink" title="028 展平多级双向链表"></a>028 展平多级双向链表</h2><p>双向链表的题先不做</p><h2 id="029-排序的循环链表"><a href="#029-排序的循环链表" class="headerlink" title="029 排序的循环链表"></a>029 排序的循环链表</h2><p>循环链表这一题也先不细看</p><p>主要注意分情况讨论</p><p><img src="/images/image-20210823194241701.png" alt="image-20210823194241701"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(Node head, <span class="hljs-keyword">int</span> insertVal)</span></span>&#123;<br>    <span class="hljs-comment">//---- 空的情况</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)<br>    &#123;<br>        Node h = <span class="hljs-keyword">new</span> Node(insertVal, <span class="hljs-keyword">null</span>);<br>        h.next = h;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br><br>    <span class="hljs-comment">//----1个结点的情况</span><br>    <span class="hljs-keyword">if</span> (head.next == head)<br>    &#123;<br>        head.next = <span class="hljs-keyword">new</span> Node(insertVal, head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">//----2个及以上结点</span><br><br>    Node pre = head;<br>    Node cur = head.next;<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-comment">//---- 顺序的情况 2 4 6 ,插入3</span><br>        <span class="hljs-keyword">if</span> (pre.val &lt;= insertVal &amp;&amp; insertVal &lt;= cur.val)&#123;<br>            pre.next = <span class="hljs-keyword">new</span> Node(insertVal, cur);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (pre.val &gt; cur.val)&#123;<br>            <span class="hljs-comment">//----新结点要成为断崖peak 2 4 6, 插入8</span><br>            <span class="hljs-keyword">if</span> (pre.val &lt; insertVal &amp;&amp; insertVal &gt; cur.val)<br>            &#123;<br>                pre.next = <span class="hljs-keyword">new</span> Node(insertVal, cur);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <br>            <span class="hljs-comment">//----新结点成成为断崖valley 2 4 6 , 插入1</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre.val &gt;= insertVal &amp;&amp; insertVal &lt;= cur.val)<br>            &#123;<br>                pre.next = <span class="hljs-keyword">new</span> Node(insertVal, cur);<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>        &#125;<br><br>        pre = cur;<br>        cur = cur.next;<br><br>        <span class="hljs-comment">//---- [3, 3, 3] 插入 0</span><br>        <span class="hljs-keyword">if</span> (pre == head)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    pre.next = <span class="hljs-keyword">new</span> Node(insertVal, cur);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="part-05-哈希表"><a href="#part-05-哈希表" class="headerlink" title="part-05 哈希表"></a>part-05 哈希表</h1><h2 id="030-插入、删除和随机访问都是-O-1-的容器"><a href="#030-插入、删除和随机访问都是-O-1-的容器" class="headerlink" title="030 插入、删除和随机访问都是 O(1) 的容器"></a>030 插入、删除和随机访问都是 O(1) 的容器</h2><p>先不做</p><h2 id="031-最近最少使用缓存"><a href="#031-最近最少使用缓存" class="headerlink" title="031 最近最少使用缓存"></a>031 最近最少使用缓存</h2><p>先不做</p><h2 id="032-有效的变位词"><a href="#032-有效的变位词" class="headerlink" title="032 有效的变位词"></a>032 有效的变位词</h2><p>方法：没有用到特殊方法</p><p><img src="/images/image-20210824191847439.png" alt="image-20210824191847439"></p><p>注意：</p><ul><li>注意判断字符串中数量相等，建立一个数组，一个字符串用来加，一个字符串用来减，如果最后数组中的值全部为0说明相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = s.length();<br><br>    <span class="hljs-keyword">if</span> (length != t.length() || s.equals(t)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>        ++chars[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        --chars[t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c : chars) &#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="033-变位词组"><a href="#033-变位词组" class="headerlink" title="033 变位词组"></a>033 变位词组</h2><p>方法：哈希表</p><p><img src="/images/image-20210824192646546.png" alt="image-20210824192646546"></p><p>注意：</p><ul><li><code>String mode = new String(t)</code>注意String的这种初始化方法</li><li><code>map.putIfAbsent()</code>方法也是添加键值对，不过是<code>put()</code>的增强版，他会先判断这个键存不存在，不存在才添加</li><li><code>map.values()</code>返回的是一个单列集合，可在<code>ArrayList</code>的初始化中作参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs)&#123;<br>    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String word : strs)&#123;<br>        String tmp = word;<br>        <span class="hljs-keyword">char</span> [] t = tmp.toCharArray();<br>        Arrays.sort(t);<br>        String mode = <span class="hljs-keyword">new</span> String(t);<br><br>        map.putIfAbsent(mode, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        map.get(mode).add(word);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="034-外星语言是否排序"><a href="#034-外星语言是否排序" class="headerlink" title="034 外星语言是否排序"></a>034 外星语言是否排序</h2><p>方法：数组或者哈希表</p><p><img src="/images/image-20210824225005228.png" alt="image-20210824225005228"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] index = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index.length; ++i) &#123;<br>        index[order.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length - <span class="hljs-number">1</span>; ++i) &#123;<br>        String w1 = words[i];<br>        String w2 = words[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> l1 = w1.length(), l2 = w2.length();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Math.max(l1, l2); ++j) &#123;<br>            <span class="hljs-keyword">int</span> i1 = j &gt;= l1 ? -<span class="hljs-number">1</span> : index[w1.charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">int</span> i2 = j &gt;= l2 ? -<span class="hljs-number">1</span> : index[w2.charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>];<br><br>            <span class="hljs-keyword">if</span> (i1 &gt; i2) &#123;<br>                <span class="hljs-comment">// 说明不是按字典序排序，直接返回False</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (i1 &lt; i2) &#123;<br>                <span class="hljs-comment">// 说明当前两单词是按字典序排序，无需再往下进行循环比较</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="035-最小时间差"><a href="#035-最小时间差" class="headerlink" title="035 最小时间差"></a>035 最小时间差</h2><p>方法：单列集合</p><p><img src="/images/image-20210824225821128.png" alt="image-20210824225821128"></p><p>注意：</p><ul><li><code>Collections.sort()</code>里面放的参数是链表<code>List&lt;T&gt; list</code>，<code>Arrays.sort()</code>里面放的参数是整型数组<code>int[] a</code></li><li><code>timePoints.size() &gt; 24 * 60</code>是根据题意来的，按分钟数，这一个数组里最多只有<code>24 * 60</code>个字符串</li><li><code>t.split(&quot;:&quot;)</code>是根据<code>:</code>来分割字符串，分割以后得到新的字符串数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (timePoints.size() &gt; <span class="hljs-number">24</span> * <span class="hljs-number">60</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    List&lt;Integer&gt; mins = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (String t : timePoints) &#123;<br>        String[] time = t.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        mins.add(Integer.parseInt(time[<span class="hljs-number">0</span>]) * <span class="hljs-number">60</span> + Integer.parseInt(time[<span class="hljs-number">1</span>]));<br>    &#125;<br><br>    Collections.sort(mins);<br>    mins.add(mins.get(<span class="hljs-number">0</span>) + <span class="hljs-number">24</span> * <span class="hljs-number">60</span>);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">24</span> * <span class="hljs-number">60</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mins.size(); ++i) &#123;<br>        res = Math.min(res, mins.get(i) - mins.get(i - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="part-06-栈"><a href="#part-06-栈" class="headerlink" title="part-06 栈"></a>part-06 栈</h1><p>方法：栈</p><h2 id="036-后缀表达式"><a href="#036-后缀表达式" class="headerlink" title="036 后缀表达式"></a>036 后缀表达式</h2><p><img src="/images/image-20210825125220791.png" alt="image-20210825125220791"></p><p>注意：</p><ul><li>每次把操作数放入栈中，遇到操作符就弹出来，并把运算结果压入栈</li><li><code>stack.push()</code>压栈，<code>stack.pop()</code>弹出栈顶元素</li><li>在switch选择语句中，程序走到break会跳出选择语句，不再执行后面的case</li><li>关于为什么不用<code>Character.isDigit()</code>来进行判断，而是自己造了一个isDigit函数。因为<code>Character.isDigit()</code>是用来判断字符是否为数字的，而这里的token是一个字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (String token : tokens) &#123;<br><br>        <span class="hljs-keyword">if</span> (isDigit(token)) &#123;<br><br>            stack.push(Integer.parseInt(token));<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> op1 = stack.pop();<br>            <span class="hljs-keyword">int</span> op2 = stack.pop();<br><br>            <span class="hljs-keyword">int</span> tempAns = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">switch</span> (token) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    tempAns = op1 * op2;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    tempAns = op2 / op1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    tempAns = op2 + op1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    tempAns = op2 - op1;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br><br>            stack.push(tempAns);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.pop();<br>&#125;<br> <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(String token)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> isDigit = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> value = Integer.parseInt(token);<br>    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<br>        isDigit = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isDigit;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="037-小行星碰撞"><a href="#037-小行星碰撞" class="headerlink" title="037 小行星碰撞"></a>037 小行星碰撞</h2><p>方法：栈</p><p><img src="/images/image-20210825145626772.png" alt="image-20210825145626772"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] asteroidCollision(<span class="hljs-keyword">int</span>[] nums) &#123;<br><br>    <span class="hljs-keyword">int</span> n=nums.length;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; <span class="hljs-comment">//标记左边的小于0的行星,i左边全部小于0</span><br>    Stack&lt;Integer&gt; stack= <span class="hljs-keyword">new</span> Stack();<br><br>    <span class="hljs-keyword">while</span>(i&lt;=n-<span class="hljs-number">1</span> &amp;&amp; nums[i]&lt;<span class="hljs-number">0</span>)&#123;<br>        stack.push(nums[i]);<span class="hljs-comment">//把开头的负数全部加入stack,因为他们不会发生碰撞</span><br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur=i;cur&lt;n;cur++)&#123;<br><br>        <span class="hljs-keyword">if</span>(nums[cur]&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//正数直接入栈</span><br>            stack.push(nums[cur]);<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-comment">//负数</span><br>            <span class="hljs-keyword">while</span>(!stack.isEmpty()&amp;&amp;stack.peek()&gt;<span class="hljs-number">0</span>&amp;&amp;nums[cur]+stack.peek()&lt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//相加小于0，且栈顶是正数,就一直弹出栈顶元素</span><br>                stack.pop();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(stack.empty() || (!stack.empty() &amp;&amp; stack.peek()&lt;<span class="hljs-number">0</span>))&#123;<span class="hljs-comment">//栈为空或者栈顶为负数，入栈</span><br>                stack.push(nums[cur]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//栈不为空，栈顶是正数。和当前负数相加为0</span><br>                <span class="hljs-keyword">if</span>(stack.peek()&gt;<span class="hljs-number">0</span> &amp;&amp; nums[cur]+stack.peek()==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//相加等于0，弹出栈顶</span><br>                    stack.pop();<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> size=stack.size();<br>    <span class="hljs-keyword">int</span> arr[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=size-<span class="hljs-number">1</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<br>        arr[k]=stack.pop();<br>    &#125;<br>    <span class="hljs-keyword">return</span>  arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="038-每日温度"><a href="#038-每日温度" class="headerlink" title="038 每日温度"></a>038 每日温度</h2><p>方法：单调栈</p><p><strong>什么是单调栈？</strong><br>单调栈就是栈里面存放的数据都是有序的，所以可以分为单调递增栈和单调递减栈两种。</p><p>单调递增栈就是从栈底到栈顶是从大到小<br>单调递减栈就是从栈底到栈顶是从小到大</p><p><img src="/images/image-20210825163646074.png" alt="image-20210825163646074"></p><p>注意：</p><ul><li>判断栈是否为空用<code>empty()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>    <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br>    Stack&lt;Integer&gt; decrStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!decrStack.empty() &amp;&amp; temperatures[i] &gt; temperatures[decrStack.peek()]) &#123;<br>            ans[decrStack.peek()] = i - decrStack.pop();<br>        &#125;<br>        decrStack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="039-直方图最大矩形面积"><a href="#039-直方图最大矩形面积" class="headerlink" title="039 直方图最大矩形面积"></a>039 直方图最大矩形面积</h2><p>方法：单调栈 + 哨兵</p><p>哨兵这一思想是用来解决边界问题的</p><p><img src="/images/image-20210825164207691.png" alt="image-20210825164207691"></p><p>困难题，暂时先不写</p><h2 id="040-矩阵中最大的矩形"><a href="#040-矩阵中最大的矩形" class="headerlink" title="040 矩阵中最大的矩形"></a>040 矩阵中最大的矩形</h2><p>方法：单调栈</p><p><img src="/images/image-20210825165212932.png" alt="image-20210825165212932"></p><p>困难题，先不写</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2021/08/18/10.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/08/18/10.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构概论"><a href="#1-数据结构概论" class="headerlink" title="1. 数据结构概论"></a>1. 数据结构概论</h1><p>数据结构包括数据的<strong>逻辑结构</strong>，<strong>物理结构</strong>和<strong>对数据的运算</strong></p><h2 id="1-1-数据的逻辑结构"><a href="#1-1-数据的逻辑结构" class="headerlink" title="1.1 数据的逻辑结构"></a>1.1 数据的逻辑结构</h2><p>对数据之间关系的描述</p><ol><li><p>线性结构</p><p>数据元素之间存在一对一的关系</p></li><li><p>非线性结构</p><p>数据元素之间存在一对多的关系</p></li></ol><p>一种逻辑结构可以有多种物理结构</p><h2 id="1-2-数据的物理结构"><a href="#1-2-数据的物理结构" class="headerlink" title="1.2 数据的物理结构"></a>1.2 数据的物理结构</h2><p>数据的物理结构又称为存储结构，是数据的逻辑结构在计算机中的表示（映像）</p><p>数据结构的4种存储方法</p><ol><li><p>顺序存储方法</p><p>存储在物理位置相邻的单元</p></li><li><p>链式存储方法</p><p>由指针指向下个结点的位置</p></li><li><p>索引存储方法</p><p>建立附加的索引表来标识结点的地址</p></li><li><p>散列存储方法</p><p>通过散列函数直接计算结点的存储地址地址</p></li></ol><h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h1><h2 id="2-1-线性表的基本概念与实现"><a href="#2-1-线性表的基本概念与实现" class="headerlink" title="2.1 线性表的基本概念与实现"></a>2.1 线性表的基本概念与实现</h2><h3 id="2-1-1-线性表定义"><a href="#2-1-1-线性表定义" class="headerlink" title="2.1.1 线性表定义"></a>2.1.1 线性表定义</h3><p>线性表是具有相同特性数据元素的一个有限序列。</p><ul><li><p>线性表中的元素具有相同特性</p></li><li><p>线性表可以有序也可以无序</p></li></ul><h3 id="2-1-2-线性表的存储结构"><a href="#2-1-2-线性表的存储结构" class="headerlink" title="2.1.2 线性表的存储结构"></a>2.1.2 线性表的存储结构</h3><ol><li><p>顺序存储</p><p>顺序存储的线性表称为顺序表</p><p>特性：</p><ul><li>随机访问</li><li>占用连续的存储空间（存储空间的分配只能预先进行，操作过程中不变）</li></ul></li><li><p>链式存储</p><p>链式存储的线性表称为链表</p><p>特性：</p><ul><li>不支持随机访问</li><li>支持存储空间的动态分配</li></ul></li></ol><p>链表有5种形式</p><ol><li><p>单链表</p><ul><li><p>带头结点的单链表</p><p><img src="/images/image-20210818221349757.png" alt="image-20210818221349757"></p><p>头指针head指向头节点，始终不为空</p><p>head-&gt;next为null的时候，链表为空</p></li><li><p>不带头结点的单链表</p><p>头指针head直接指向A1，当头指针为null的时候，链表为空</p></li></ul></li><li><p>双链表</p><p><img src="/images/image-20210818221700693.png" alt="image-20210818221700693"></p><p>带头结点的双链表</p><p>head-&gt;next为null的时候，链表为空</p></li><li><p>循环单链表</p></li><li><p>循环双链表</p></li><li><p>静态链表</p></li></ol><p>顺序表的存储密度为1，链表的存储密度小于1</p><h2 id="2-2-线性表的结构体定义和基本操作"><a href="#2-2-线性表的结构体定义和基本操作" class="headerlink" title="2.2 线性表的结构体定义和基本操作"></a>2.2 线性表的结构体定义和基本操作</h2><h3 id="2-2-1-线性表的结构体定义"><a href="#2-2-1-线性表的结构体定义" class="headerlink" title="2.2.1 线性表的结构体定义"></a>2.2.1 线性表的结构体定义</h3><p>1、顺序表的结构体定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sqList</span>&#123;</span><br><span class="hljs-keyword">int</span> data[<span class="hljs-number">100</span>];   <span class="hljs-comment">//存放顺序表元素的数组</span><br><span class="hljs-keyword">int</span> length; <span class="hljs-comment">//存放顺序表的长度</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>2、单链表结构体定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br><span class="hljs-keyword">int</span> data;        <span class="hljs-comment">//存放结点数据</span><br>LNode *next;   <span class="hljs-comment">//指向后继节点的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>3、双链表定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dNode</span> &#123;</span><br><span class="hljs-keyword">int</span> data;    <span class="hljs-comment">//存放数据</span><br>dNode *prior;   <span class="hljs-comment">//指向前驱节点的指针</span><br>dNode *next;  <span class="hljs-comment">//指向后继节点的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-顺序表的操作"><a href="#2-2-2-顺序表的操作" class="headerlink" title="2.2.2 顺序表的操作"></a>2.2.2 顺序表的操作</h3><h3 id="2-2-3-单链表的操作"><a href="#2-2-3-单链表的操作" class="headerlink" title="2.2.3 单链表的操作"></a>2.2.3 单链表的操作</h3><p>1、插入新结点</p><p>注意下节点插入的步骤: 把s结点插入到p结点后面</p><p>注意：</p><ul><li>顺序不能变</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">s-&gt;next = p-&gt;next;<br>p-&gt;next = s;<br></code></pre></td></tr></table></figure><p>2、删除原有结点</p><p>删除p的下一个结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">q = p-&gt;next;<br>p-&gt;next = p-&gt;next-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br></code></pre></td></tr></table></figure><h3 id="2-2-4-双链表操作"><a href="#2-2-4-双链表操作" class="headerlink" title="2.2.4 双链表操作"></a>2.2.4 双链表操作</h3><p>1、插入新结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s-&gt;next = p-&gt;next;<br>s-&gt;prior = p;<br>p-&gt;next = s;<br></code></pre></td></tr></table></figure><p>2、删除原有结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">p-&gt;next = p-&gt;next-&gt;next;<br>p-&gt;next-&gt;prior = p;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络与安全</title>
    <link href="/2021/08/11/9.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/08/11/9.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1. 计算机网络体系结构"></a>1. 计算机网络体系结构</h1><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><p>21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的倍息时代。网络对社会生活的很多方面以及对社会经济的发展己经产生了不可估量的影响。</p><p>三网合一主要指的是“电信网络”、“有线电视网络”、“计算机网络”。</p><h3 id="1-1-1-计算机网络概念"><a href="#1-1-1-计算机网络概念" class="headerlink" title="1.1.1 计算机网络概念"></a>1.1.1 计算机网络概念</h3><p>计算机网络是指分布在不同地理位置上的具有独立功能的多个计算机系统，通过通信设备和通信线路互连起来，在网络软件的管理下实现数据传输和资源共享的系统。</p><h3 id="1-1-2-计算机网络发展"><a href="#1-1-2-计算机网络发展" class="headerlink" title="1.1.2 计算机网络发展"></a>1.1.2 计算机网络发展</h3><ol><li><p>第一阶段</p><p>1969 年美国国防部建立了世界上第一个 ARPANET 网络。</p><p><img src="/images/image-20210811120525303.png" alt="image-20210811120525303"></p></li><li><p>第二阶段</p><p>三级结构网络阶段，1985 年，美国国家科学基金会 NSF 围绕六个大型的计算机中心建设计算机网络，即国家科学基金网 NSFNET。它是第一个三级网络，分为，主干网、地区网和校园网（企业网）。</p></li><li><p>第三阶段</p><p>第三阶段的特点是逐渐形成多层次的 ISP 结构的 internet。1993 年美国资助的NSFNEF 网络被若干个商用的因特网主干网代替，政府不再复制因特网的运营。因特网服务提供商 ISP（internet service provider）。ISP 拥有从因特网管理机构申请多个 IP 地址，同时拥有通信线路，路由等通信连接设备。任何机构或个人可以向 ISP 缴纳费用，从而获取 IP 地址，获取网络服务。</p><p><img src="/images/image-20210811120757910.png" alt="image-20210811120757910"></p></li></ol><h3 id="1-1-3-计算机网络功能"><a href="#1-1-3-计算机网络功能" class="headerlink" title="1.1.3 计算机网络功能"></a>1.1.3 计算机网络功能</h3><ol><li><p>数据通信</p><p>计算机网络主要提供传真、电子邮件、电子数据交换（EDI）、电子公告牌（BBS）、远程登录和浏览等数据通信服务。</p></li><li><p>资源共享</p><p>凡是入网用户均能享受网络中各个计算机系统的全部或部分软件、硬件和数据资源，为最本质的功能。</p></li><li><p>提高系统可靠性</p><p>网络中的每台计算机都可通过网络相互成为后备机。一旦某台计算机出现故障，它的任务就可由其他的计算机代为完成，这样可以避免在单机情况下，一台计算机发生故障引起整个系统瘫痪的现象，从而提高系统的可靠性。</p></li><li><p>提高性能</p><p>当网络中的某台计算机负担过重时，网络又可以将新的任务交给较空闲的计算机完成，均衡负载，从而提高了每台计算机的可用性。</p></li><li><p>分布式处理</p><p>通过算法将大型的综合性问题交给不同的计算机同时进行处理。用户可以根据需要合理选择网络资源，就近快速地进行处理。</p></li></ol><h3 id="1-1-4-计算机网络组成"><a href="#1-1-4-计算机网络组成" class="headerlink" title="1.1.4 计算机网络组成"></a>1.1.4 计算机网络组成</h3><ol><li><p>边缘部分</p><p>资源子网：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</p></li><li><p>核心部分</p><p>通信子网：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</p><p><img src="/images/image-20210811121302746.png" alt="image-20210811121302746"></p></li></ol><p>处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统（end system）。</p><p>“主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。</p><p>即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”</p><h3 id="1-1-5-网络分类"><a href="#1-1-5-网络分类" class="headerlink" title="1.1.5 网络分类"></a>1.1.5 网络分类</h3><ol><li><p>按作用范围</p><ol><li>局域网（LAN）</li></ol><p>局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><ol start="2"><li>城域网（MAN）</li></ol><p>城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称 MAN。属宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。</p><ol start="3"><li>广域网（WAN）</li></ol><p>广域网（WAN，Wide Area Network）也称远程网（long haul network ）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p></li><li><p>按拓扑结构</p><p><img src="/images/image-20210811121759726.png" alt="image-20210811121759726"></p><ol><li>星型拓扑结构</li></ol><p>星形拓扑结构是一种以中央节点为中心，把若干外围节点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。</p><ol start="2"><li>树型拓扑结构</li></ol><p>树形拓扑结构是一种层次结构，结点按层次连结，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。</p><ol start="3"><li>总线型拓扑结构</li></ol><p>总线型拓扑是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。</p><p>在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。</p><ol start="4"><li>环型拓扑结构</li></ol><p>环型拓扑是使用公共电缆组成一个封闭的环，各节点直接连到环上，信息沿着环按一定方向从一个节点传送到另一个节点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。</p><ol start="5"><li>网状拓扑结构</li></ol><p>网状拓扑结构，这种拓扑结构主要指各节点通过传输线相互连接起来，并且每一个节点至少与其他两个节点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护，不常用于局域网。</p></li><li><p>按使用范围</p><ol><li>公用网</li></ol><p>一般是国家的邮电部门建造的网络。”公用”的意思就是从所有愿意按邮电部门规定交纳费用的人都可以使用。因此，公用网也可以称为公众网，例如 CHINANET、CERNET 等。</p><ol start="2"><li>专用网</li></ol><p>“专用网”英文对照 private data network； intranet；special network；是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。</p></li></ol><h3 id="1-1-6-网络交换方式"><a href="#1-1-6-网络交换方式" class="headerlink" title="1.1.6 网络交换方式"></a>1.1.6 网络交换方式</h3><ol><li><p>电路交换</p><p>电路交换（CS:circuit switching）是通信网中最早出现的一种交换方式，也是应用最普遍的一种交换方式，主要应用于电话通信网中，完成电话交换。</p><ol><li>工作过程</li></ol><p>电话通信分为三个阶段：呼叫建立、通话、呼叫拆除。</p><p>电话通信的过程是：首先摘机，听到拨号音后拨号，交换机找寻被叫，向被叫振铃同时向主叫送回铃音，此时表明在电话网的主被叫之间已经建立起双向的话音传送通路；当被叫摘机应答，即可进入通话阶段；在通话过程中，任何一方挂机，交换机毁拆除已建立的通话通路，并向另一方送忙音提示挂机，从而结束通话。</p><ol start="2"><li>电路交换特点</li></ol><ul><li><p>面向连接的独占性</p><p>在通信前要先建立一条端到端的连接，建立好之后，通信就沿着这条路径进行，路径起点就是发送端，路径的终点就是接收端。在建立电路之后、释放线路之前，即使站点之间无任何数据可以传输，整个线路仍不允许其他站点共享。</p></li><li><p>同步时分复用固定带宽</p><p>信息传输的最小单位是时隙，时隙是用户传输信息的时候占用的时间。</p><p>时分多路复用技术：将传输信号的时间分割成若干个时间片（时隙），利用不同的时隙传输各自不同的信号，多路信号使用各自的时隙。</p></li><li><p>信息传送无差错控制，信息具有透明性。</p><p>电路交换对传输信息不作处理，这称为透明传输。进行低速率数据传送时也不进行速率、码型的变换。对传输的信息也不作差错控制，没有 CRC 循环冗余校验和重发等机制。</p></li><li><p>基于呼叫损失的流量控制；</p><p>电路交换采用基于呼叫损失的控制方法来处理业务流，过负荷时呼损率增加，但不影响已经建立的呼叫。这种控制方法符合实时业务的特性。</p></li></ul><ol start="3"><li>电路交换优缺点</li></ol><ul><li><p>优点</p><p>实时性好、信息传输时延小，对于一次接续来讲，传输时延固定不变，适用于实时、大批量、连续的数据传输。</p><p>数据传输可靠、迅速，数据不会丢失，且保持原来的序列。</p><p>通信质量有保证，控制简单。 </p></li><li><p>缺点</p><p>呼叫建立需要时间</p><p>每个连接带宽固定（不能适应不同速率的业务）</p><p>不传信息时也占用资源（不适用于突发业务）</p><p>对信息无差错控制，不适合差错敏感的数据业务</p><p>流量控制是基于呼叫损失制的</p></li></ul></li><li><p>分组交换</p><p>1）虚电路交换</p><ul><li><p>工作原理</p><p>虚电路是建立一条逻辑连接，发送方与接收方不需要预先建立连接。</p><p>虚电路是由分组交换通信所提供的面向连接的通信服务。在两个节点或应用进程之间建立起一个逻辑上的连接或虚电路后，就可以在两个节点之间依次发送每一个分组，接收端收到分组的顺序必然与发送端的发送顺序一致，因此接收端无须负责在接收分组后重新进行排序。虚电路协议向高层协议隐藏了将数据分割成段，包或帧的过程。</p></li><li><p>虚电路特点</p><p>应用程序产生数据的比特率；</p><p>利用一个 RTT(Round-Trip Time, 往返时间) 时间来建立虚拟信道。</p><p>如果交换失败，必须重新建立连接。</p><p>为每一个虚拟信道分配缓冲区；权限控制；对每一连接进行计费。</p><p>使用统计多路复用技术时，共享同一网络资源的其他用户的负荷；</p><p>许多虚电路协议通过数据重传，包括检错纠错和自动重传请求（ARQ），提供可</p><p>靠的通信服务。</p></li></ul><p>2）报文交换</p><ul><li><p>基本概念</p><p>报文交换不要求在两个通信结点之间建立专用通路。结点把要发送的信息组织成一个数据包(报文)，该报文中含有目标结点的地址，完整的报文在网络中一站一站地向前传送。在电子邮件系统中有使用。</p></li><li><p>优缺点</p><p>报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式，因而有以下优缺点：</p><ul><li><p>优点</p><p>报文交换是无连接的，不需要在连接建立时延，用户可随时发送报文。</p><p>在报文交换中便于设置代码检验和数据重发设施，提高了传输的可靠性</p><p>在存储转发中容易实现代码转换和速率匹配</p><p>提供多目标服务，即一个报文可以同时发送到多个目的地址</p><p>允许建立数据传输的优先级，使优先级高的报文优先转换。</p><p>报文在传输过程种是分段的占用物理通路，因而大大提高了通信线路的利用率。</p></li><li><p>缺点</p><p>数据需要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>报文交换只适用于数字信号。</p><p>由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p></li></ul></li></ul><p>3）<strong>分组交换</strong></p><ul><li><p>分组交换概念</p><p>分组交换实质上是在“存储——转发”基础上发展起来的。它兼有电路交换和报文交换的优点。分组交换在线路上采用动态复用技术传送按一定长度分割为许多小段的数据——分组，每个分组独立进行传送。到达接受端口，再重新组装为一个完整的数据报文。分组交换比电路交换的传输效率高，比报文交换的时延小。</p><p><img src="/images/image-20210811124228542.png" alt="image-20210811124228542"></p></li><li><p>分组交换优缺点</p><ul><li><p>优点</p><p>利用率高：数据分组可以在同一条链路上以动态共享和复用方式进行传输，通信资源利用率高，从而使得信道的容量和吞吐量有了很大的提升。</p><p>数据率：两个不同数据率的站之间能够交换分。</p><p>排队机制：当分组网络上有大量的分组时，可以根据设定数据传输的排队机制，保证优先级高的分组优先传输。</p><p>优先级：在使用优先级时，如果一个结点有大量的分组在排队等待传送，它可以先传送高优先级的分组。</p><p><img src="/images/image-20210811124451244.png" alt="image-20210811124451244"></p></li><li><p>缺点</p><p>时延：一个分组通过一个分组交换网结点存储转发时会产生时延，而在电路交换网中则不存在这种时延。</p><p>时延抖动：因为一个给定的源站和目的站之间的各分组可能具有不同的长度，可以走不同的路径，也可以在沿途的交换机中经历不同的时延，所以分组的总时延就可能变化很大。这种现象被称为抖动。</p><p>开销大：要将分组通过网络传送，包括目的地址在内的额外开销信息和分组排序信息必须加在每一个分组里。这些信息降低了可用来运输用户数据的通信容量。</p></li></ul></li></ul></li><li><p>四种交换方式</p><p><img src="/images/image-20210811124948429.png" alt="image-20210811124948429"></p></li><li><p>交换方式的比较</p><p><img src="/images/image-20210811125034381.png" alt="image-20210811125034381"></p></li></ol><h3 id="1-1-7-计算机网络的性能指标"><a href="#1-1-7-计算机网络的性能指标" class="headerlink" title="1.1.7 计算机网络的性能指标"></a>1.1.7 计算机网络的性能指标</h3><ol><li><p>速率</p><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。</p><p>Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p><p>速率即数据率（data rate）或比特率（bit rate）是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或 kb/s， Mb/s， Gb/s 等。</p></li><li><p>带宽</p><p>“带宽”（bandwidth）本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。最高频率和最低频率的差值。</p><p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s （bit/s）。</p><p>在时间轴上信号的宽度随带宽的增大而变窄。</p><p><img src="/images/image-20210811125517772.png" alt="image-20210811125517772"></p></li><li><p>吞吐量</p><p>吞吐量（throughput）表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p></li><li><p>时延（delay 或 latency）</p><p>发送时延 —— 第一个比特算起，到最后一个比特发送完毕所需的时间。</p><p>传播时延 —— 电磁波在信道中需要传播一定的距离而花费的时间。</p><p>处理时延 —— 交换结点为存储转发而进行一些必要的处理所花费的时间。</p><p>排队时延 —— 结点缓存队列中分组排队所经历的时延。</p><p>总时延 = 发送时延+传播时延+处理时延+排队时延</p></li><li><p>时延带宽积</p><p>时延带宽积=传播时延 X 带宽。</p></li><li><p>利用率</p><p>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</p><p>网络利用率则是全网络的信道利用率的加权平均值。</p><p>信道利用率并非越高越好。</p><p>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0 之间的关系：</p><p><img src="/images/image-20210811125839009.png" alt="image-20210811125839009"></p></li></ol><h2 id="1-2-计算机网络体系结构"><a href="#1-2-计算机网络体系结构" class="headerlink" title="1.2 计算机网络体系结构"></a>1.2 计算机网络体系结构</h2><h3 id="1-2-1-网络协议"><a href="#1-2-1-网络协议" class="headerlink" title="1.2.1 网络协议"></a>1.2.1 网络协议</h3><ol><li><p>协议的定义</p><p>简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</p></li><li><p>协议的三要素</p><p>语法：数据与控制信息的结构或格式。</p><p>语义：需要发出何种控制信息，完成何种动作以及做出何种响应。</p><p>同步：事件实现顺序的详细说明。</p></li></ol><h3 id="1-2-2-OSI-参考模型"><a href="#1-2-2-OSI-参考模型" class="headerlink" title="1.2.2 OSI 参考模型"></a>1.2.2 OSI 参考模型</h3><ol><li><p>分层的好处</p><p>各层之间是独立的。灵活性好。结构上可分割开。易于实现和维护。能促进标准化工作。</p></li><li><p>分层的原则</p><p>若层数太少，就会使每一层的协议太复杂。</p><p>层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。</p></li><li><p>OSI 层次</p><p>1977 年，开放系统互联参考模型 OSI/RM（Open System Interconnection，OSI）。</p><p>相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。</p><p>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p><p><img src="/images/image-20210811131246210.png" alt="image-20210811131246210"></p></li><li><p>各层次结构的功能</p><p>1）物理层（Physical Layer）</p><p>物理层规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。</p><p>在这一层，数据的单位称为比特（bit）。</p><p>属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45 等。</p><p>2）数据链路层（Data Link Layer）</p><p>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><p>在这一层，数据的单位称为帧（frame）。</p><p>数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</p><p>3）网络层（Network Layer）</p><p>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。</p><p>在这一层，数据的单位称为数据包（packet）。</p><p>网络层协议的代表包括：IP、IPX、RIP、OSPF 等。</p><p>4）传输层（Transport Layer）</p><p>传输层是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p><p>在这一层，数据的单位称为数据段（segment）。</p><p>传输层协议的代表包括：TCP、UDP、SPX 等。</p><p>5）会话层（Session Layer）</p><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><p>会话层协议的代表包括：NetBIOS、ZIP（AppleTalk 区域信息协议）等。</p><p>6）表示层（Presentation Layer）</p><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。表示层协议的代表包括：ASCII、ASN.1、JPEG、MPEG 等。</p><p>7）应用层（Application Layer）</p><p>应用层为操作系统或网络应用程序提供访问网络服务的接口。</p><p>应用层协议的代表包括：Telnet、FTP、HTTP、SNMP 等。</p></li></ol><h3 id="1-2-3-TCP-IP-层次"><a href="#1-2-3-TCP-IP-层次" class="headerlink" title="1.2.3 TCP/IP 层次"></a>1.2.3 TCP/IP 层次</h3><p>TCP/IP 是四层的体系结构：应用层、传输层、网络层和网络接口层。</p><p><img src="/images/image-20210811131826577.png" alt="image-20210811131826577"></p><ol><li><p>应用层</p><p>应用层是经常接触使用的部分，比如常用的 http 协议、ftp 协议（文件传输协议）、snmp（网络管理协议）、telnet （远程登录协议 ）、smtp（简单邮件传输协议）、dns（域名解析），这次主要是面向用户的交互的。这里的应用层集成了 osi 分层模型中 的应用、会话、表示层三层的功能。</p></li><li><p>传输层</p><p>传输层的作用就是将应用层的数据进行传输转运。比如我们常说的 TCP（可靠的传输控制协议）、UDP（用户数据报协议）。传输单位为报文段。</p><p>TCP（Transmission Control Protocol）面向连接（先要和对方确定连接、传输结束需要断开连接，类似打电话）、复杂可靠的、有很好的重传和查错机制。一般用于高速、可靠的通信服务。UDP（user datagram protocol）面向无连接（无需确认对方是否存在，类似寄包裹）、简单高效、没有重传机制。一般用于即时通讯、广播通信等。</p></li><li><p>网络层</p><p>网络层用来处理网络中流动的数据包，数据包为最小的传递单位，比如我们常用的 IP 协议、ICMP 协议、ARP 协议（通过分析 IP 地址得出物理 MAC 地址）。</p></li><li><p>数据链路层</p><p>数据链路层一般用来处理连接硬件的部分，包括控制网卡、硬件相关的设备驱动等。传输单位数据帧。</p></li><li><p>物理层</p><p>物理层一般为负责数据传输的硬件，比如我们了解的双绞线电缆、无线、光纤等。比特流光电等信号发送接收数据。</p></li></ol><h3 id="1-2-4-两种模型的比较"><a href="#1-2-4-两种模型的比较" class="headerlink" title="1.2.4 两种模型的比较"></a>1.2.4 两种模型的比较</h3><ol><li><p>层次模型之间的对比</p><p><img src="/images/image-20210811132207417.png" alt="image-20210811132207417"></p></li><li><p>OSI 参考模型和 TCP/IP 参考模型之共同点</p><p>都是基于独立的协议栈的概念；</p><p>它们的功能大体相似，在两个模型中，传输层及以上的各层都是为了通信的进程提供点到点、与网络无关的传输服务；</p><p>OSI 参考模型与 TCP/IP 参考模型传输层以上的层都以应用为主导。</p></li><li><p>OSI 参考模型与 TCP/IP 参考模型的主要差别</p><p>TCP/IP 一开始就考虑到多种异构网的互联问题，并将网际协议 IP 作为 TCP/IP 的重要组成部门。但 ISO 最初只考虑到使用一种标准的公用数据网将各种不同的系统互联在一起。</p><p>TCP/IP一开始就对面向连接和无连接并重，而OSI在开始时只强调面向连接服务。</p><p>TCP/IP 有较好的网络管理功能，而 OSI 到后来才开始这个问题，在这方面两者有所不同。</p></li></ol><h3 id="1-2-5-实体、协议、服务"><a href="#1-2-5-实体、协议、服务" class="headerlink" title="1.2.5 实体、协议、服务"></a>1.2.5 实体、协议、服务</h3><p>协议—- 是控制两个对等实体进行通信的规则的集合。</p><p>实体（entity）—- 用以表示任何可发送或接收信息的硬件或软件进程。</p><p>对等层 —- 任何两个结点在同层次（例如在两个系统的第 4 层）间通信，好像将数据（即数据单元加上控制信息）直接传递给对方，即所谓的“对等层”之间通信。各层协议实际上就是在各个对等层之间传递数据时的各项规定。</p><p>服务原语 —-上层使用下层提供的服务必须通过与下层交换一些命令，这些命令在 OSI 中称为服务原语。</p><p>服务访问点（SAP）—- 是同一系统中相邻两层的实体进行交互（交换信息）的一个逻辑接口。</p><p>PDU —- 协议数据单元，在对等层之间传送的数据单位。</p><p>SDU —- 服务数据单元，层与层之间交换的数据的单位。</p><p>服务：在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</p><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><h2 id="2-1-通信基础"><a href="#2-1-通信基础" class="headerlink" title="2.1 通信基础"></a>2.1 通信基础</h2><h3 id="2-1-1-物理层功能"><a href="#2-1-1-物理层功能" class="headerlink" title="2.1.1 物理层功能"></a>2.1.1 物理层功能</h3><ol><li><p>机械特性</p><p>指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p></li><li><p>电气特性</p><p>指明在接口电缆的各条线上出现的电压的范围。</p></li><li><p>功能特性</p><p>指明某条线上出现的某一电平的电压表示何种意义。</p></li><li><p>过程特性</p><p>指明对于不同功能的各种可能事件的出现顺序。</p></li></ol><h3 id="2-1-2-计算机通信"><a href="#2-1-2-计算机通信" class="headerlink" title="2.1.2 计算机通信"></a>2.1.2 计算机通信</h3><p><img src="/images/image-20210811132816378.png" alt="image-20210811132816378"></p><p>信道: 是指信息传输的通道。信号必须通过信道才能传输出去。常见的信道有有线信道和无线信道两种。</p><p>数据（data）：运送消息的实体。</p><p>信号（signal）：数据的电气的或电磁的表现。</p><p>码元（code）：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="2-1-3-通信方式"><a href="#2-1-3-通信方式" class="headerlink" title="2.1.3 通信方式"></a>2.1.3 通信方式</h3><ol><li><p>信号编码</p><p>把二进制代码转化为计算机信号的过程，称为编码技术。</p><p>常见的编码技术有：单极性码、极性码、双极性码、归零码、不归零码、双相码、曼彻斯特码、差分曼彻斯特码等。常见的编码技术是：曼彻斯特码和差分曼彻斯特码编码。</p><p><img src="/images/image-20210811133133941.png" alt="image-20210811133133941"></p><p>1）曼彻斯特编码</p><p>曼彻斯特编码，也叫做相位编码，是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。曼彻斯特编码，常用于局域网传输。曼彻斯特编码把每一个码元都被调成两个电平，即把一个周期分成前半周期和后半周期。</p><p>传输数据 0：前半周期是正电压，后半周期是负电压。</p><p>传输数据 1：前半周期是负电压，后半周期是正电压。</p><p>所以曼彻斯特编码具有自同步能力和良好的抗干扰性能。</p><p>2）差分曼彻斯特编码</p><p>差分曼彻斯特编码和曼彻斯特编码功能类似，但是不同之处在于差分曼彻斯特编码主要是在传输周期结束后，电压是否发生变化来确定传输的数据是 0 还是 1。</p><p>传输数据 0：周期结束后，电压发生变化，后半周期电压变化。</p><p>传输数据 1：周期结束后，电压不发生变化，后半周期电压变化。</p><p>两种常见编码： </p><p><img src="/images/image-20210811133348975.png" alt="image-20210811133348975"></p></li><li><p>编码转化</p><p>1）数字信号-基带传输</p><p>数字信号指自变量是离散的、因变量也是离散的信号，这种信号的自变量用整数表示，因变量用有限数字中的一个数字来表示（曼彻斯特编码或差分曼彻斯特编码）。</p><p>数字信号特点：信号准确、抗干扰能力强、便于加密处理、便于存储和交换、便于构成综合数字网和综合业务数字网、占用信道频带较宽。</p><p>2）模拟信号-频带传输</p><p>模拟信号是指信号是连续的，是用波形模拟随着信息的变化而变化，模拟信号其特点是幅度连续（心电图、声波等）。</p><p>3）信号的调整</p><ul><li><p>调幅（AM）</p><p>载波的振幅随基带数字信号而变化</p></li><li><p>调频（FM）</p><p>载波的频率随基带数字信号而变化</p></li><li><p>调相（PM）</p><p>载波的初始相位随基带数字信号而变化</p><p><img src="/images/image-20210811133704905.png" alt="image-20210811133704905"></p><p>码元传输的速度越高，或信号传输的距离远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。</p><p><img src="/images/image-20210811133800952.png" alt="image-20210811133800952"></p></li></ul></li><li><p>通信方式</p><p>1）单向通信（单工通信）</p><p>只能有一个方向的通信而没有反方向的交互。</p><p>2）双向交替通信（半双工通信）</p><p>通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。</p><p>3）双向同时通信（全双工通信）</p><p>通信的双方可以同时发送和接收信息。</p></li></ol><h3 id="2-1-4-信号传输"><a href="#2-1-4-信号传输" class="headerlink" title="2.1.4 信号传输"></a>2.1.4 信号传输</h3><ol><li><p>信息传输的概念</p><p>1）码元 (携带的比特数)</p><p>码元：在数字通信中常常用时间间隔相同的符号来表示数字。这样的时间间隔内的信号称为码元，这个间隔称为码元长度。</p><p>2）比特率（bit rate）</p><p>比特率每秒钟传输数据的位数，即 bit/s，或写成位每秒。基本上用于表示网络传输速度，有时候也可以写成 bps（参照第一节的计算机网络性能指标）。</p><p>3）波特率（baud rate）</p><p>“波特率”是指每秒传输的码元数，单位为波特，说明单位时间传输了多少个码元。<strong>若每个码元所含的信息量为 1 比特，则波特率等于比特率</strong>。所以波特率通常单位是 bit/s，也就是二进制位/秒。</p><p>例 1：3600 的波特率的信道，理论上每秒可以传输 3600/8 个字节的数据，也就是450 个字节。</p><p>例 2：如果在数字传输过程中，0V、2V、4V 和 6V 分别表示 00、01、10 和 11，那么每个码元有四种状态 00、01、10 和 11。每个码元代表两个二进制数字。此时的每秒码元数是每秒二进制代码数是一半的，这叫四相调制，波特率等于比特率一半。</p></li><li><p>奈奎斯特定理</p><p>1）基本概念</p><p>美国电信工程师奈奎斯特推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。该定理说明采样频率与信号频谱之间的关系，是连续信号离散化的基本依据。</p><p>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</p><p>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><p>2）定理内容</p><p>对于一个带宽为 W 赫兹的理想信道，其最大码元（信号）速率为 2W 波特。这一限制是由于存在码间干扰。如果被传输的信号包含了 M 个状态值（信号的状态数是 M），那么 W 赫兹信道所能承载的最大数据传输速率（信道容量）是：</p><p><img src="/images/image-20210811135132821.png" alt="image-20210811135132821"></p></li><li><p>信噪比</p><p>1）信号衰减</p><p>信号的传输的波形，在信号的传输过程中受到（带宽、噪声、干扰、距离、磁场、电场）等影响，会使得当前的计算机信号出现与原始信号不一样的情况，这样成为信号的衰减，信号衰减比较小时信号可以还原，信号衰减比较大时则信号不能还原。</p><p>码元传输的速度越高，或信号传输的距离远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形失真就越严重。</p><p>2）噪音</p><p>噪声是指信息经过该设备后产生的原信号中并不存在的无规则的额外信号（或信息），并且该种信号并不随原信号的变化而变化。</p><p>噪声是无规律的。</p><p>3）信噪比</p><p>信息传输过程中，信号的平均功率和噪声的平均功率的比，常用 S/N，分贝（dB）是度量单位。</p><p>信噪比（dB）=  10lg(S/N)</p><p>S 表示信息的功率</p><p>N 表示噪音的功率</p><p>信噪比越大，说明当前计算机网络性能越优越。</p><p>4）<strong>香农定理</strong></p><ul><li><p>香农定理</p><p>1948 年，信息论的创始人香农得出的香农公式。</p><p>目的是为了计算出当前信道带宽和信噪比一定的情况下，信道传输数据的极限值。</p><p>香农（Shannon）用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。</p><p>信道的极限信息传输速率 C 可表达为：</p><p><img src="/images/image-20210811140015628.png" alt="image-20210811140015628"></p><p>W 为信道的带宽（以 Hz 为单位）</p><p>S 为信道内所传信号的平均功率</p><p>N 为信道内部的高斯噪声功率。</p></li><li><p>信道速度和噪音关系</p><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p><p>若信道带宽 W 或信噪比 S/N 没有上限，则信道的极限信息传输速率 C 也就没有上限。</p><p>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</p></li></ul></li></ol><h3 id="2-1-5-信道的复用技术"><a href="#2-1-5-信道的复用技术" class="headerlink" title="2.1.5 信道的复用技术"></a>2.1.5 信道的复用技术</h3><ol><li><p>信号频段</p><p>电信领域使用的电磁波的频谱。</p><p><img src="/images/image-20210811140311854.png" alt="image-20210811140311854"></p><p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li><li><p>频分多路复用</p><p>频分多路复用（Frequency-division multIPlexing，FDM），是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。</p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。</p><p><img src="/images/image-20210811140437400.png" alt="image-20210811140437400"></p><p>例如：中央电视台、河北电视台、上海卫视在同一时间内可以发送自己频段的电视节目，这样可以保证用户在相同的频段收看相同的节目，不同的频段收看不同的节目。</p><p>收音广播就是利用这样的一种通信方式，当然计算机网路中主要表现在光纤和电话拨号网络上。</p></li><li><p>波分多路复用</p><p>波分复用 WDM（Wavelength Division MultIPlexing）是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，MultIPlexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，DemultIPlexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。不同的信号使用不同频率的光，实际上光纤就是使用的波分多路复用技术。</p><p>波分复用就是光的频分复用。 </p><p><img src="/images/image-20210811140623886.png" alt="image-20210811140623886"></p><p>小时候玩的三棱镜就是波分多路复用技术。</p></li><li><p>时分多路复用</p><ul><li><p>基本概念</p><p>时分多路复用（TDM）是按传输信号的时间进行分割的，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM 就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。</p><p>例如中央电视台在进行节目播放的时候，19：00 到 19：30 分的时候播放《新闻联播》，19：30 到 19：35 播放《天气预报》，19：35 到 20：00 分的时候播放《焦点访谈》。</p><p>计算机网络上不同的用户可以在不同的时间上传输不同的数据，网络通信信道归不同的计算机终端使用。</p><p>TDM 帧是周期性出现，这样用户就可以周期性的使用当前的计算机网络传输数据。</p></li><li><p>特点</p><p>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。</p><p><img src="/images/image-20210811140857926.png" alt="image-20210811140857926"></p><p>TDM 信号也称为等时（isochronous）信号。</p><p>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p><p>时分复用可能会造成线路资源的浪费，使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p></li></ul></li><li><p>统计时分多路复用</p><p>统计时分多路复用（statistical time division multIPlexing，STDM）是指动态地按需分配共用信道的时隙，只将需要传送数据的终端接入共用信道，以提高信道利用率的多路复用技术，简称 STDM。也称异步时分多路复用。</p><p>在进行数据传输时，可以先统计下一时刻需要发送数据的用户数量，这样可以把当前的一个 TDM 周期分割成等时的积分，分给不同的用户使用，在不同的周期分割的时间不同，这样不同的用户就可以在不同的周期占用信道的时间就会有不同。</p><p>这样可以有效的避免当前用户在进行数据传输过程中占用时隙不发送数据的情况。</p></li><li><p>码分多路复用</p><p>1）基本概念</p><p>码分多路复用 CDM 又称码分多址（Code Division MultIPle Access，CDMA），CDM 与 FDM（频分多路复用）和 TDM（时分多路复用）不同，它<strong>既共享信道的频率，也共享时间</strong>，是一种真正的动态复用技术。</p><p>原理是每比特时间被分成 m 个更短的时间槽，称为码片（ChIP），通常情况下每比特有 64 或 128 个码片.每个站点（通道）被指定一个唯一的 m 位的代码或码片序列。当发送 1 时站点就发送码片序列，发送 0 时就发送码片序列的反码。当两个或多个站点同时发送时，各路数据在信道中被线形相加。为了从信道中分离出各路信号，要求各个站点的码片序列是相互正交的。</p><p>即假如用 S 和 T 分别表示两个不同的码片序列，用!S 和!T 表示各自码片序列的反码，那么应该有 S·T=0，S·!T=0，S·S=1，S·!S=-1。当某个站点想要接收站点 X发送的数据时，首先必须知道 X 的码片序列（设为 S）；假如从信道中收到的和矢量为 P，那么通过计算 S·P 的值就可以提取出 X 发送的数据：S·P=0 说明 X 没有发送数据；S·P=1 说明 X 发送了 1；S·P=-1 说明 X 发送了 0。</p><p>2）优缺点</p><p>码分多路复用通信系统抗窄频带干扰能力强，保密性强，各路的连接、变换较灵活，但电路较复杂并需有精度高的同步系统。因此尚未得到广泛应用。</p><p>3）例题 (记住)</p><p><img src="/images/image-20210811141605461.png" alt="image-20210811141605461"></p></li></ol><h2 id="2-2-传输介质"><a href="#2-2-传输介质" class="headerlink" title="2.2 传输介质"></a>2.2 传输介质</h2><h3 id="2-2-1-同轴电缆"><a href="#2-2-1-同轴电缆" class="headerlink" title="2.2.1 同轴电缆"></a>2.2.1 同轴电缆</h3><ol><li><p>概述</p><p>同轴电缆（50Ω 同轴电缆 75Ω 同轴电缆）</p><p>同轴电缆也是局域网中最常见的传输介质之一。</p><p><img src="/images/image-20210811144142365.png" alt="image-20210811144142365"></p></li><li><p>分类</p><p>1）细缆</p><p>直径为 0.26 厘米，最大传输距离 185 米，使用时与 50Ω终端电阻、T 型连接器。网络最大的干线长度：大于 185 米，小于 925 米。</p><p>2）粗缆</p><p>直径为 1.27 厘米，最大传输距离达到 500 米。网络干线电缆长度：大于 500 米，小于 2500 米。</p></li></ol><h3 id="2-2-2-双绞线"><a href="#2-2-2-双绞线" class="headerlink" title="2.2.2 双绞线"></a>2.2.2 双绞线</h3><ol><li><p>概述</p><p>双绞线（twisted pair，TP）是一种综合布线工程中最常用的传输介质，是由两根具有绝缘保护层的铜导线组成的。把两根绝缘的铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。</p></li><li><p>分类</p><p>屏蔽双绞线 STP 无屏蔽双绞线 UTP</p><p><img src="/images/image-20210811144520662.png" alt="image-20210811144520662"></p></li><li><p>非屏蔽双绞线电缆具有以下优点：</p><p>无屏蔽外套，直径小，节省所占用的空间，成本低；</p><p>重量轻，易弯曲，易安装；</p><p>将串扰减至最小或加以消除；</p><p>具有阻燃性；</p><p>具有独立性和灵活性，适用于结构化综合布线。</p><p>既可以传输模拟数据也可以传输数字数据。</p></li><li><p>国际标准线序</p><p>EIA/TIA 568A：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕。</p><p>EIA/TIA 568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕。</p></li><li><p>国际标准</p><p>100BASE-T4RJ-45 对双绞线的规定如下：</p><p>1、2 用于发送，3、6 用于接收，4、5 用于语音，7、8 是双向线。</p><p>传输距离是 100m。</p></li></ol><h3 id="2-2-3-光纤"><a href="#2-2-3-光纤" class="headerlink" title="2.2.3 光纤"></a>2.2.3 光纤</h3><ol><li><p>概述</p><p>是一种由玻璃或塑料制成的纤维。</p><p><img src="/images/image-20210811144802021.png" alt="image-20210811144802021"></p></li><li><p>分类</p><p>1）单模光纤</p><p>只能传输一个传播模式的光纤。传输距离 20 公里至 120 公里。</p><p>2）多模光纤</p><p>将光纤按工作波长以其传播可能的模式为多个模式的光纤。传输距离 2 公里到 5 公里。</p><p><img src="/images/image-20210811144958225.png" alt="image-20210811144958225"></p></li><li><p>优点</p><p>频带宽、损耗低、重量轻、抗干扰能力、强保真度高、工作性能可靠、成本不断下降。</p><p>传输损耗小，中继距离长，对远距离传输经济。 </p><p>抗雷电和电磁干扰好。在大电流脉冲干扰的环境下重要。</p><p>无串音干扰，保密性好，不易被窃听或截取数据。</p><p>体积小，重量轻。</p><p>缺点是光纤要连接必须用专用的设备。</p></li></ol><h3 id="2-2-4-传输介质比较"><a href="#2-2-4-传输介质比较" class="headerlink" title="2.2.4 传输介质比较"></a>2.2.4 传输介质比较</h3><p><img src="/images/image-20210811145233370.png" alt="image-20210811145233370"></p><h3 id="2-2-5-无线传输媒体"><a href="#2-2-5-无线传输媒体" class="headerlink" title="2.2.5  无线传输媒体"></a>2.2.5  无线传输媒体</h3><p>无线传输所使用的频段很广。</p><p>短波通信主要是靠电离层的反射，但短波信道的通信质量较差。</p><p>微波在空间主要是直线传播。</p><p>地面微波接力通信</p><p>卫星通信</p><p>微波通信</p><p>微波通信可以传输电话、电报、图像、数据等信息。特点如下：</p><ul><li><p>微波波段频率很高，其频段范围也很宽，因此其通信信道的容量很大。</p></li><li><p>工业干扰和天电干扰的主要频谱成分比微波频率低的多，对微波通信危害比对短波和米波通信小的多，所以微波的传输质量更高。</p></li><li><p>与相同容量和长度的电缆载波通信比较，微波的接力通信建设投资少，见效快，易跨山区、江河。</p></li></ul><h2 id="2-3-传输设备及技术"><a href="#2-3-传输设备及技术" class="headerlink" title="2.3 传输设备及技术"></a>2.3 传输设备及技术</h2><h3 id="2-3-1-中继器（Repeater）"><a href="#2-3-1-中继器（Repeater）" class="headerlink" title="2.3.1 中继器（Repeater）"></a>2.3.1 中继器（Repeater）</h3><p><img src="/images/image-20210811145531231.png" alt="image-20210811145531231"></p><p>由于传输线路噪音的影响，承载信息的数字信号或模拟信号只能传输有限的距离。在线路中间插入放大器的办法是不可取的，因为伴随信号的噪音也被放大了。在这种情况下用中继器连接两个网络可以延长信号传输的距离。<strong>中继器的功能是对接收信号进行再生和发送</strong>。</p><p>中继器不解释也不改变接收到的数字信息，它只是从接收信号中分离出数字数据。存储起来，然后重新构造它并转发出去。再生的信号与接收信号完全相同并可以沿着另外的网络段传输到远端。</p><p><strong>中继器是局域网互连的最简单设备，它工作在 OSI 体系结构的物理层</strong>，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。</p><p><strong>集线器是有多个端口的中继器。简称 HUB</strong>。</p><p>HUB 集线器就是一种共享设备，HUB 本身不能识别目的地址。这种方式就是共享网络带宽。</p><h3 id="2-3-2-集线器"><a href="#2-3-2-集线器" class="headerlink" title="2.3.2 集线器"></a>2.3.2 集线器</h3><p><img src="/images/image-20210811145749311.png" alt="image-20210811145749311"></p><ol><li><p>基本概述</p><p>集线器（hub）属于纯硬件网络底层设备。它也不具备 MAC 地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。</p><p>集线器为主要网络设别的网络被称为共享式以太网，当网络中的主机数量过多的时候，就会在网络生成广播风暴。</p><p><strong>集线器工作于 OSI/RM 参考模型的物理层和数据链路层的 MAC（介质访问控制）子层</strong>。</p><p>10M集线器在物理层有4 个标准接口可用，那就是：10BASE-5、10BASE-2、10BASE-T、10BASE-F。10M 集线器的 10BASE-5（AUI）端口用来连接层 1 和层 2。</p><p>集线器采用了 CSMA/CD（载波帧听多路访问/冲突检测）协议，CSMA/CD 为 MAC 层协议，所以集线器也含有数据链路层的内容。</p><p>每一个集线器可以形成一个碰撞域（广播域） </p></li><li><p>集线器特点</p><p>集线器是使用电子器件来模拟实际电缆线的工作，整个系统仍然像传统的以太网那样运行。</p><p>使用集线器的以太网在逻辑上是一个总线网，还使用 CSMA/CD 协议，并共享逻辑上的总线。</p><p>集线器很像一个多接口的转发器，工作在物理层。</p></li></ol><h3 id="2-3-3-ADSL"><a href="#2-3-3-ADSL" class="headerlink" title="2.3.3 ADSL"></a>2.3.3 ADSL</h3><ol><li><p>ADSL 技术</p><p>1）ADSL （Asymmetric Digital Subscriber Line）：非对称数字用户线</p><p>ADSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</p><p>标准模拟电话信号的频带被限制在 300~3400 Hz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。</p><p>ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p><p>DSL 就是数字用户线（Digital Subscriber Line）的缩写。</p><p>2）ADSL 的特点</p><p>上行和下行带宽做成不对称的。</p><p>上行指从用户到 ISP，而下行指从 ISP 到用户。</p><p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p><p>我国目前采用的方案是离散多音调 DMT （Discrete Multi-Tone）调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</p><p>3）ADSL 的数据率</p><p>由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），因此 ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率。</p><p>通常下行数据率在 32 kb/s 到 6.4 Mb/s 之间，而上行数据率在 32 kb/s 到 640 kb/s 之间。</p></li></ol><h3 id="2-3-4-HFC"><a href="#2-3-4-HFC" class="headerlink" title="2.3.4 HFC"></a>2.3.4 HFC</h3><p>光纤同轴混合网 HFC （Hybrid Fiber Coax）</p><p>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p><p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p><p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造</p><ol><li><p>HFC 的主要特点</p><p>1）HFC 网的主干线路采用光纤</p><p>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。在光纤结点以下就是同轴电缆。</p><p>2）HFC 网采用结点体系结构</p><p><img src="/images/image-20210811150527928.png" alt="image-20210811150527928"></p><p>3）HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能</p><p><img src="/images/image-20210811150558663.png" alt="image-20210811150558663"></p><p>4）每个家庭要安装一个用户接口盒</p><p>用户接口盒 UIB （User Interface Box）要提供三种连接，即：</p><ul><li><p>使用同轴电缆连接到机顶盒（set-top box），然后再连接到用户的电视机。</p></li><li><p>使用双绞线连接到用户的电话机。</p></li><li><p>使用电缆调制解调器连接到用户的计算机。</p></li></ul></li><li><p>电缆调制解调器（cable modem）</p><p>电缆调制解调器是为 HFC 网而使用的调制解调器。</p><p>电缆调制解调器最大的特点就是传输速率高。其下行速率一般最高可达 30Mb/s，而上行速率一般最高可达 10Mb/s。</p><p>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。</p></li></ol><h3 id="2-3-5-FTTx-技术"><a href="#2-3-5-FTTx-技术" class="headerlink" title="2.3.5 FTTx 技术"></a>2.3.5 FTTx 技术</h3><p>FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。例如：</p><ul><li>光纤到户 FTTH （Fiber To The Home）：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</li><li>光纤到大楼 FTTB （Fiber To The Building）：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li><li> 光纤到路边 FTTC （Fiber To The Curb）：从路边到各用户可使用星形结构双绞线作为传输媒体。</li></ul><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><h2 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h2><h3 id="3-1-1-数据链路层功能"><a href="#3-1-1-数据链路层功能" class="headerlink" title="3.1.1 数据链路层功能"></a>3.1.1 数据链路层功能</h3><ol><li><p>基本概念</p><p>数据链路是将本质上不可靠的传输媒体变成可靠的传输通路提供给网络层。</p><p>链路（link）是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</p><p>数据链路（data link） 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p>一般的适配器都包括了数据链路层和物理层这两层的功能。</p><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：<strong>封装成帧</strong>、<strong>透明传输</strong>和<strong>差错检测</strong>。</p></li><li><p>基本功能</p><p>1）链路管理功能</p><p>主要是在数据通信前，在物理线路上进行数据链路连接的建立、拆除、分离工作。</p><p>2）为网络层提供服务</p><p>数据链路层位于物理层和网络层中间，所以数据链路层是享用物理层的服务和向网络层提供服务。物理层传输数据是不可靠的，数据链路层必须保证数据传输的可靠性和准确性。</p><p>3）封装成帧</p><p>封装成帧也就是帧的定界，是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。告知接收方帧的开始位置和结束位置，确定帧中数据的位置。在封装成帧时，不考虑帧的长短等问题。</p><p>4）差错检测</p><p>保证数据的可靠传输，则必须对数据进行相应的校验机制，保证接收到的数据是可靠的，有效的，正确的。</p><p>误码率：传输错误的比特占所传输比特总数的比率称为误码率。误码率与信噪比有很大的关系。误码率越大，计算机网络性能越差。</p><p>5）流量控制</p><p>控制数据发送的速度，保证发送的帧不要太长，以免造成网络拥塞或接收方不能完全接收。</p><p>流量控制两种方法，第一种是基于反馈的流量控制，根据接收方反馈的信息来控制发送的数据；第二种是基于速率的流量控制，加法增大和乘法减小等原则。</p><p><strong>常用的流量控制方法是：滑动窗口协议</strong>。</p><p>6）MAC 寻址</p><p>根据计算机网卡的物理地址，在局域网中寻找网络主机的地址，把数据发送给目标地址，一般局域网中寻址方式是 MAC 寻址，页脚物理寻址。</p><p>7）透明传输</p><p>保证帧的传输信息和控制信息不能混淆，接收方能区分正常数据和控制信息等数据，例如帧开始控制信息和结束控制信息。</p></li></ol><h3 id="3-1-2-数据帧"><a href="#3-1-2-数据帧" class="headerlink" title="3.1.2 数据帧"></a>3.1.2 数据帧</h3><ol><li><p>帧的定界</p><p>帧的定界是确保帧的开始位置和结束位置，保证接收方能判定在什么位置开始，扫描位置结束。</p><p>常见的定界方法有：使用字符填充的首尾定界符法、使用比特填充的首尾标志法、违法编码法和字节计数法。</p><p>1）字节计数法</p><p>发送方：用一个特殊字段表示帧的开始，在开始字段后添加一个帧的长度字段确认帧中传输数据的长度。</p><p>接收方：识别特殊的开始字段，在开始字段后读取有字段的长度字段，在接收后直接接收字段长度的字符作为数据字段存储。</p><p>问题：“字节计数”字段是出现错误，则影响后面接收的数据长度，则会影响整个数据的统计情况，所以必须采取措施来保证它不会出错。</p><p>2）特殊字符填充的首尾定界符方法</p><p>用一些特定的字符来定界一帧的开始和结束。</p><p><img src="/images/image-20210811152029116.png" alt="image-20210811152029116"></p><p>开始标识：控制字符 SOH（Start Of Header）放在一帧的最前面，表示帧的开始，十六进制编码是 01（二进制是 00000001）</p><p>结束标识：控制字符 EOT（End Of Transnussion）放在帧的结束位置，表示帧的结束，十六进制编码是 04（二进制是 00000100）</p><p>当计算机接收数据的时候，遇到 00000001 则说明当前帧为开始，遇到 00000100则说明当前帧结束。</p><p>问题：当计算机数据传输的时候，可能出现传输的数据为 00000100，结果被计算机误认为帧的结束标识，造成数据接收的不完整，破坏数据的完整性。</p><p>3）特殊比特填充的首尾标志方法</p><p>在 ppp 协议中，多采用特定的比特模式（如 01111110）来标志一帧的开头和结束。</p><p>问题：数据中传输的数据包含 01111110 数据时，被误认为结束的标识，也会造成数据的丢失。</p><p>4）违例编码法</p><p>在物理层传输数据的时候，0 和 1 用不同的电压表示，曼彻斯特和差分曼彻斯特编码都是半周期变化电压（一个周期内存在高低电压的变化）。如果出现一个周期电压不是高低变化，则说明当前代码是不合标准的。</p><p>可以借用这些违例编码的序列来定界帧的开始和结束。</p></li><li><p>帧透明传输</p><p>为解决帧中传输的数据和帧的定界冲突的问题，让计算机能识别计算机传输的数据编码和定界编码有一定的区别，这成为帧的透明传输。</p><p>1）转义字符填充法</p><p><img src="/images/image-20210811152421692.png" alt="image-20210811152421692"></p><p>发送方：除第一个开始字符“SOH”和结束字符“EOT”外，当传输的数据中有和在控制字符“SOH”、“EOT” “ESC”相同的信息的时候，则先前添加转义字符“ESC”。</p><p>其中“SOH”的二进制代码 0000 0001、“EOT”的二进制代码 0000 0100、“ESC” 的二进制代码 0010 1011。</p><p>接收方：接收信息的时候，出现转义字符“ESC”时，先去掉前面的转义字符“ESC”，这样就可以保证接收的有效性。如果接收的字符为“EOT”前面没有转义字符“ESC”时，说明当前数据结束。</p><p><img src="/images/image-20210811152527302.png" alt="image-20210811152527302"></p><p>ESC 的二进制代码是：00011101，十六进制编码是 0x1D。</p><p>2）“零”比特填充</p><p>发送端在输出数据的时候，第一个 01111110 字符说明当前为数据的开始位置，第二个 01111110 字符说明当前为数据的结束位置。</p><p>但传输数据和控制字段相同的时候，方法是每出现连续 5 个 1，则在后面添加一个 0，这样就可以直接和控制字段有很好的区分。接收方在接收的时候，如果连续有 5 个 1 出现，则直接去掉后面的 1 个 0。</p><p>例如要传输的数据中包含下面字段 011111 11111 001111 这样的数据字段。</p><p><img src="/images/image-20210811152655429.png" alt="image-20210811152655429"></p></li></ol><h2 id="3-2-差错控制"><a href="#3-2-差错控制" class="headerlink" title="3.2 差错控制"></a>3.2 差错控制</h2><h3 id="3-2-1-出错原因"><a href="#3-2-1-出错原因" class="headerlink" title="3.2.1 出错原因"></a>3.2.1 出错原因</h3><p>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER （Bit Error Rate）。</p><p>误码率与信噪比有很大的关系。</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p><p>通信过程中出现的差错可大致分为两类：一类是由热噪声引起的随机错误；另一类是由冲击噪声引起的突发错误。</p><h3 id="3-2-2-检错编码"><a href="#3-2-2-检错编码" class="headerlink" title="3.2.2 检错编码"></a>3.2.2 检错编码</h3><p>检错编码的作用是检查当前数据中出现的错误，对错误不进行处理，<strong>数据链路层就采用检错码</strong>，当检查出现错误后，数据链路层会丢弃当前的错误，不对当前的数据错误处理，并发出一个反回的控制信息，告知发送方，当前发送的数据出现错误。</p><p>如果数据链路层接收的帧出现错误或这帧的长度有变化，则数据链路层就直接丢弃当前接收的数据帧。</p><p>向后纠错：接收端发现接收的数据帧出现错误时，以某种方式通知发送端重传该数据帧，直到接收到正确的数据帧为止。</p><p>向前纠错：接收端不能发现接收的数据帧的错误，而能确定二进制代码中发生错误的位置，从而进行纠正，允许接收方修改数据。</p><ol><li><p>水平/垂直奇偶校验码</p><p>奇偶校验是最常用的检错方法。在要传输数据的后面增加一位，使得传输数据中“l”的个数成奇数（奇校验）或偶数（偶校验）。</p><p>接收方接收后，如果接收的数据中“l”的个数成奇数个（奇校验）或偶数个（偶校验），说明传输数据中没有出现错误。如果接收的数据中“l”的个数成偶数个（奇校验）或奇数个（偶校验），说明传输数据出现错误。</p><p><img src="/images/image-20210811154516990.png" alt="image-20210811154516990"></p></li><li><p>循环冗余校验</p><p>循环冗余检查（CRC）是一种数据传输检错功能，对数据进行求余计算，并将得到的余数附在帧的后面，接收设备也执行类似的算法，如果进行求余的结果是 0，说明传输的数据是正确的，如果求余的结果不是 0，则说明传输数据有问题。</p><p>校验机制是保证数据传输的正确性和完整性。</p><p>FCS（Frame CheckSequence）帧检查序列位，数比规定的除数少 1 位。，是放在传输数据的后面。</p><p>例如：发送端发送的数据为 1101011011，发送和接收双方规定的除数为 10011（有时候说成是多项式）。</p><p>在发送端，先把数据划分为组，假定每组 K 个比特。现假定待传送的数据 M= 1101011011（K=10）。CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码（冗余码是 FCS 编码，位数比多项式位数少 1 位），然后构成一个帧发送出去，一批发送（M+n）位。在所要发送的数据后面增加 n 位的冗余码，虽然增大了数据传输的开销，但却可以进行差错检测。当传输可能出现差错时，付出这种代价往往是很值得的。</p><p><img src="/images/image-20210811154853471.png" alt="image-20210811154853471"></p><p>循环冗余校验 CRC 是一种检错方法。帧检验序列 FCS 是添加在数据后面的冗余码。</p></li></ol><h3 id="3-2-3-纠错编码"><a href="#3-2-3-纠错编码" class="headerlink" title="3.2.3 纠错编码"></a>3.2.3 纠错编码</h3><p>在传输过程中发生错误后能在j接收端自行发现或纠正的码。一般在数据传输过程中增加足够的校验位，通过校验的方法来发现传输数据的错误，并且纠正传输中的错误。</p><ol><li><p>水平垂直奇偶校验码</p><p>即在水平方向上进行验证，也在垂直方向上进行验证，当数据出现的时候，就可以检验出错误的所在，并且修改错误。</p><p>例如用水平垂直偶校验，受到数据为:</p><p><img src="/images/image-20210811155223691.png" alt="image-20210811155223691"></p><p>利用在水平方向上 1 的个数为偶数个</p><p>在垂直方向上 1 的个数为偶数个</p><p>但经过计算发现第二行和第三列 1 的个数为奇数个，判断相应的位置上出现错误。所以可以判断出行列交叉部分出现错误。可以将错误数字 1 改为 0。</p></li><li><p>海明校验</p><p>海明于 1950 年提出只要增加少数几个校验位，就能检测出二位同时出错、亦能检测出一位出错并能自动恢复该出错位的正确值的有效手段。</p><p>原理，是在 k 个数据位之外加上 r 个校验位，从而形成一个 k+r 位的新的码字，使新的码字的码距比较均匀地拉大。把数据的每一个二进制位分配在几个不同的偶校验位的组合中，当某一位出错后，就会引起相关的几个校验位的值发生变化，这不但可以发现出错，还能指出是哪一位出错，为进一步自动纠错提供了依据。</p><p>求 r 校验的方法是： 2<sup>r</sup> ≥ k+r+1 </p><p>其中 r 是校验的位数，k 是传输数据的位数。</p><p>例如：要传输的数据为 1000111，求海明校验码是多少？</p><p>第一步：由已知条件得到 k 是 7 位，所以 2<sup>r</sup> ≥ 7+r+1 ，通过不等式得到 r 的值为4。</p><p>所以可以确定，要传输上述的数据，需要有增加 4 位完成校验过程。</p><p>校验位可以是第 2<sup>0</sup>位、 2<sup>1</sup>位、 2<sup>2</sup>位、 2<sup>3</sup>位；即传输数据的第 1、2、4、8 位是做校验位，其余的位数为数据位。那么传输数据的总位数为 7 位+4 位=11 位。</p><p>第二步：求校验位的数据校验：主要是做进制转化。</p><p><img src="/images/image-20210811155851232.png" alt="image-20210811155851232"></p><p>从行方面看：</p><p>3 转化为二进制为 11，也可以写成 0011，即 3 所对应的一行。</p><p>5 转化为二进制为 101，也可以写成 0101，即 5 所对应的一行。</p><p>从列方面看：</p><p>数字 1 所对应的列里，有出现数字 1 的，说明可以用第 1 位完成校验，出现数字 0 的说明第 1 位不能完成校验。则第 1 位可以校验 3、5、7、9、11 位</p><p>数字 2 所对应的列里，有出现数字 1 的，说明可以用第一位完成校验，出现数字 0 的说明第一位不能完成校验。则第 2 位可以校验 3、6、7、10、11 位</p><p>同理第 4 为可以校验 5、6、7 位； </p><p>第 8 位可以校验 9、10、11 位</p><p>第三步：求解过程：</p><p>因为 1、2、4、8 位是做校验位，所以数据只能存放在 3、5、6、7、9、10、11 位上。</p><p><img src="/images/image-20210811160211614.png" alt="image-20210811160211614"></p><p><img src="/images/image-20210811160241730.png" alt="image-20210811160241730"></p><p><img src="/images/image-20210811160314369.png" alt="image-20210811160314369"></p><p><img src="/images/image-20210811160343414.png" alt="image-20210811160343414"></p><p><img src="/images/image-20210811160412812.png" alt="image-20210811160412812"></p><p><img src="/images/image-20210811160454982.png" alt="image-20210811160454982"></p><p>判断错误的过程为：</p><p>第 1、3、5、7、9、11 位上 1 的格式为偶数个，说明没有错误。</p><p>第 2、3、6、7、10、11 位上 1 的格式为奇数个，说明有错误。</p><p>第 4、5、6、7 位上 1 的格式为奇数个，说明有错误。</p><p>第 8、9、10、11 位上 1 的格式为偶数个，说明没有错误。</p><p>而 2 和 4 号位的奇偶性校对，于是 2+4=6，立即可确认错在 6 号位。可以对其进行修改。</p><p>海明校验码也是能够找出奇数个错误的编码形式，并且对错误进行修改。</p></li></ol><h3 id="3-2-4-可靠传输"><a href="#3-2-4-可靠传输" class="headerlink" title="3.2.4 可靠传输"></a>3.2.4 可靠传输</h3><p>循环冗余检验 CRC 差错检测技术只能做到无差错接收（accept）。</p><p>“无差错接收”是指：“凡是接收的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。</p><p>也就是说：“凡是接收端数据链路层接收的帧都没有传输差错”（有差错的帧就丢弃而不接收）。</p><p>要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。</p><p>帧丢失：收到【#1】-【#3】（丢失【#2】）。</p><p>帧重复：收到【#1】-【#2】-【#2】-【#3】（收到两个【#2】）。</p><p>帧失序：收到【#l】-【#3】-【#2】（后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样）。</p><p>OSI 的观点是必须把数据链路层做成是可靠传输的。因此在 CRC 检错的基础上，增加了<strong>帧编号</strong>、<strong>确认和重传机制</strong>。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。</p><p><strong>因特网广泛使用的数据链路层协议都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务（因为这要付出的代价太高，不合算）</strong>。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，传输层的 TCP 协议）来完成。这样做可以提高通信效率。</p><h2 id="3-3-数据链路层协议"><a href="#3-3-数据链路层协议" class="headerlink" title="3.3 数据链路层协议"></a>3.3 数据链路层协议</h2><h3 id="3-3-1-PPP（点对点）协议"><a href="#3-3-1-PPP（点对点）协议" class="headerlink" title="3.3.1 PPP（点对点）协议"></a>3.3.1 PPP（点对点）协议</h3><ol><li><p>PPP 协议（Point to Point Protocol）有三个组成部分</p><ul><li><p>将 IP 数据报封装到串行链路的方法。</p></li><li><p>链路控制协议 LCP （Link Control Protocol）</p></li><li><p>网络控制协议 NCP （Network Control Protocol）</p></li></ul></li><li><p>ppp 协议满足功能</p><p>身份验证功能</p><p>简单——这是首要的要求</p><p>封装成帧：PPP 协议必须规定特殊的字符作为帧定界符（即标志个帧的开始和结束的字符），以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</p><p>透明性：PPP 协议必须保证数据传输的透明性。如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效的措施来解决。</p><p>多种网络层协议：PPP 协议必须能够在同一条物理链路上同时支持多种网络层协议（如 lP 和 IPX 等）的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</p><p>多种类型链路：PPP 还必能够在多种类型的链路上运行。例如，串行的（一次只发送一个比特）或并行的（一次并行地发送多个比特），同步的或异步的，低速的或高速的，电的或光的，交换的（动态的）或非交换的（静态的）点对点链路。</p><p>差错检测：PPP 协议必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。若在数据链路层不进行差错检测，那么已出现差错的无用帧就还要在网络中继续向前转发，从而会白白浪费许多的网络资源</p><p>检测连接状态：PPP 协议必须具有种机制能够及时（不超过几分钟）自动检测出链路是否处于正常工作状态。</p><p>最大传送单元：PPP </p><p>协议必须每一种点对点的链路设置最大传输单元 MTU 的标准。对于超过 MTU 长度的帧丢弃，并返回错误。</p><p>网络层地址协商</p><p>数据压缩协商</p></li><li><p>ppp 协议不需要的功能</p><ul><li>纠错；流量控制；序号；多点线路；半双工或单工链路。</li></ul><p><strong>PPP 协议只支持全双工链路</strong>。</p></li><li><p>ppp 组成</p><p>PPP 既支持异步链路（无奇偶检验的 8 比特数据），也支持面向比特的同步链路。IP 数据报在 ppp 帧中就是信息部分。这个信息部分的长度受到最大传输单元 MTU 限制。</p><p>1）链路控制协议 LCP （Link Control Protocol）</p><p>用来建立、配置和测试数据链路层连接。</p><p>在通过点对点链接建立通信之前，每个点对点链接的端必须发出链路控制协议包。不论链路控制协议包连接接不接收它的同等连接认证，它们的包大小限制是相同的，还有相同的错误控制。</p><p>2）网络控制协议 NCP （Network Control Protocol）</p><p>网络控制协议是一组独立定义的协议，它们负责在 PPP 建立过程中协商网络层属性。例如，如果一个用户要拨号进入 Cisco 路由器，该用户的机器一般不知道要使用哪个 IP 地址，因此必须通过 NCP/IPCP 协商从 Cisco 路由器获得一个地址。然而，当在专用连接上使用 PPP 时，网络管理者分配所有的网络层属性，因此 NCP 的能力并不重要。</p></li><li><p>ppp 帧的格式</p><p><img src="/images/image-20210811162823323.png" alt="image-20210811162823323"></p><ol><li>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。表示帧的开始和结束的标志。</li><li>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</li><li>控制字段 C 通常置为 0x03。</li><li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。（最长的是 1500 字节）。</li><li>PPP 有一个 2 个字节的协议字段。<ul><li>当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。</li><li>若为 0xC021， 则信息字段是 PPP 链路控制数据。</li><li>若为 0x8021，则表示这是网络控制数据。</li></ul></li></ol></li></ol><h3 id="3-3-2-CSMA-CD-技术"><a href="#3-3-2-CSMA-CD-技术" class="headerlink" title="3.3.2 CSMA/CD 技术"></a>3.3.2 CSMA/CD 技术</h3><p>总线上的广播式数据通信</p><p><img src="/images/image-20210811163117580.png" alt="image-20210811163117580"></p><p>CSMA/CD 是载波监听多点接入／碰撞检测（Carrier Sense MultIPle Access with Collision Detection）的缩写。</p><p>“多点接入”在总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。CSMA/CD 采用 IEEE 802.3 标准。</p><p>它的主要目的是：提供寻址和媒体存取的控制方式，使得不同设备或网络上的节点可以在多点的网络上通信而不相互冲突。</p><ol><li><p>工作过程</p><p>“载波监听”就是“发送前先监听”，即每一个站在发送数据之前先要检测一下总线上是否有其他站在发送数据，如果有，则暂时不要发送数据，要等待信道变为空闲时再发送。</p><p>其原理简单总结为：先听后发，边发边听，冲突停发，随机延迟后重发。</p><ul><li>先听后发：首先“监听”信道，看是否有信号在传输。如果信道空闲，就立即发送。</li><li>边发边听：发送信息的站点在发送过程中同时监听信道，检测是否有冲突发生。</li><li>冲突停发：当发送数据的节点检测到冲突后，就立即停止该次数据传输。</li><li>随机延迟后重发：当发生冲突后，向信道发送 “干扰”信号，以确保其他节点也发现该冲突，等待一段随机时间，再尝试重新发送。</li></ul><p><strong>在使用 CSMA/CD 协议时，一个站点不可能同时进行发送和接收</strong>。所以使用CSMA/CD 协议的以太网只能进行半双工通信或单工通信，不能进行全双工通信。</p></li><li><p>CSMA/CD 优点</p><p>原理比较简单，技术上易实现，网络中各工作站处于平等地位 ，不需集中控制，不提供优先级控制。但在网络负载增大时，发送时间增长，发送效率急剧下降。</p></li><li><p>二进制退避算法</p><p>随机延迟时间</p><p>随机选择的时间和遇到的冲突次数有关：首先规定一个固定的周期 2t，随机的时间是固定周期的整数倍。</p><p>首先：定义冲突次数 n，规定 n 不能超过 10，n=Min[冲突次数，10]。</p><p>其次：从整数集合[0，1，2，……，2<sup>n</sup>-1 ]中随机的取出一个数 m，则随机选择的时间为 m*2t。</p><p>最后：当冲突次数超过 16 次后，发送失败，丢弃传输的帧，发送错误报告。</p><p><img src="/images/image-20210811163822233.png" alt="image-20210811163822233"></p></li><li><p>冲突/冲突域</p><p>冲突：在以太网中，两个节点同时在传输介质上有数据传输，则发生了数据冲突。</p><p>冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧。</p><p>冲突越多，网络性能越差，越影响 CSMA/CD 的通信效率。</p></li><li><p>广播/广播域</p><p>广播：在网络传输中，向所有连通的节点发送消息称为广播。</p><p>广播域：网络中能接收任何一设备发出的广播帧的所有设备的集合。</p><p>广播一般是 IP 地址的主机位为 1，即广播地址，<strong>广播一般在一个网段内发生</strong>。</p></li></ol><h2 id="3-4-数据链路层设备"><a href="#3-4-数据链路层设备" class="headerlink" title="3.4 数据链路层设备"></a>3.4 数据链路层设备</h2><h3 id="3-4-1-硬件地址"><a href="#3-4-1-硬件地址" class="headerlink" title="3.4 1 硬件地址"></a>3.4 1 硬件地址</h3><p><strong>局域网规定了一种 48 位的全球地址，每一台计算机固化在适配器 ROM 芯片中的地址。计算机用户不可以修改该地址。</strong></p><ol><li><p>MAC 层的硬件地址</p><p>在局域网中，硬件地址又称为物理地址，或 MAC (Media Access Control Address, 媒体访问控制地址) 地址。</p><p>802 标准所说的“地址”严格地讲应当是每一个站的“名字”或标识符。</p><p>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节（即高位 24 位）。</p><p><strong>地址字段中的后三个字节（即低位 24 位）由厂家自行指派，称为扩展标识符</strong>，必须保证生产出的适配器没有重复地址。</p><p>一个地址块可以生成 2<sup>24</sup> 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。 </p></li><li><p>MAC 帧格式</p><p><img src="/images/image-20210811164544823.png" alt="image-20210811164544823"></p><p>目的地址字段 6 字节,</p><p>源地址字段 6 字节</p><p>类型字段 2 字节：类型字段用来标志上一层使用的是什么协议，以便把收到的MAC 帧的数据上交给上一层的这个协议。</p><p>数据字段 46 ~ 1500 字节：数据字段的正式名称是 MAC 客户数据字段最小长度 (64 字节− 18 字节的首部和尾部= 数据字段的最小长度)</p><p>FCS 字段 4 字节：当传输媒体的误码率为 1 X 10<sup>−8</sup> 时，MAC 子层可使未检测到的差错小于 1 X 10<sup>−14</sup>。当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 <strong>MAC 帧长不小于 64 字节</strong>。</p></li><li><p>MAC 帧的接收</p><ol><li>正确接收</li></ol><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。</p><p>如果是发往本站的帧则收下，然后再进行其他的处理。</p><p>否则就将此帧丢弃，不再进行其他的处理。</p><p>2）丢弃的帧</p><p>数据字段的长度与长度字段的值不一致；（网络层实现改功能）</p><p>帧的长度不是整数个字节；</p><p>用收到的帧检验序列 FCS 查出有差错；</p><p>数据字段的长度不在 46~1500 字节之间。（<strong>MAC 帧的首部和尾部长度共 18 字节，所以有效的 MAC 帧长度为 64 ~ 1518 字节之间</strong>）。</p><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p></li><li><p>MAC 帧的类型</p><p>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同。</p><p>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧（全 1 地址）。</p><p>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧。</p><p>所有的适配器都至少应当能够识别前两种帧，即能够识别单播和广播地址。有的适配器可用编程方法识别多播地址。当操作系统启动时，它就把适配器初始化，使适配器能够识别某些多播地址。显然，只有目的地址才能使用广播地址和多播地址。</p></li></ol><h3 id="3-4-2-网络适配器"><a href="#3-4-2-网络适配器" class="headerlink" title="3.4.2 网络适配器"></a>3.4.2 网络适配器</h3><ol><li><p>网卡的概念</p><p>网络接口卡 NIC（Network Interface Card）又称网络接口卡或网络适配器。</p><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p></li><li><p>网卡的功能</p><p>1）网络接口</p><p>计算机连接上 internet 网，必须要有接口，可以使得计算机连入网络上。</p><p>2）电信号匹配</p><p>使得信号和电压能适合网络上的编码标准，比如传输的时候能很好的完成曼彻斯特编码或差分曼彻斯特编码技术，并且完成编码的译码任务。</p><p>3）数据的封装与解封</p><p>还需要能把数据链路层要发送的封装成 MAC 帧，完成数据的寻址工作。</p><p>发送时将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。</p><p>4）链路管理</p><p>主要是 CSMA/CD（Carrier Sense MultIPle Access with Collision Detection ，带冲突检测的载波监听多路访问）协议的实现。</p><p><img src="/images/image-20210811165456727.png" alt="image-20210811165456727"></p></li></ol><h3 id="3-4-3-网桥"><a href="#3-4-3-网桥" class="headerlink" title="3.4.3 网桥"></a>3.4.3 网桥</h3><ol><li><p>网桥的概念</p><p><strong>网桥（Bridge）也叫桥接器，是连接两个相同协议的局域网设备</strong>。也可以用于连接大的局域网中相同的网段。</p><p><img src="/images/image-20210811175126501.png" alt="image-20210811175126501"></p></li><li><p>网桥功能</p><p>网桥在数据链路层上的局域网互联设备。</p><p>网桥需要互连的网络在数据链路层以上采用相同的协议；</p><p>网桥以接收、存储、地址过滤与转发的方式实现互连的网络之间的通信；</p><p>网桥可以使得数据的冲突在一个子网内发生。</p><p>网桥能够互连两个采用不同数据链路层协议、不同传输介质与不同传输速率的网络；</p></li><li><p>网桥缺点</p><p>由于网桥对接收的帧要先存储和查找站表，然后转发，这就增加了时延。</p><p>在 MAC 子层并没有流量控制功能。当网络上负荷很重时，可能因网桥缓冲区的存储空间不够而发生溢出，以致产生帧丢失的现象。</p><p>具有不同 MAC 子层的网段桥接在一起时，网桥在转发一个帧之前，必须修改帧的某些字段的内容，以适合另一个 MAC 子层的要求，增加时延。</p><p>网桥只适合于用户数不太多（不超过几百个）和信息量不太大的局域网，否则有时会产生较大的广播风暴。</p></li></ol><h3 id="3-4-4-交换机"><a href="#3-4-4-交换机" class="headerlink" title="3.4.4 交换机"></a>3.4.4 交换机</h3><ol><li><p>局域网交换机</p><p>1990 年问世的交换式集线器（switching hub），可明显地提高局域网的性能。</p><p><strong>交换机（Switch）可以看成是多端口网桥，是一种用于电（光）信号转发的网络设备</strong>。可以为接入交换机的任意两个网络节点提供独享的电信号通路，不同的通信信道之间相互不影响通信。最常见的交换机是以太网交换机、电话语音交换机、光纤交换机等。</p><p>交换式集线器常称为以太网交换机（switch）或第二层交换机（表明此交换机工作在数据链路层）。</p></li><li><p>工作原理</p><p>交换机工作于 OSI 参考模型的数据链路层。</p><p>1）按端口转发数据</p><p>交换机本身有一个路由表，路由表中记录了交换机端口主机的 MAC 地址和端口对应信息，当交换机收到 MAC 帧后。交换机直接根据路由表的信息，MAC 地址的数据包将仅送往其对应的端口。</p><p>2）隔离集线器广播</p><p>交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层的 IP 广播地址，即广播域。</p><p>交换机可以有效的避免有集线器形成的广播，但是不能隔离计算机网络层的广播（广播的 IP 地址）。</p><p>3）端口独立性</p><p><strong>交换机每一端口都可视为独立的物理网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。</strong></p><p>4）传输方式</p><p>交换机的传输模式有全双工，半双工，全双工/半双工自适应</p><p>交换机的全双工是指交换机在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。交换机都支持全双工。全双工的好处在于迟延小，速度快。</p><p>5）虚拟局域网（Vlan）功能</p><p>VLAN（Virtual Local Area Network）的中文名为”虚拟局域网”。</p><p>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。</p></li></ol><h3 id="3-4-5-虚拟局域网"><a href="#3-4-5-虚拟局域网" class="headerlink" title="3.4.5 虚拟局域网"></a>3.4.5 虚拟局域网</h3><p>VLAN 是工作在 OSI 参考模型的第 2 层和第 3 层，一个 VLAN 就是一个广播域，VLAN 之间的通信是通过第 3 层的路由器来完成的。与传统的局域网技术相比较，VLAN 技术更加灵活，它具有以下优点</p><ul><li>网络设备的移动</li><li>添加和修改的管理开销减少</li><li>可以控制广播活动</li><li>可提高网络的安全性。</li></ul><p>在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互隔离的。不同的广播域之间想要通信，需要通过一个或多个路由器。这样的一个广播域就称为 VLAN。</p><p>核心是把不同的交换机接口划分到不同的子网中，这样子网的内部广播不会影响到其他的网络计算机。</p><p><img src="/images/image-20210811180529042.png" alt="image-20210811180529042"></p><ol><li><p>虚拟局域网优点</p><p>限制网络上的广播，将网络划分为多个 VLAN 可减少参与广播风暴的设备数量。LAN 分段可以防止广播风暴波及整个网络。</p><p>VLAN 可以提供建立防火墙的机制，防止交换网络的过量广播。使用 VLAN，可以将某个交换端口或用户赋于某一个特定的 VLAN 组，该 VLAN 组可以在一个交换网中或跨接多个交换机，在一个 VLAN 中的广播不会送到 VLAN 之外。同样，相邻的端口不会收到其他 VLAN 产生的广播。这样可以减少广播流量，释放带宽给用户应用，减少广播的产生。</p></li><li><p>虚拟局域网的划分策略</p><p>1）按端口划分 VLAN</p><p>许多 VLAN 厂商都利用交换机的端口来划分 VLAN 成员。被设定的端口都在同一个广播域中。例如，一个交换机的 1，2，3，4，5 端口被定义为虚拟网 AAA，同一交换机的 6，7，8 端口组成虚拟网 BBB。这样做允许各端口之间的通讯，并允许共享型网络的升级。但是，这种划分模式将虚拟网限制在了一台交换机上。</p><p>2）按 MAC 地址划分 VLAN</p><p>这种划分 VLAN 的方法是根据每个主机的 MAC 地址来划分，即对每个 MAC 地址的主机都配置它属于哪个组。这种划分 VLAN 方法的最大优点就是当用户物理位置移动时，即从一个交换机换到其他的交换机时，VLAN 不用重新配置，所以，可以认为这种根据MAC地址的划分方法是基于用户的VLAN，这种方法的缺点是初始化时，所有的用户都必须进行配置，如果有几百个甚至上千个用户的话，配置是非常累的。而且这种划分的方法也导致了交换机执行效率的降低，因为在每一个交换机的端口都可能存在很多个 VLAN 组的成员，这样就无法限制广播包了。另外，对于使用笔记本电脑的用户来说，他们的网卡可能经常更换，这样，VLAN 就必须不停地配置。</p><p>3）按网络层划分</p><p>这种划分 VLAN 的方法是根据每个主机的网络层地址或协议类型(如果支持多协议)划分的，虽然这种划分方法是根据网络地址，比如 IP 地址，但它不是路由，与网络层的路由毫无关系。</p><p>这种方法的优点是用户的物理位置改变了，不需要重新配置所属的 VLAN，而且可以根据协议类型来划分 VLAN，这对网络管理者来说很重要，还有，这种方法不需要附加的帧标签来识别 VLAN，这样可以减少网络的通信量。</p><p>这种方法的缺点是效率低，因为检查每一个数据包的网络层地址是需要消耗处理时间的(相对于前面两种方法)，一般的交换机芯片都可以自动检查网络上数据包的以太网帧头，但要让芯片能检查 IP 帧头，需要更高的技术，同时也更费时。当然，这与各个厂商的实现方法有关。</p><p>4）按 IP 组播划分</p><p>IP 组播实际上也是一种 VLAN 的定义，即认为一个组播组就是一个 VLAN，这种划分的方法将 VLAN 扩大到了广域网，因此这种方法具有更大的灵活性，而且也很容易通过路由器进行扩展，当然这种方法不适合局域网，主要是效率不高。</p></li><li><p>虚拟局域网帧的格式</p><p><img src="/images/image-20210811181158788.png" alt="image-20210811181158788"></p><p>虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记（tag），用来指明发送该帧的工作站属于哪一个虚拟局域网。</p></li></ol><h2 id="3-5-局域网技术"><a href="#3-5-局域网技术" class="headerlink" title="3.5 局域网技术"></a>3.5 局域网技术</h2><h3 id="3-5-1-局域网概念"><a href="#3-5-1-局域网概念" class="headerlink" title="3.5.1 局域网概念"></a>3.5.1 局域网概念</h3><p>局域网（Local Area Networks，LAN）是分组广播式网络，在广播通信网络中，所有的工作站都连接到共享的传输介质上，任何站发出的数据包其他站都能接收。共享信道的分配技术是局域网的核心技术，而这一技术又与网络的拓扑结构和传输介质有关。</p><h3 id="3-5-2-局域网结构"><a href="#3-5-2-局域网结构" class="headerlink" title="3.5.2 局域网结构"></a>3.5.2 局域网结构</h3><ol><li><p>拓扑结构</p><p>局域网采用拓扑结构主要是：总线型、环型、星型、树形拓扑结构。</p><p>1）总线型拓扑结构</p><p>总线型拓扑结构接入计算机的数量有限，数量过多，影响网络通信速率。</p><p>安装简单方便，需要铺设的电缆最短，成本低。</p><p>某个站点的故障不会影响整个网络，但总线介质的故障会导致网络瘫痪。</p><p>总线网络故障不易排除，很难检测出是哪个段线路出现的故障。</p><p>广播式通信，总线型网络安全性低。 </p><p>2）环型拓扑结构</p><p>环型拓扑结构需要多个网络连接设备，使得网络价格增加。</p><p>信息以固定方向单向流动，信息传输时，不需要线路选择，速度比较块。</p><p>网络中各某个工作站节点出故障，可能影响整个网络的通信。</p><p>不便于扩充，系统响应延时长，</p><p>主要采用令牌来控制网络信道的使用。</p><p>3）星型拓扑结构</p><p>计算机接入简单。网络线缆重复铺设比较大。</p><p>星型拓扑结构的特点是很容易在网络中增加新的站点。</p><p>中心节点的故障会引起整个网络瘫痪。</p><p>故障容易排除，在局域网中使用比较多的拓扑结构。</p><p>4）树形拓扑结构</p><p>继承了星型和总线的优点。</p><p>网络中结点扩充方便、灵活，寻查链路路径比较简单。</p><p>兄弟节点要进行数据传输的时候，必须通过父节点进行转发。</p><p>对根节点要求比较高。</p></li></ol><h3 id="3-5-3-局域网协议标准"><a href="#3-5-3-局域网协议标准" class="headerlink" title="3.5.3 局域网协议标准"></a>3.5.3 局域网协议标准</h3><p>802.1X 协议是由（美）电气与电子工程师协会提出，刚刚完成标准化的一个符合IEEE802 协议集的局域网接入控制协议，全称为基于端口的访问控制协议。</p><ul><li>802.1–高层及其交互工作。提供高层标准的框架，包括端到端协议、网络互连、网络管理、路由选择、桥接和性能测量。</li><li>802.2–连接链路控制 LLC，提供 OSI 数据链路层的高子层功能，提供 LAN、MAC子层与高层协议间的一致接口。</li><li>802.3–以太网规范。定义 CSMA/CD 标准的总线介质访问控制子层和物理层规范。</li><li>802.4–令牌总线网。令牌总线（Token Bus）介质访问控制子层和物理层规范。</li><li>802.5–令牌环线网，令牌传环（Token Ring）介质访问控制子层和物理层规范。</li><li>802.6–城域网 MAN。城域网的介质访问控制子层和物理层规范。</li><li>802.7–宽带技术咨询组，为其他分委员会提供宽带网络技术的建议和咨询。</li><li>802.8–光纤技术咨询组，为其他分委员会提供使用有关光纤网络技术的建议和咨询。</li><li>802.9–综合话音/数据局域网。</li><li>802.10–可互操作局域网安全标准（SILS ）。定义局域网互连安全机制。</li><li>802.11–无线局域网。定义自由空间媒体的媒体访问控制子层和物理层规范。</li><li>802.12–按需优先。定义使用按需优先访问方法的 100Mpbs 的以太网标准。</li><li>802.14–定义了电缆调调制解调器（cable modem）标准。</li><li>802.15–定义了近距离个人无线网络标准。</li><li>802.16–定义了宽带无线局域网标准。</li></ul><p>局域网主要使用 OSI 结构的下两层进行数据的通信和传输，所以 IEEE 802 标准把数据链路层划分成了两个子层。</p><p>与物理介质相关的 MAC（Media Access Conrrol）介质访问控制子层。</p><p>与上层“网络层”服务相关的 LLC（Logical Link Control），逻辑链路控制子层。</p><p><img src="/images/image-20210811183157243.png" alt="image-20210811183157243"></p><ol><li><p>逻辑链路控制子层</p><p>逻辑链路控制子层主要是接收上一层即网络层传输过来的数据包，参与数据包的封装。一般分为数据添加上相应的包头信息：MAC 头、LLC 头、IP 头、TCP 头等。</p><p>LLC 负责识别网络层协议，然后对它们进行封装/接封装。工作原理是：主机接收到帧并查看其 LLC 报头，以找到数据包的目的地（查看数据包中各种包头协议）。LLC子层也可以提供流量控制并控制比特流的排序。</p><p>LLC 的主要功能是：管理数据链路通信、链接寻址、定义服务接入点 Service Access Points （SAP）、排序。</p></li><li><p>介质访问控制子层</p><p>MAC 主要负责控制与连接物理层的物理介质。</p><p>在发送数据的时候，MAC 协议在发送的数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；在接收数据的时候，MAC 协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至 LLC（逻辑链路控制）层，如果有错误产生，则直接丢弃当前的数据，告知对方需要重新传输数据。</p></li></ol><h3 id="3-5-4-局域网特点"><a href="#3-5-4-局域网特点" class="headerlink" title="3.5.4 局域网特点"></a>3.5.4 局域网特点</h3><p>覆盖范围小，一般覆盖范围有限几米到几十千米之间。</p><p>传输速度块，局域网内部传输的速度可以达到几百兆到几千兆。</p><p>局域网主要的功能是共享，能方便地共享昂贵的外部设备、主机以及软件、数据，使得局域网建设后可以节省很多的成本。</p><p>接入灵活，当新的计算机或终端接入网络时，可以很好的对单个设备进行设置。</p><p>误码率低，局域网覆盖的范围小，所以在传输中受到的感染相比比较少，这样能很好的保证信号的准确性。</p><p>低延时，局域网距离有限，所以在数据传输过程中，不需要过的线路选择和线路的传输延迟。</p><p>结构简单，局域网内部采用很简单的拓扑结构，所以在组建和维护比较容易，故障也比较容易维护。</p><h3 id="3-5-5-访问控制技术"><a href="#3-5-5-访问控制技术" class="headerlink" title="3.5.5 访问控制技术"></a>3.5.5 访问控制技术</h3><ol><li><p>循环式</p><p>每个站轮流得到发送机会。如果工作站利用这个机会发送，则可能对其发送时间或发送的数据总量有一定限制，超过这个限制的数据只能在下一轮中发送。所有的站按一定的逻辑顺序传递发送权限。这种顺序控制可能是集中式的，也可能是分布式的。</p></li><li><p>预约式</p><p>流式通信就是长时间连续传输。预约式控制适合这种通信方式。一般来说，这种技术把传输介质的使用时间划分为时间片。</p></li><li><p>竞争式</p><p>这种技术并不对各个工作站的发送权限进行控制，而是由各个工作站自由竞争发送机会，更适合分布式控制。</p><p>竞争式分配的主要优点在于其简单性。在轻负载或中等负载下效率较高。当负载很重时，其性能很快下降。</p></li></ol><h3 id="3-5-6-局域网技术"><a href="#3-5-6-局域网技术" class="headerlink" title="3.5.6 局域网技术"></a>3.5.6 局域网技术</h3><p>局域网在使用通信的时候，采用多种协议进行数据的访问控制：</p><p><img src="/images/image-20210811183626355.png" alt="image-20210811183626355"></p><ol><li><p>以太网</p><p>1）以太网标准</p><p>以太网（Ethernet）指的是由 Xerox 公司创建并由 Xerox、Intel 和 DEC 公司联合开发的基带局域网规范，是当今现有局域网采用的最通用的通信协议标准。</p><p>以太网络使用 CSMA/CD（载波监听多路访问及冲突检测）技术。</p><p>以太网（10Mbit/s）、快速以太网（100Mbit/s）和 10G（10Gbit/s）吉比特以太网。它们都符合 IEEE802.3。</p><p>2）CSMA/CD 技术</p><p>带冲突检测的载波侦听多路访问 （CSMA/CD）技术规定了多台电脑共享一个通道的方法。</p><p>3）共享式以太网</p><p>共享式以太网的典型代表是使用 10Base2/10Base5 的总线型网络和以集线器为核心的星型网络。在使用集线器的以太网中，集线器将很多以太网设备集中到一台中心设备上，这些设备都连接到集线器中的同一物理总线结构中。</p><p>4）交换式以太网</p><p>在交换式以太网中，交换机根据收到的数据帧中的 MAC 地址决定数据帧应发向交换机的哪个端口，交换式以太网主要使用交换机来作为中心的设备传输。</p><p>交换式网络：</p><ul><li>减少冲突：交换机将冲突隔绝在每一个端口（每个端口都是一个冲突域），避免了冲突的扩散。</li><li>提升带宽：接入交换机的每个节点都可以使用全部的带宽，而不是各个节点共享带宽。</li></ul></li><li><p>令牌环网（Tooken Ring）</p><p>令牌是一种控制网络访问的特殊帧，允许哪个的设备计算机网络发送数据。</p><p>在令牌环网中有一个令牌沿着环形总线在入网节点计算机间依次传递，通过令牌控制信道的使用，确保在同一时刻只有一个节点能够独占信道。</p><p>令牌在工作中有“闲”和“忙”两种状态。“闲”表示令牌没有被占用，即网中没有计算机在传送信息；“忙”表示令牌已被占用，即网中有信息正在传送。</p><p>节点计算机只有取得令牌后才能发送数据帧，因此不会发生碰撞。</p><p>由于令牌在网环上是按顺序依次传递的，因此对所有入网计算机而言，访问权是公平的。</p></li><li><p>令牌总线网（Tooken Bus）</p><p>令牌总线网的拓扑结构是总线网，在数据传输的时候是环型网。是一种在总线拓扑中利用令牌作为控制节点访问公共传输介质的访问控制方法。</p><p>令牌按照站点地址的序列号，从一个站点传送到另外一个站点。数据从数字的第一个站点出发，在数字序列的最后一个站点将令牌返回到第一个站点。</p><p>站点的数字序列和物理位置无关，不一定按照物理位置编号，站点 1 可能在一条电缆的一端，而站点 2 在这条电缆的另外一端，站点 3 却在这条电缆的中间。</p><p>主要的工作是利用令牌来控制网络中节点数据的发送。</p><p>网上只有一个令牌沿环传递，得到令牌的站才能发送数据。</p></li><li><p>光纤分布式数据接口网（FDDI）</p><p>FDDI 的英文全称为（Fiber Distributed Data Interface），光纤分布式数据接口网络。</p><p>FDDI 在网络通信中采用定时“令牌”访问方法。</p><p>令牌沿网络环路从一个结点向另一个结点移动，如果某结点不需要传输数据，FDDI 将获取令牌并将其发送到下一个结点中。如果处理令牌的结点需要传输，那么在指定的称为“目标令牌循环时间”（Target Token Rotation Time，TTRT）的时间内，它可以按照用户的需求来发送尽可能多的帧。因为 FDDI 采用的是定时的令牌方法，所以在给定时间中，来自多个结点的多个帧可能都在网络上，以为用户提供高容量的通信。</p></li></ol><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络层基本概述"><a href="#4-1-网络层基本概述" class="headerlink" title="4.1 网络层基本概述"></a>4.1 网络层基本概述</h2><h3 id="4-1-1-网络层功能"><a href="#4-1-1-网络层功能" class="headerlink" title="4.1.1 网络层功能"></a>4.1.1 网络层功能</h3><ol><li><p>异构网络互联</p><p>1）异构网络概念</p><p>异构网络（Heterogeneous Network）是一种类型的网络，其是由不同制造商生产的计算机，网络设备和系统组成的，大部分情况下运行在不同的协议上支持不同的功能或应用。</p><p>2）网络互联</p><p>网络互连是指将不同的网络连接起来，以构成更大规模的网络系统，实现网络间的数据通信、资源共享和协同工作。</p><p>3）异构网络互联</p><p>解决不同的网络相互之间连接在一起，通过路由器等设备进行信息的转发，使得网络用户能访问其他网络上的资源，使不同网络上的用户互相通信和交换信息。这不仅有利于资源共享，也可以从整体上提高网络的可靠性。</p></li><li><p>两种服务</p><p>1）面向连接服务</p><p>面向连接的服务（connection-oriented service）就是通信双方在通信时，要事先建立一条通信线路，其过程有建立连接、使用连接和释放连接三个过程。</p><p>面向连接服务其特点是：数据传输过程前必须经过建立连接、维护连接和释放连接的 3 个过程；在数据传输过程中，各分组不需要携带目的节点的地址。</p><p>面向连接服务的传输过程可以用电路交换，一端放入数据，另一端取出数据。面向连接数据传输的收发数据顺序不变，因此传输的可靠性好，但需通信开始前的链接开销，协议复杂，通信效率不高。</p><p>2）无连接服务</p><p>无连接服务，不要求发送方和接收方之间事先连接。发送方给每个发送的数据分组（称为数据报）添加目的地址，数据就可以沿着不同的线路进行传输，最后到达目的地。</p><p>无连接服务的优点是通信比较迅速，使用灵活方便，连接开销小；但可靠性低，不能防止报文的丢失，重复或失序。适合于传送少量零星的报文。</p></li><li><p>路由选择</p><p>路由选择是指选择通过互连网络从源节点向目的节点传输信息的通道，而且信息至少通过一个中间节点。路由器利用网络层中定义的逻辑地址来决定如何在网络通信中更有效地传输数据信息，协议定义数据传输的语法和规则。</p><p>目的是在复杂的网络环境下，选择一条合适的网络路径来进行网络通信。保证数据的可靠的传输。</p><p>路径选择功能在 OSI 参考模型的网络层实现。</p></li><li><p>最大努力交付</p><p>网络层传输数据时，对传输的数据不进行校验，传输的过程中分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</p></li></ol><h3 id="4-1-2-网络层的服务"><a href="#4-1-2-网络层的服务" class="headerlink" title="4.1.2 网络层的服务"></a>4.1.2 网络层的服务</h3><ol><li><p>面向连接的通信</p><p>建立虚电路（Virtual Circuit），以保证双方通信所需的一切网络资源。</p><p>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。</p><p><img src="/images/image-20210811201805068.png" alt="image-20210811201805068"></p><p>虚电路和电路连接的区别：</p><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</li></ul></li><li><p>无连接的通信</p><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p><p><img src="/images/image-20210811201928840.png" alt="image-20210811201928840"></p><p>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</p><p>尽最大努力交付。</p><p>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</p><p>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的传输层负责（包括差错处理、流量控制等）。</p><p>采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。</p></li><li><p>虚电路交换和报文交换对比</p><p><img src="/images/image-20210811202151306.png" alt="image-20210811202151306"></p></li></ol><h3 id="4-1-3-网络层的协议"><a href="#4-1-3-网络层的协议" class="headerlink" title="4.1.3 网络层的协议"></a>4.1.3 网络层的协议</h3><ol><li><p>地址解析协议 ARP（Address Resolution Protocol）</p><p>1）基本概念</p><p>是<strong>根据 IP 地址获取物理地址的一个 TCP/IP 协议</strong>。主机发送信息时将包含目标 IP地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。</p><p><img src="/images/image-20210811203103158.png" alt="image-20210811203103158"></p><p>IP 地址→ARP 协议→物理地址（MAC）</p><p>2）ARP 高速缓存的作用</p><p>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。</p><p>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</p><p>3）注意</p><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。</p><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p>从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。</p><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 </p><p>4）ARP 报文格式</p><p><img src="/images/image-20210811204004837.png" alt="image-20210811204004837"></p><p>协议类型：指明了发送方提供的高层协议类型，IP 为 0800（16 进制）</p><p>操作类型：用来表示这个报文的类型，ARP 请求为 1，ARP 响应为 2，RARP 请求为 3，RARP 响应为 4。 </p><p>5）ARP 命令</p><p>C:\Users\Administrator&gt;ARP /?</p><p>格式：</p><p>ARP -s inet_addr eth_addr [if_addr]</p><p>ARP -d inet_addr [if_addr]</p><p>ARP -a [inet_addr] [-N if_addr] [-v]</p><p>参数：</p><p>-a：通过询问当前协议数据，显示当前 ARP 项。如果指定 inet_addr，则只显示指定计算机的 IP 地址和物理地址。如果不止一个网络接口使用 ARP，则显示每个ARP 表的项。</p><p><img src="/images/image-20210811204306821.png" alt="image-20210811204306821"></p><p>-v 在详细模式下显示当前 ARP 项。所有无效项和环回接口上的项都将显示。inet_addr 指定 Internet 地址。</p><p>-N if_addr 显示 if_addr 指定的网络接口的 ARP 项。</p><p>-d 删除 inet_addr 指定的主机。inet_addr 可以是通配符 *，以删除所有主机。</p><p>-s 添加主机并且将 Internet 地址 inet_addr 与物理地址 eth_addr 相关联。物理地址是用连字符分隔的 6 个十六进制字节。该项是永久的。</p><p>eth_addr 指定物理地址。</p><p>if_add 如果存在，此项指定地址转换表应修改的接口的 Internet 地址。如果不存在，则使用第一个适用的接口。</p><p>示例:</p><p>&gt; ARP -s 157.55.85.212 00-aa-00-62-c6-09  添加静态项。</p><p>&gt; ARP -a   显示 ARP 表。</p></li><li><p>逆地址解析协议 RARP（Reverse Address Resolution Protocol）</p><p>允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。 RARP 可以使用于以太网、光纤分布式数据接口及令牌环 LAN。</p><p>物理地址（MAC）→RARP 协议→IP 地址</p></li><li><p>internet 控制报文协议 ICMP（Internet Control Message Protocol）</p><p>1）基本概念</p><p>用于在 IP 主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。侦测远端主机是否存在；建立及维护路由资料；重导资料传送路径（ICMP 重定向）；资料流量控制。</p><p>2）ICMP 格式</p><p> ICMP 使用时，一般伴随 IP 使用：</p><p><img src="/images/image-20210811205833205.png" alt="image-20210811205833205"></p><p>ICMP 报文具体格式如下：除去数据部分，ICMP 数据报文一共有 8 个字节。</p><p><img src="/images/image-20210811210015845.png" alt="image-20210811210015845"></p><p>3）ICMP 类型</p><p><img src="/images/image-20210811210114675.png" alt="image-20210811210114675"></p></li><li><p>internet 管理协议 IGMP（Internet Group Management Protocol）</p><p>因特网协议家族中的一个组播协议，用于 IP 主机向任一个直接相邻的路由器报告他们的组成员情况。它规定了处于不同网段的主机如何进行多播通信，其前提条件是路由器本身要支持多播。</p></li></ol><h2 id="4-2-IP-地址"><a href="#4-2-IP-地址" class="headerlink" title="4.2 IP 地址"></a>4.2 IP 地址</h2><h3 id="4-2-1-IPV4"><a href="#4-2-1-IPV4" class="headerlink" title="4.2.1 IPV4"></a>4.2.1 IPV4</h3><ol><li><p>IPV4 概念</p><p>1）IPV4 地址的概念</p><p>IP（Internet Protocol Address）地址是指互联网协议地址，是 IP Address 的缩写。<strong>在互联网上的每一台计算机分配唯一的一个逻辑地址，即 IP 地址。</strong>使用 IP 地址来进行广域网的寻址和数据报的传输。</p><p>2）IPV4 地址的特点</p><p>a. 唯一性</p><p>在 Internet 上的计算机所拥有的 IP 地址是不同的，即网络中不能有两台主机同时使用同一个 IP 地址。如果使用会造成 IP 地址冲突，使得后使用者不能使用 IP 地址进行网路连接。</p><p>一台计算机上可以设置多个 IP 地址，但是使用的时候只能用其中的 1 个发送数据或作为计算机的唯一标识。</p><p>b. 固定长度</p><p>IPV4 地址是由 32 位二进制表示的，在 IPV4 地址中理论可以放  2<sup>32</sup> 个 IP 地址，当然去掉一部分特殊的 IP 地址后，使得 IP 地址的总数量会减少。</p><p>c. 点分十进制</p><p>由于 32 位二进制不容易记忆和书写，所以在书写 IP 地址的时候，需要用到点分十进制书写，即把32位二进制平均分成4个字节，然后把二进制数转化为十进制书写，中间用点号隔开。转化后十进制数值不大于 255。</p><p><img src="/images/image-20210811211122740.png" alt="image-20210811211122740"></p><p>d. 可变性</p><p>计算机拥有的 IP 地址不是固定不变的，当计算机所在的网络发生变化后，其 IP地址也要跟着发生变化。注意这里的变化指的是网络发生变化不是计算机的位置变化。</p><p>注意：逻辑（IP）地址可变，但是物理（MAC）地址不可变。</p><p>e. 组成</p><p><strong>IP 地址由两部分组成：{ &lt;网络号&gt;，&lt;主机号&gt;}</strong></p><p>网络号：表示计算机所在的网络，路由器在进行路由选择的时候使用的。</p><p>主机号：表示网络中的某台主机，是计算机在某个网络中的唯一标识。</p><p>网络号相同的计算机可以不经过路由器的转发就可以直接通信。</p></li><li><p>IPv4 分类</p><p>1）国际分类标准</p><p>根据 32 位中的第一个字节的不同，可以将 IP 地址分为 ABCDE 五大类。</p><p><img src="/images/image-20210811211444124.png" alt="image-20210811211444124"></p><p>2）使用范围分类</p><ol><li><p>公有 IP 地址</p><p>公有地址由 Inter NIC（Internet Network Information Center 因特网信息中心）负责分配。当有组织机构提出申请后，可以由 Inter NIC 分配给该机构一个公有的 IP 地址。通过公有 IP 可直接访问因特网。</p></li><li><p>私有 IP 地址</p><p>私有地址不需要注册，可以直接使用的地址，一般在公司内部使用。</p><p>常见的私有地址有：</p><p>A 类 10.0.0.0–10.255.255.255</p><p>B 类 172.16.0.0–172.31.255.255</p><p>C 类 192.168.0.0–192.168.255.255</p></li><li><p>计算机不能直接使用</p><p>有些计算机的 IP 地址是不能直接被计算机使用：</p><ul><li>主机号全为 0 的地址表示网络号。</li><li>主机号全为 1 的地址表示本网广播地址。</li><li>32 位全为 1 表示广播地址</li><li>127 开头的地址是本地回环地址，是用来测试 TCP/IP 协议的正确性。</li><li>当计算机自动获取 IP 地址失败后，会获取一个 169.254.*.*地址，这部分地址是用来标识计算机的，不能用于网络通信使用</li></ul></li><li><p>IP 地址汇总</p><p><img src="/images/image-20210811213000667.png" alt="image-20210811213000667"></p></li><li><p>子网掩码</p><ol><li><p>子网掩码概念</p><p>子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。</p></li><li><p>子网掩码功能</p><p>子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p><p>子网掩码是一个 32 位地址，一般在书写的时候也是点分十进制表示。</p><p><strong>在子网掩码中，1 表示网络位，0 表示主机位</strong>。</p></li><li><p>默认子网掩码</p><p>A 类网络的子网掩码为 255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为 255.255.255.0。</p></li><li><p>求网络号</p><p>主机号全为 0 的地址表示网络号。</p><p>第一步把 IP 地址转化为二进制。</p><p>第二步把子网掩码转化为二进制。</p><p>第三步保留子网掩码中 1 所对应的部分，主机位用 0 填充。</p><p>第四步转为点分十进制。</p><p>求 IP 地址为 192.172.123.125，子网掩码为 255.255.255.240 的网络号？</p><p><img src="/images/image-20210811213843272.png" alt="image-20210811213843272"></p></li><li><p>求广播号</p><p>主机号全为 1 的地址表示广播号。</p><p>第一步把 IP 地址转化为二进制。</p><p>第二步把子网掩码转化为二进制。</p><p>第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。</p><p>第四步转为点分十进制。</p><p>求 IP 地址为 192.172.123.125，子网掩码为 255.255.255.240 的网络号？</p><p><img src="/images/image-20210811214013844.png" alt="image-20210811214013844"></p></li><li><p>求主机号</p><p>第一步把 IP 地址转化为二进制。</p><p>第二步把子网掩码转化为二进制。</p><p>第三步保留子网掩码中 0 所对应的部分。</p><p>求 IP 地址为 192.172.123.125，子网掩码为 255.255.255.240 的主机号？</p><p><img src="/images/image-20210811214102623.png" alt="image-20210811214102623"></p></li></ol></li></ol></li></ol><h3 id="4-2-2-子网划分"><a href="#4-2-2-子网划分" class="headerlink" title="4.2.2 子网划分"></a>4.2.2 子网划分</h3><ol><li><p>划分子网划分的好处</p><p>节约 IP 地址，避免浪费，使得大网络划分成小的网络，这样可以分配给公司使用，能很好的解决 IP 地址紧缺的问题。</p><p>限定广播的传播，可以把计算机网络中的广播限制在一个小的广播域。</p><p>保证网络的安全，有助于覆盖大型地理区域。</p></li><li><p>子网数量计算</p><p>形成子网的数量计算：从主机位借位当网络位来使用。</p><p><img src="/images/image-20210811214250580.png" alt="image-20210811214250580"></p></li><li><p>子网划分例题</p><p>C 类地址例子：网络地址 202.168.10.0；子网掩码 255.255.255.192 。</p><p>第一步：子网数= （原来 C 类默认是 24 位子网掩码，现在有 26 位子网掩码，借了 2 位）</p><p>第二步：主机数= 2<sup>6</sup>=64（计算机网络可用主机的数量是 64-2=62 个） </p><p>第三步：有效主机范围是：</p><p><img src="/images/image-20210811214652287.png" alt="image-20210811214652287"></p></li></ol><h3 id="4-2-3-IP-转发"><a href="#4-2-3-IP-转发" class="headerlink" title="4.2.3 IP 转发"></a>4.2.3 IP 转发</h3><ol><li><p>局域网内</p><p>同一局域网内计算机之间通信是根据 IP 地址和 MAC 地址的对应信息直接通信，不需要经过路由器端口的转发，只需要保证计算机的 IP 地址是在同一网段中就可以。同一网段的问题涉及到的是子网划分技术。</p></li><li><p>广域网</p><p>广域网通信主要是利用计算机的 IP 地址进行寻址和通信，数据报需要经过多个路由器的转发，不断的变化 MAC 地址，最终根据目的地址（IP）找到目的主机。</p><p>在通信过程中，需要涉及到网络安全，不能泄漏内部网路的地址信息，所以数据需要进行数据传输的时候要考虑到以下的措施：第一在广域网上传输时，内部 MAC 地址不能传输到外部网络。第二内部的 IP 地址需要经过 Nat 技术变化为外部的 IP 地址。但变换后的 IP 地址信息就不再发生变化了。</p><p>广域网进行路径选择的时候需要录用路由表的信息，寻找合适的路径。</p></li><li><p>IP 报文传输</p><p><img src="/images/image-20210811215020902.png" alt="image-20210811215020902"></p><p>在传输过程中：下一层的帧是看不到上一层数据的控制信息，只能查看本层的数据协议信息，并且对其封装和转发。</p><p>网络层的逻辑寻址：在整个传输过程中 IP 的源地址和目的地址不变。</p><p>数据链路层物理寻址：在整个传输过程中 MAC 帧的物理地址不断变化。</p><p>物理层的信号传输：物理层主要是负责信号的实际传输。</p></li></ol><h3 id="4-2-4-IP-报文格式"><a href="#4-2-4-IP-报文格式" class="headerlink" title="4.2.4 IP 报文格式"></a>4.2.4 IP 报文格式</h3><p>IP 数据包也叫 IP 报文分组，传输在 ISO 网络 7 层结构中的网络层，它由 IP 报文头和 IP 报文用户数据组成，IP 报文头的长度一般在 20 到 60 个字节之间，其中固定长度是 20 字节，而一个 IP 分组的最大长度则不能超过 65535 个字节，在传输中一般不会超过 65525 的长度，在数据帧中有最大传输单元 MTU 的限制。</p><p><img src="/images/image-20210811215203709.png" alt="image-20210811215203709"></p><ol><li><p>版本（4 位）</p><p>指 IP 协议的版本，0100 表示 IPV4，0110 表示 IPV6。在通信时，计算机所使用的 IP 版本号必须相同。</p></li><li><p>首部长度（4 位）</p><p>范围是 0000—1111，最小为 0，最大为 15。1 个单位 4 字节，IP 的首部长度的最大值是 60 字节。</p></li><li><p>区分服务（8 位）</p><p>用来获得更好的服务。</p><p>前 3 位表示报文的优先级：111 网络控制；110 互联网控制；101 紧急；100 火速覆盖；011 火速；010 立即；001 优先级；000 路由。</p><p><img src="/images/image-20210811215437480.png" alt="image-20210811215437480"></p><p>相应的位数上为 1 表示更低时延、更高的吞吐量、更高的可靠性、更低的路由代价等。</p></li><li><p>总长度（16 位）</p><p>指首部和数据之和的长度，单位为字节，数据长度不超过最大传送单元 MTU。理论最大长度为 65535 字节。包头总长度必须是 32 位节的整数倍。</p><p>若数据报长度超过对于 MTU 的值，就将数据报进行分片处理，此时数据报首部中的总长度字段是指分片后的每一个分片的报头长度和数据长度之和。</p></li><li><p>标识（16 位）</p><p>是一个计数器，用来产生数据报的标识。每产生一个数据报，计数器就加 1，并将值赋给标识字段。但是这个标识不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。</p><p>当数据报进行分片处理后，每个分片的标识值都与原数据报的标识值相同，则在接收端具有相同标识值的分片就能最终正确的重装成为原来的数据报。</p></li><li><p>标志（3 位）</p><p><img src="/images/image-20210811215702678.png" alt="image-20210811215702678"></p><p>MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。</p><p>只有当 DF=0 时才允许分片。</p></li><li><p>片偏移（13 位）</p><p>用于指明分段起始点相对于报头起始点的偏移量，即当前接收的分片需要从从包头处向后移动的数量。可以使接收者按照正确的顺序重组数据包。片偏移以 8 个字节为单位。（计算过程见后 15 点）</p></li><li><p>生存时间（8 位）</p><p><strong>TTL（Time To Live）数据报在网络中可通过的路由器数的最大值</strong>。用于防止数据包在网络上无休止地被传输；长度 8 位，最大值 255，每经过一台路由器 TTL 被减 1。</p></li><li><p>协议（8 位）</p><p>字段指出此数据报携带的数据使用何种协议。</p><p><img src="/images/image-20210811215905498.png" alt="image-20210811215905498"></p></li><li><p>首部检验和（16 位）</p><p>针对 IP 报头的纠错字段。</p></li><li><p>源地址（32 位）</p><p>发送方的 IP 地址。</p></li><li><p>目的地址（32 位）</p><p>接收方的 IP 地址。</p><p>IP 地址在传输过程中不变。</p></li><li><p>可变部分</p><p>被添加在 IP 报头中，包括源点产生的信息和其它路由器加入的信息；可选字段，主要用于测试，长度可变、支持排错、测量以及安全等措施等。</p></li><li><p>填充</p><p>通过在可选字段后面添加 0 来补足 32 位，为了确保报头长度是 32 的倍数。</p></li><li><p>片偏移的计算</p><p>例题：数据报的总长度为 2450 字节，使用固定首部，需要分片为长度不超过 1000字节的数据报片。</p><p>数据总长度是 2450 字节，去掉 20 字节的首部，则剩余 2430 字节的数据部分，现在分片的长度不超过 1000 字节，所以可以把数据分为 3 部分。3 部分数据的长度分别为 1000、1000、430 字节，在每个分片前加上 20 字节的首部。</p><p><img src="/images/image-20210811220136153.png" alt="image-20210811220136153"></p></li></ol><h3 id="4-2-5-IPv6"><a href="#4-2-5-IPv6" class="headerlink" title="4.2.5 IPv6"></a>4.2.5 IPv6</h3><ol><li><p>IPV6 概念</p><p>IPv6 是 Internet Protocol Version 6 的缩写，是下一代 IP 地址，用于替代现行版本IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。</p></li><li><p>IPv6 的主要特点</p><p>IPv6 将地址 32 位（IPV4）增大到了 128 位二进制，使得地址数量变为原来的 2<sup>96</sup> 倍，地址数量更多，适应未来网络扩展的需求。</p><p>IPV6 简化了报文头，包头有 8 个字节，加快报文转发，提高了吞吐量。</p><p>IPV6 中路由器可以简化过滤选项，加快了报文处理速度。</p><p>IPV6 增加了身份认证和隐私权的特征，提高安全性。</p><p>IPV6 支持更多的服务类型。</p><p>IPV6 增加协议继续演变，使之适应未来技术的发展；</p></li><li><p>IPv6 表示方法</p><p>1）冒分十六进制表示法</p><p>格式为 X:X:X:X:X:X:X:X，其中每个 X 表示地址中的 16b，以十六进制表示，例如：fec0：0000：0000：0000：0000：ffff：1abd：0001</p><p>这种表示法中，连续的 0000 是可以简写为 0，例如：</p><p>fec0：0：0：0：0：ffff：1abd：1</p><p>2）0 位压缩表示法</p><p>可以把连续的一段 0 压缩为“：：”。但地址中”：：”只能出现一次，例如：fec0：0：0：0：ffff：0：0：1 可以写成  fec0：：ffff：0：0：1 或 fec0：0：0：0：ffff：：1</p><p>3）兼容 IPv4 地址表示法</p><p>0:0:0:0:0:0:128.10.2.1 再使用零压缩即可得出：::128.10.2.1</p></li><li><p>IPV6 的地址格式</p><p><img src="/images/image-20210811222327129.png" alt="image-20210811222327129"></p><p>版本号（4 位）：主要区别 IPv4，其二进制值为（0110）。</p><p>流量等级（8 位）：主要用于 QoS。</p><p>流标签（20 位）：用来标识同一个流里面的报文。</p><p>载荷长度（16 位）： IPv6 包头部后包含的字节数，包含扩展头部。</p><p>下一报头（8 位）：该字段用来指明报头后接的报文头部的类型，若存在扩展头，表示第一个扩展头的类型。</p><p>跳数限制（8 位）：TTL 生存时间（参照路由协议）。</p><p>源地址（128 位）：发送端地址。</p><p>目的地址（128 位）：接收端地址。</p></li><li><p>IPv6 地址类型</p><p>单播：单播就是传统的点对点通信。</p><p>多播：多播是一点对多点的通信。</p><p>任播：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。</p></li></ol><h2 id="4-3-路由器"><a href="#4-3-路由器" class="headerlink" title="4.3 路由器"></a>4.3 路由器</h2><h3 id="4-3-1-路由器的概念"><a href="#4-3-1-路由器的概念" class="headerlink" title="4.3.1 路由器的概念"></a>4.3.1 路由器的概念</h3><p>路由器（Router）是通信子网的核心设备，是连接因特网中各局域网、广域网的设备，根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</p><h3 id="4-3-2-路由器的功能"><a href="#4-3-2-路由器的功能" class="headerlink" title="4.3.2 路由器的功能"></a>4.3.2 路由器的功能</h3><ol><li><p>网络连接</p><p>路由器支持各种局域网和广域网连接，广域网和广域网连接，实现不同网络互相通信，完成异构网络的互联功能。</p></li><li><p>路由寻址</p><p>路由器根据路由表的对应信息，可以直接把数据报文转发到下一个路由器，数据包经过国多次由转发后，就可以到达目的地。</p></li><li><p>数据转发</p><p>路由器对进出路由内部的数据报文信息进行过滤，提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能。</p></li><li><p>网络管理</p><p>网络管理主要是对网络进行子网划分、拨号加密等功能。路由器还提供包括路由器配置管理、性能管理、容错管理和流量控制等功能。</p></li><li><p>隔绝广播域</p><p>使得 IP 的广播报文限制在一个网段（或子网）中进行广播，这样的广播信号不会传输到其他的网络中，造成网络的拥塞和资源的浪费，能更好的保证网络的安全性。</p></li></ol><h3 id="4-3-3-路由协议"><a href="#4-3-3-路由协议" class="headerlink" title="4.3.3 路由协议"></a>4.3.3 路由协议</h3><ol><li><p>路由设置</p><p>1）静态路由</p><p>以手工方式将路由添加到每台路由器的路由表中的方式就是静态路由。</p><p>添加默认路由的命令是：</p><p>IP route 192.168.1.1   255.255.255.0    10.65.1.2</p><ol><li><p>优点</p><p>对于路由器的 CPU 没有管理性开销。</p><p>在路由器之间没有带宽占用，意味着在 WAN 链接中可以节省花费。</p><p>增加了安全性，因为管理员可以有选择地允许路由只访问特定的网络。</p></li><li><p>缺点</p><p>管理员必须真正了解所配置的互联网络，正确配置这些路由。网络发生变化的时候需要修改路由表，工作量大。对于大型网络来说，静态路由会导致巨大的工作量，不可行。</p></li></ol><p>2）动态路由</p><p>使用协议来查找网络并更新路由表的配置就是动态路由。这比使用静态或默认路由容易，但它需要一定的路由器 CPU 处理时间和网络链接带宽。路由协议定义了路由器与相邻路由器通信时所使用的一组规则。</p><p>其特点是能较好地适应网络状态的变化，管理员不需要对每一条路由信息进行设置，路由器可以通过自动学习功能，确定好路由表。</p></li><li><p>路由选择协议算法</p><p>1）距离矢量</p><p>距离矢量协议通过判断距离查找到达远程网络的最佳路径。<strong>数据包每通过一台路由器，称为一跳</strong>。使用最少跳数量到达网络的路由被认为是最佳路由。RIP 和 IGRP 都是距离矢量路由选择协议。</p><p>2）链路状态</p><p><strong>链路状态协议也称为最短路径优先协议</strong>。使用它的路由器分别创建 3 个独立的表。其中一个表用来跟踪直接相连接的邻居，一个用来判定整个互联网络的拓扑，而另一个用于路由选择表。链路状态路由器要比任何使用距离矢量路由选择协议的路由器知道更多关于互联网络的情况。OSPF 完全是一个链路状态的 IP 路由选择协议。</p></li><li><p>常见路由协议</p><p>1）内部网关协议 RIP</p><ol><li><p>RIP 协议</p><p>RIP（Routing information Protocol，路由信息协议）是应用较早、使用较普遍的内部网关协议（Interior Gateway Protocol，IGP），适用于小型同类网络的一个自治系统（AS）内的路由信息的传递。、</p><p>RIP 是一种分布式的基于距离向量的路由选择协议。</p><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</p><p>RIP 允许一条路径最多只能包含 15 个路由器。“距离”的最大值为 16 时即相当于不可达。</p><p>RIP 好消息传播得快，而坏消息传播得慢。</p></li><li><p>RIP 路由信息</p><p><img src="/images/image-20210812121018720.png" alt="image-20210812121018720"></p><p><img src="/images/image-20210812121100721.png" alt="image-20210812121100721"></p><p><img src="/images/image-20210812121157353.png" alt="image-20210812121157353"></p><p><img src="/images/image-20210812121222881.png" alt="image-20210812121222881"></p><p><img src="/images/image-20210812121248003.png" alt="image-20210812121248003"></p><p>距离为 0 说明是直连交付，距离为 1 说明需要中间要再经过 1 个路由器。如果距离为 16，说明不可达。</p><p>例题：假定网络中的路由器 A 的路由表有如下的项目</p><p><img src="/images/image-20210812121350664.png" alt="image-20210812121350664"></p><p><img src="/images/image-20210812121413682.png" alt="image-20210812121413682"></p></li></ol><p>2）OSPF 路由协议</p><p><strong>OSPF（Open Shortest Path First，ospf）开放最短路径优先协议</strong>，是由 Internet 工程任务组开发的路由选择协议，公用协议，任何厂家的设备。</p><p>OSPF 的“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF</p><p>OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p>OSPF 是分布式的链路状态协议。</p><p>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。</p><p>3）BGP 路由协议.</p><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。</p><p>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。</p><p>BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓扑图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。</p><p>BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。</p></li></ol><h2 id="4-4-广域网技术"><a href="#4-4-广域网技术" class="headerlink" title="4.4 广域网技术"></a>4.4 广域网技术</h2><h3 id="4-4-1-广域网概念"><a href="#4-4-1-广域网概念" class="headerlink" title="4.4.1 广域网概念"></a>4.4.1 广域网概念</h3><p>Wide Area Netwok，也称远程网。通常是指跨越很大地理范围的网络。一般从几十公里到几千公里。它能连接多个城市或国家，甚至横跨几大洲，并提供远距离通信。</p><p>由相距较远的局域网或城域网互连而成，通常是除了计算机设备以外，还要涉及一些电信通讯方式。</p><p>与局域网区别之一在于需要向外界的广域网服务供应商申请广域网服务。</p><p>广域网技术主要体现在 OSI 参考模型的下 3 层。</p><h3 id="4-4-2-广域网设备"><a href="#4-4-2-广域网设备" class="headerlink" title="4.4.2 广域网设备"></a>4.4.2 广域网设备</h3><p>路由器（router）：提供诸如局域网互连、广域网接口等多种服务。</p><p>交换机（switch）：连接到广域网上，进行语音、数据及视频通信。</p><p>调制解调器（modem）：提供话音服务的接口，信道服务单元是 T1/E2 服务的接口，终端适配器是综合业务数字网的接口。</p><p>通讯服务器（communication server）：汇集用户拨入和拨出的连接。</p><h3 id="4-4-3-广域网技术"><a href="#4-4-3-广域网技术" class="headerlink" title="4.4.3 广域网技术"></a>4.4.3 广域网技术</h3><ol><li><p>专线技术</p><p>1）DDN 概述</p><p>DIGITAL DATA NETWORK 数字数据网。DDN 专线接入向用户提供的是永久性的数字连接，既可用于计算机之间的通信，也可用于传送数字化传真，数字话音，数字图像信号或其它数字化信号。</p><p>2）优点</p><p>线路是为某公司独立建立。</p><p>传输质量高，流量独立、私有线路、安全性高。</p><p>传输速率高，网络延时小，带宽固定、流量固定。</p><p>数据信息传输透明度高，可支持任何规程，可传输语音、数据、传真、图象等多种业务。</p></li><li><p>公用电话网 PSTN</p><p>PSTN（Public Switched Telephone Network）公共交换电话网，主要是为电话通信而建立的网络，覆盖范围大，网络价格低廉。</p><p>电话网包括本地电话网、长途电话网、国际电话网等多种类型。是业务量最大、服务面最广的电信网。</p></li><li><p>公用分组交换数据网</p><p>PSDN（Packet Switched Data Network）分组交换数据网是一种以分组（Packet）为基本数据单元进行数据交换的通信网络。</p><p>是比较早的网路交换方式，分组交换数据网使用 X.25 协议标准，故通常也称它为X.25 网。</p><p>X.25 建议标准分为三个协议层，即物理层、链路层和分组层。</p><p>随着更完美的数字电话服务和差错更正功能的调制解调器的快速发展，再来讨论X.25 不再有什么实际意义了。结果就是帧中继的出现，帧中继就是带有差错自动修正功能的 X.25。现虚电路的概念仍然在异步传输模式中使用来进行拥塞控制和网络服务。</p></li><li><p>综合业务数字网 ISDN</p><p>1）ISDN</p><p>综合业务数字网（ISDN），俗称“一线通”。它除了可以用来打电话，还可以提供诸如可视电话、数据通信、会议电视等多种业务，从而将电话、传真、数据、图像等多种业务综合在一个统一的数字网络中进行传输和处理，这也就是“综合业务数字网”名字的来历。</p><p>2）优点分析</p><p>综合的通信业务：可以在上网的同时拨打电话、收发传真。</p><p>传输质量高：由于采用端到端的数字传输通信质量高。</p><p>使用灵活方便：只需一个入网接口，可以完成不同的通信。</p><p>3）缺点</p><p>速度相对于 ADSL 和 LAN 等接入方式来说，速度不够快。</p><p>在进行通信时，需要长时间的拨号保持连接，费用会很高。</p></li><li><p>帧中继 FR</p><p>1）FR</p><p>帧中继（Frame Relay）是从综合业务数字网中发展起来的，是一种用于连接计算</p><p>机系统的面向分组的通信方法。它主要用在公共或专用网上的局域网互联以及广域网</p><p>连接</p><p>2）特点</p><p>仅提供面向连接的虚电路服务。</p><p>局域网通过广域网互联时，体现出低网络时延、低设备费用、高带宽利用率等优点。</p><p>使用光纤作为传输介质，通信效率高。</p><p>因为采用了基于变长帧的异步多路复用技术，帧中继主要用于数据传输，而不适合语音、视频或其他对时延时间敏感的信息传输。</p><p>传输中，只检错不纠错。</p><p>帧长度可变，允许最大帧长度在 1600B 以上。</p><p>没有滑动窗口式的流控，只有拥塞控制。</p></li><li><p>ATM 技术</p><p>1）ATM</p><p>异步传输模式（ATM Asynchronous Transfer Mode），就是建立在电路交换和分组交换的基础上的一种新的交换技术。<strong>ATM 的信元的长度为 53 个字节</strong>。</p><p>ATM 是以信元为基础的一种分组交换和复用技术，数据分组大小固定。</p><p>它是一种为了多种业务设计的通用的面向连接的传输模式。</p><p>它适用于局域网和广域网，它具有高速数据传输率和支持许多种类型如声音、数据、传真、实时视频、CD 质量音频和图像的通信。</p><p>ATM 是在 LAN 或 WAN 上传送声音、视频图像和数据的宽带技术。</p><p>2）ATM 特点</p><p>其特征：基于信元的分组交换技术；快速交换技术；面向连接的信元交换；预约带宽。</p><p>其优点：吸取电路交换实时性好，分组交换灵活性强的优点；采取定长分组（信元）作为传输和交换的单位；具有优秀的服务质量；目前最高的速度为 10GB/S，即将达到 40GB/S.</p><p>其缺点：信元首部开销太大；技术复杂且价格昂贵。</p></li></ol><h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h1><h2 id="5-1-传输层基本概述"><a href="#5-1-传输层基本概述" class="headerlink" title="5.1 传输层基本概述"></a>5.1 传输层基本概述</h2><h3 id="5-1-1-传输层功能"><a href="#5-1-1-传输层功能" class="headerlink" title="5.1.1 传输层功能"></a>5.1.1 传输层功能</h3><p>分割与重组数据</p><p>按端口号寻址</p><p>传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错。</p><p>传输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。</p><p>传输层还要对收到的报文进行差错检测、差错控制、流量控制，纠错的功能。 </p><p>传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。 </p><h3 id="5-1-2-传输层服务"><a href="#5-1-2-传输层服务" class="headerlink" title="5.1.2 传输层服务"></a>5.1.2 传输层服务</h3><ol><li><p>面向连接服务</p><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接（连接导向）的、可靠的、基于 IP 的传输层协议。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p></li><li><p>无连接服务</p><p>UDP（User Datagram Protocol）用户数据报协议是定义用来在互连网络环境中提供包交换的计算机通信的协议，此协议默认认为网路协议（IP）是其下层协议。UDP 是 TCP 的另外一种方法，像 TCP 一样，UDP 使用 IP 协议来获得数据单元（叫做数据报），不像 TCP 的是，它不提供包（数据报）的分组和组装服务。</p><p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</p></li></ol><h3 id="5-1-3-协议端口"><a href="#5-1-3-协议端口" class="headerlink" title="5.1.3 协议端口"></a>5.1.3 协议端口</h3><ol><li><p>端口定义</p><p>计算机”端口”是英文 port 的意译，可以认为是计算机与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的 80 端口、21 端口、23 端口等。物理端口又称为接口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11插口也属于物理端口的范畴。</p><p>端口是运行在计算机中的进程是用进程标识符来标志的。</p></li><li><p>端口号</p><p>熟知端口：数值一般为 0~1023。</p><p>登记端口号：数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</p><p>客户端口号或短暂端口号：数值为 49152~65535，留给客户进程选择暂时使用。</p><p>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</p></li><li><p>常见端口</p><p><img src="/images/image-20210812130649958.png" alt="image-20210812130649958"></p><p><img src="/images/image-20210812130714527.png" alt="image-20210812130714527"></p></li></ol><h2 id="5-2-TCP-协议"><a href="#5-2-TCP-协议" class="headerlink" title="5.2 TCP 协议"></a>5.2 TCP 协议</h2><h3 id="5-2-1-面向字节"><a href="#5-2-1-面向字节" class="headerlink" title="5.2.1 面向字节"></a>5.2.1 面向字节</h3><p>TCP 中的“流”（stream）指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但TCP 把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p><p>TCP 并不知道所传送的字节流的含义。</p><p>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付给了上层的应用程序）。</p><p><img src="/images/image-20210812131417138.png" alt="image-20210812131417138"></p><p>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。TCP 根据对方给出的窗口值和当前网络拥睦的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</p><p>如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分短一些再传送。如果应用进程一次只发来一个字节。TCP 也可以等待积累自足够多的字节后再构成报文段发送出区。</p><h3 id="5-2-2-TCP-传输特点"><a href="#5-2-2-TCP-传输特点" class="headerlink" title="5.2.2 TCP 传输特点"></a>5.2.2 TCP 传输特点</h3><p>TCP 提供可靠交付的服务，TCP 连接是一条虚连接而不是一条真正的物理连接。</p><p>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）。</p><p>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</p><p>TCP 是面向连接的传输层协议。</p><p>每一条 TCP 连接只能有两个端点（endpoint），每一条 TCP 连接只能是点对点的（一对一）。</p><p>TCP 提供全双工通信。</p><p>面向字节流。</p><h3 id="5-2-3-TCP-报文格式"><a href="#5-2-3-TCP-报文格式" class="headerlink" title="5.2.3 TCP 报文格式"></a>5.2.3 TCP 报文格式</h3><p>TCP 报文包括两部分：首部和数据两部分。</p><p>TCP 报文的首部的前 20 个字节是固定的，后面有 4N 字节根据需要而增加的选项（N 是整数）。所以 TCP 首部的最小长度是 20 字节。 </p><p><img src="/images/image-20210812131828132.png" alt="image-20210812131828132"></p><ol><li>源端口和目的端口：各为 16 比特，用于表示应用层的连接。源端口表示产生数据包的应用层进程，而目的端口则表示数据包所要到达的目的进程。</li><li>序列号：为 32 比特，表示数据流中的字节数。序列号为首字节在整个数据流中编号的位置。初始序列号随机产生，并在连接建立阶段予以同步。序号的范围是[0， 2^32-1]共有 2^32（4284 967 296）个序号，序号到 2^32-1 后从 0 开始。<ul><li>TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>例如，一报文段的序号字段值是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。这个字段的名称也叫做“报文段序号”。</li></ul></li><li>确认号：表示序号为确认号减去 1 的数据包及其以前的所有数据包已经正确接收，也就是说它相当于下一个准备接收的字节的序号。</li><li>数据偏移：4 比特，用于指示数据起始位置。由于 TCP 包头中可选项的长度可变，因此整个包头的长度不固定。如果没有附加字段，则 TCP 数据包基本长度为 20字节。</li><li>中间的标志位就是用于协议的一些机制的实现的比特位可以看到有 6 比特，它们依次如下：URG、ACK、PSH、RST、SYN、FIN。<ul><li>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li><li>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。若确认号=N，则表明序号 N-1 为止的所有数据已经正确收到。</li><li>PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li><li>RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li><li>SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。</li><li>FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul></li><li>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。</li><li>校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP数据，以 16 位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。</li><li>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</li><li>选项：最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size） 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。</li><li>数据： TCP 报文段中的数据部分是可选的。</li></ol><h2 id="5-3-UDP-协议"><a href="#5-3-UDP-协议" class="headerlink" title="5.3 UDP 协议"></a>5.3 UDP 协议</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p><h3 id="5-3-2-UDP-面向报文"><a href="#5-3-2-UDP-面向报文" class="headerlink" title="5.3.2 UDP 面向报文"></a>5.3.2 UDP 面向报文</h3><p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p><p>应用程序必须选择合适大小的报文。</p><p><img src="/images/image-20210812132534897.png" alt="image-20210812132534897"></p><h3 id="5-3-3-UDP-优点"><a href="#5-3-3-UDP-优点" class="headerlink" title="5.3.3 UDP 优点"></a>5.3.3 UDP 优点</h3><p>UDP 是无连接的，即发送数据之前不需要建立连接。</p><p>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</p><p>UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</p><p>UDP 支持一对一、一对多、多对一和多对多的交互通信。</p><p>UDP 的首部开销小，只有 8 个字节。</p><h3 id="5-3-4-UDP-格式"><a href="#5-3-4-UDP-格式" class="headerlink" title="5.3.4 UDP 格式"></a>5.3.4 UDP 格式</h3><p>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p><ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全 O。</li><li>目的端口：目的端口号。这在终点交付报文时必须要使用到。</li><li>长度：UDP 用户数据报的长度，其最小值是 8（仅有首部）。</li><li>检验和：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li><li>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</li></ul><p><img src="/images/image-20210812133004037.png" alt="image-20210812133004037"></p><h3 id="5-3-5-UDP-的校验"><a href="#5-3-5-UDP-的校验" class="headerlink" title="5.3.5 UDP 的校验"></a>5.3.5 UDP 的校验</h3><p>UDP 计算检验和和 IP 数据报首部检验不同的是：IP 数据报的检验和只检验 lP 数据报的首部，但 UDP 的检验和是把首部和数据部分一起都检验。</p><p>首先是先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来。若 UDP 用户数据报的数据部分不是偶数个字节，要填写若干个全零字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和。当无差错时其结果应为全 1，否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报（也可以上交给应用层，但附上出现了差错的警告）。</p><p>这里假定用户数据报的长度是 15 字节，因此要添加一个全 0 的字节。不难看出，这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。</p><p><img src="/images/image-20210812133141360.png" alt="image-20210812133141360"></p><p><img src="/images/image-20210812133216395.png" alt="image-20210812133216395"></p><p>伪首部的第 3 字段是全零，第 4 个字段是 lP 首部中的协议字段的值。以前已讲过，对于 UDP，此协议字段值为 17。第 5 字段是 UDP 用户数据报的长度。因此，这样的检验和，既检验 UDP 用户数据报的源端口号和目的端口号以及 UDP 用户数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。</p><h3 id="5-3-6-端口校验"><a href="#5-3-6-端口校验" class="headerlink" title="5.3.6 端口校验"></a>5.3.6 端口校验</h3><p>如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程）。就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给发送方。</p><p><img src="/images/image-20210812133345863.png" alt="image-20210812133345863"></p><h2 id="5-4-传输层技术"><a href="#5-4-传输层技术" class="headerlink" title="5.4 传输层技术"></a>5.4 传输层技术</h2><p>TCP 发送的报文段是交给 lP 层传送的。但 IP 层只能提供尽最大努力服务，也就是说，TCP 下面的网络所提供的是不可靠的传输。因此，TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p><h3 id="5-4-1-停止等待"><a href="#5-4-1-停止等待" class="headerlink" title="5.4.1 停止等待"></a>5.4.1 停止等待</h3><p>每发送一个数据分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。</p><ol><li><p>无差错情况</p><p>A 发送分组 M1，发完就暂停传送，等待 B 的确认。B 收到了 M1 就向 A 发送确认。A 在收到了对 M1 的确认后，就再发送下一个分组 M2。</p></li><li><p>出现差错</p><p>B 接收 M1 时检测出了差错，就丢弃 M1，不通知 A 收到有差错的分组。</p><p>M1 在传输过程中丢失了，这时 B 当然什么都不知道。在这两种情况下，B 都不会发送任何信息。</p><p>A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做超时重传。</p><p><img src="/images/image-20210812133905371.png" alt="image-20210812133905371"></p></li><li><p>注意</p><p>在发送完一个分组后，必须暂时保留已发送的分组的副本。</p><p>分组和确认分组都必须进行编号。</p><p>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</p><p>可靠传输协议常称为<strong>自动重传请求 ARQ （Automatic Repeat Request）</strong>。</p><p><img src="/images/image-20210812133935456.png" alt="image-20210812133935456"></p></li><li><p>流水技术</p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。</p><p><img src="/images/image-20210812134128013.png" alt="image-20210812134128013"></p></li></ol><h3 id="5-4-2-连续-ARQ-协议"><a href="#5-4-2-连续-ARQ-协议" class="headerlink" title="5.4.2 连续 ARQ 协议"></a>5.4.2 连续 ARQ 协议</h3><p>发送方维持的发送窗口，它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p><p>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。</p><p><img src="/images/image-20210812134331736.png" alt="image-20210812134331736"></p><h3 id="5-4-3-滑动窗口"><a href="#5-4-3-滑动窗口" class="headerlink" title="5.4.3 滑动窗口"></a>5.4.3 滑动窗口</h3><ol><li><p>基本概念</p><p>TCP 采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节。</p><p>在 TCP 报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。</p><p>发送窗口在连接建立时由双方商定。但在通信的过程中，接收端根据自己的资源情况，随时动态地调整对方的发送窗口上限值（可增大或减小）。</p><p>根据 B 给出的窗口值 A 构造出自己的发送窗口</p><p>TCP 标准强烈不赞成发送窗口前沿向后收缩</p><p><img src="/images/image-20210812134549675.png" alt="image-20210812134549675"></p><p>发送方 A 的发送窗口。发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</p><p>发送窗口里面的序号表示允许发送的序号。窗口越大，投送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但接收方必须来得及处理这些收到的数据。</p><p>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间问。</p><p>发送窗口的位置由窗口前沿和后沿的位置共同确定。不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。</p><p>这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小不变：二是收到了的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。</p></li><li><p>滑动窗口工作过程</p><p>现在假定 A 发送了序号为 31 一 41 的数据。这时，发送窗口位置并未改变，但发送窗口内靠后面有 11 个字节（灰色小方框表示）表示已发送但未收到确认。而发送窗口内靠前面的 9 个字节（42~ 50）是允许发送但尚未发送的。</p><p><img src="/images/image-20210812134815584.png" alt="image-20210812134815584"></p><p>小于 P1 的是已发送并已收到确认的部分，而大于 n 的是不允许发送的部分。</p><p>P3 - Pl =A 的发送窗口（又称为通知窗口）</p><p>P2– P1：已发送但尚未收到确认的字节数</p><p>P3 - P2=允许发送但尚未发送的字节数（又称为可用窗口或有效窗口）</p><p><img src="/images/image-20210812134935140.png" alt="image-20210812134935140"></p><p>B 的接收窗口。B 的接收窗口大小是 20，在接收窗口外而，到 30 号为止的数据是已经发送过确认，并且已经交付给主机了。因此在 B 可以不再保留这些数据。接收窗口内的序号（31-50）是允许接收的。B 收到了序号为 32 和 33 的数据。这些数据没有按序到达，因为序号为 31 的数据没有收到。请注意，B 只能对按序收到的数据中的最高序号给出确认，因此 B 发送的确认报文段中的确认号仍然是 31（即期望收到的序号），而不能是 32 或 33。</p><p>现在假定 B 收到了序号为 31 的数据，并把序号为 31~ 33 的数据交付给主机，然后 B 删除这些数据。接着把接收窗口向前移动 3 个序号，同时给 A 发送确认，其中窗口值仍为 20，但确认号是 34。这表明 B 已经收到了到序号 33 为止的数据。我们注意到，B 还收到了序号为 37，38 和 40 的数据，但这些都没有按序到达，只能先暂存在接收窗口中。</p><p><img src="/images/image-20210812135054762.png" alt="image-20210812135054762"></p><p>A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送。</p><p><img src="/images/image-20210812135129752.png" alt="image-20210812135129752"></p></li></ol><h3 id="5-4-4-选择确认机制-SACK"><a href="#5-4-4-选择确认机制-SACK" class="headerlink" title="5.4.4 选择确认机制 SACK"></a>5.4.4 选择确认机制 SACK</h3><p>接收方收到了和前面的字节流不连续的两个字节块。</p><p>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p><p><img src="/images/image-20210812135229548.png" alt="image-20210812135229548"></p><p>和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。图中用四个指针标记这些边界。</p><p>第一个字节块的左边界 L1 = 1501，但右边界 R1 = 3001。</p><p>左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。序号1——1000收到了，但序号1001—1500没有收到。接下来的字节流又收到了，可是又缺少了 3001——3500。再后面从序号 4501 起又没有收到。也就是说，接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p><h3 id="5-4-5-流量控制"><a href="#5-4-5-流量控制" class="headerlink" title="5.4.5 流量控制"></a>5.4.5 流量控制</h3><p>让发送方发送的数据速度不要太快，让接收方能接收这些数据。</p><p>流量控制（flow control）就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</p><p>滑动窗口协议控制数据流量</p><p>A 向 B 发送数据。在连接建立时，B 告诉 A：“我的接收窗口 rwnd = 400（字节）”（rwnd 表示receive windows）。</p><p>发送方的发送窗口不能超过接收方的接收窗口的数值。TCP 的窗口单位是字节，不是报文段。</p><p>数据报文段的初始值为 1，即 seq=1.ACK 表示首部中确认位是 ACK，ack 表示字段值。</p><p><img src="/images/image-20210812135527503.png" alt="image-20210812135527503"></p><p>接收方的主机 B 进行了 3 次流量控制。第一次把窗口缩小到 rwnd=300，第二次叉减到 rwnd= 100，最后减到 rwnd=0，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机 B 重新发出一个新的窗口值为止。我们还应注意到，B 向 A 发送的三个报文段都设置了 ACK=1，只有在 ACK =1 时确认号字段才有意义。</p><h3 id="5-4-6-拥塞控制"><a href="#5-4-6-拥塞控制" class="headerlink" title="5.4.6 拥塞控制"></a>5.4.6 拥塞控制</h3><ol><li><p>拥塞定义</p><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞（congestion）。</p><p>出现资源拥塞的条件：对资源需求的总和&gt;可用资源</p><p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p></li><li><p>慢开始和拥塞避免 (这里的内容没有放上来，需要深入时在学习)</p><p>发送方维持一个叫做拥塞窗口 cwnd （congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p>发送端的主机在确定发送报文段的速率时，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞。</p><p>接收端窗口 rwnd 这是接收端根据其目前的接收缓存大小所许诺的最新的窗口值，是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</p><p>拥塞窗口 cwnd （congestion window）发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。</p></li></ol><h3 id="5-4-7-TCP-的传输控制—三次握手协议"><a href="#5-4-7-TCP-的传输控制—三次握手协议" class="headerlink" title="5.4.7 TCP 的传输控制—三次握手协议"></a>5.4.7 TCP 的传输控制—三次握手协议</h3><p>运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p><p>连接建立过程中要解决以下三个问题：</p><p>要使每一方能够确知对方的存在。</p><p>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</p><p>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。</p><p>使用三次握手协议建立连接：</p><p><img src="/images/image-20210812140405752.png" alt="image-20210812140405752"></p><p>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号seq = x，表明传送数据时的第一个数据字节的序号是 x。</p><p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x +1，自己选择的序号 seq = y。</p><p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y +1。A 的 TCP 通知上层应用进程，连接已经建立。</p><p>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</p><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h3 id="6-1-服务方式"><a href="#6-1-服务方式" class="headerlink" title="6.1 服务方式"></a>6.1 服务方式</h3><ol><li><p>C/S 模式</p><p>客户服务器模式（Client–server model）简称 C/S 结构，是一种网络架构，它把客户端 （Client）与服务器（Server）区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。</p><p>服务器：是网络上一种为客户机提供各种服务的高性能的计算机，它能够提供网络管理、运行应用程序、处理各网络工作站成员的信息请示等服务。</p><p>工作站：享受服务器所提供的服务的那些计算机，我们称之为工作站。</p><p>客户（client）和服务器（server）都是指通信中所涉及的两个应用进程。</p><p>客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户是服务的请求方，服务器是服务的提供方。</p></li><li><p>B/S 模式</p><p>B/S 结构（Browser/Server，浏览器/服务器模式），是 WEB 兴起后的一种网络结构模式，WEB 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Netscape Navigator 或 Internet Explorer，服务器安装 SQL Server、Oracle、MYSQL 等数据库。浏览器通过 Web Server 同数据库进行数据交互。</p></li><li><p>C/S 与 B/S 比较</p><p><img src="/images/image-20210812144558014.png" alt="image-20210812144558014"></p></li><li><p>P2P 模式</p><p>对等网络又称工作组，网上各台计算机有相同的功能，无主从之分，一台计算机都是既可作为服务器，设定共享资源，供网络中其他计算机所使用，又可以作为工作站，没有专用的服务器，也没有专用的工作站。对等网络是小型局域网常用的组网方式。</p><p>对等计算（Peer to Peer，简称 p2p）可以简单的定义成通过直接交换来共享计算机资源和服务，而对等计算模型应用层形成的网络通常称为对等网络。在 P2P 网络环境中，成千上万台彼此连接的计算机都处于对等的地位，整个网络一般来说不依赖专用的集中服务器。网络中的每一台计算机既能充当网络服务的请求者，又对其它计算机的请求作出响应，提供资源和服务。</p></li></ol><h2 id="6-2-DNS-域名解析服务"><a href="#6-2-DNS-域名解析服务" class="headerlink" title="6.2 DNS 域名解析服务"></a>6.2 DNS 域名解析服务</h2><ol><li><p>什么是域名</p><p>域名 Domin name:因为计算机的 IP 地址对于人来说不容易记忆，所以使用一组英文表示的名字，来表示每一台主机。</p><p>DNS 域名系统（Domain Name System）是因特网使用的命名系统，用来把域名转换为 IP 地址。</p></li><li><p>域名的组成</p><p>一般分 4 级，每级 1-4 个字符，中间用小数点间隔。</p><p>域名的结构由标号序列组成，各标号之间用点隔开：….三级域名.二级域名.顶级域名。</p><p><img src="/images/image-20210812144843898.png" alt="image-20210812144843898"></p><p>域名一般用小写，且需要申请、注册和付费。</p></li><li><p>常见计算机域名</p><p><img src="/images/image-20210812145006260.png" alt="image-20210812145006260"></p></li><li><p>internet 的域名空间</p><p>我国的互联网发展现状及各种规定（如申请域名的手续），均可在中国互联网信息中心 CNNIC 的网址上找到[W-CNNIC]。</p><p>域名树的树叶就是单台计算机的名字，不能再继续往下划分子域了。</p><p>应当注意，虽然中央电视台和清华大学都各有一台计算机取名为 mail，但它们的域名并不一样，因为前者是 mail.cctv.com，而后者是 mainl.tsinghua.edu.cn。因此，即使在世界上还有很多单位的计算机取名为 mail，但是它们在因特网中的域名却都必须是唯一的。</p><p>因特网的名字空间是按照机构的组织来划分的，与物理的网络无关，与 lP 地址中的“子网”也没有关系。</p><p><img src="/images/image-20210812145144524.png" alt="image-20210812145144524"></p></li><li><p>域名服务器</p><p>1）本地域名服务器</p><p><strong>本地域名服务器是距离本地主机最近的域名解析服务器</strong>，当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器</p><p>本地域名服务器有时也称为默认域名服务器。</p><p>2）根域名服务器</p><p>全球共有 13 台根逻辑域名服务器。这 13 台逻辑根域名服务器中名字分别为“A”至“M”。根域名服务器是最重要的域名服务器。</p><p>在根域名服务器中虽然没有每个域名的具体信息，但储存了负责每个域（如.com， .cn， .ren， .top 等）的解析的域名服务器的地址信息。</p><p>3）顶级域名服务器</p><p>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。</p><p>4）权限域名服务器</p><p>这就是前面已经讲过的负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p></li><li><p>域名查询</p><p>1）递归查询</p><p>进行递归查询时，DNS 客户机向 DNS 服务器发送请求，如果 DNS 服务器没有所请求的信息，则会联系其他 DNS 服务器来提供答案或返回查询失败信息。</p><p>主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><p><img src="/images/image-20210812145706445.png" alt="image-20210812145706445"></p><p>2）迭代查询</p><p>进行迭代查询时，DNS 允许 DNS 服务器根据自己的高速缓存提供最佳答案，如果不能答复，则一般会返回一个指针，指向有下级域名空间授权的 DNS 服务器，DNS客户机根据指针所指向的 DNS 服务器查询。</p><p>本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><img src="/images/image-20210812145943065.png" alt="image-20210812145943065"></p></li></ol><h2 id="6-3-WWW-万维网服务"><a href="#6-3-WWW-万维网服务" class="headerlink" title="6.3 WWW 万维网服务"></a>6.3 WWW 万维网服务</h2><ol><li><p>www 概述</p><p>万维网 WWW（World Wide Web）是一种交互式图形界面的 Internet 服务，具有强大的信息连接功能，是目前 Internet 中最受欢迎的、增长速度最快的一种多媒体信息服务系统。</p><p>WWW 以客户服务器方式工作。</p><p>浏览器就是在用户计算机上的 WWW 客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。</p></li><li><p>HTML 语言</p><p>1）基本概念</p><p>超文本标记语言 HTML （HyperText Markup Language）中的 Markup 的意思就是“设置标记”。</p><p>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。利用超链接的方式。</p><p>超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</p><p>仅当 HTML 文档是以.html 或 .htm 为后缀时，浏览器才对此文档的各种标签进行解释。</p><p>2）网页形态</p><p>静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。</p><p>动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。</p><p>动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。</p></li><li><p>URL 统一资源定位器</p><p>URL（Uniform Resource Locator，统一资源定位器）是 WWW 页的地址。每一个网址都有唯一的一个 URL。</p><p>使每一个文档在整个因特网的范围内具有唯一的标识符 URL。</p><p>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</p><p>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</p><p>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</p><p>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</p><p>格式：&lt;协议&gt;&lt;主机域名或 IP 地址&gt;&lt;路径&gt;&lt;文件名&gt; </p><p>例如：<a href="http://www.sina.com.cn/">http://www.sina.com.cn</a></p></li><li><p>HTTP 超文本传输协议</p><p>1）概述</p><p>超文本传输协议（HTTP，HyperText Transfer Protocol）是 WWW 文件都必须遵守这个标准。</p><p>HTTP 是一个客户端和服务器端请求和应答的标准（TCP）。</p><p>客户端是终端用户，服务器端是网站。</p><p>客户端发起一个到服务器上指定端口（默认端口为 80）的 HTTP 请求。</p><p>2）工作过程</p><p>HTTP 是面向事务的（transaction-oriented）应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</p><p><img src="/images/image-20210812150926366.png" alt="image-20210812150926366"></p><p>每个万维网网点都是一个服务器进程，不断的监听 TCP 的端口 80，以便发现是否有浏览器向它发送请求。</p><p>浏览器分析超链指向页面的 URL。</p><p>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a> 的 IP 地址。</p><p>域名系统 DNS 解析出清华大学服务器的 IP 地址。</p><p>浏览器与服务器建立 TCP 连接</p><p>浏览器发出取文件命令： GET /chn/yxsz/index.htm。</p><p>服务器给出响应，把文件 index.htm 发给浏览器。</p><p>TCP 连接释放。</p><p>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</p><p>HTTP 本身是无连接的，http 使用 TCP 连接，但是通信双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。</p></li></ol><h3 id="6-4-FTP-文件传输服务"><a href="#6-4-FTP-文件传输服务" class="headerlink" title="6.4 FTP 文件传输服务"></a>6.4 FTP 文件传输服务</h3><ol><li><p>概念</p><p>FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文件传输协议”。用于 Internet 上的控制文件的双向传输。</p><p>FTP 文件传输协议中，经常使用的名词为“下载”和“上传”。“下载”文件就是从远程主机拷贝文件至自己的计算机上；“上传”文件就是将文件从自己的计算机中拷贝至远程主机上。</p></li><li><p>端口</p><p>FTP 是客户机服务器模式。</p><p>启动 ftp：ftp：//[用户名：口令@]ftp 服务器域名：[端口号]。</p><p>TCP/IP 协议中，FTP 标准命令 TCP 端口号为 21，Port 方式数据端口为 20。FTP的任务是从一台计算机将文件传送到另一台计算机，不受操作系统的限制。</p></li><li><p>传输模式</p><p>FTP 支持两种模式：Standard （PORT 方式，主动方式），Passive（PASV，被动方式）。</p><p>1）Port 模式</p><p>FTP 客户端与服务器的 TCP 21 端口建立连接，用来发送命令，客户端需要接收数据的时候在这个通道上发送 PORT 命令。PORT 命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的 TCP 20 端口连接至客户端的指定端口发送数据。FTP server 必须和客户端建立一个新的连接用来传送数据。</p><p>2）Passive 模式</p><p>服务器收到 Pasv 命令后，打开一个临时端口（端口号大于 1023 小于 65535）并且通知客户端在这个端口上传送数据的请求，客户端连接 FTP 服务器此端口，然后FTP 服务器将通过这个端口传送数据。</p><p>很多防火墙在设置的时候都是不允许接收外部发起的连接的，所以许多位于防火墙后或内网的 FTP 服务器不支持 PASV 模式，因为客户端无法穿过防火墙打开 FTP 服务器的高端端口；而许多内网的客户端不能用 PORT 模式登陆 FTP 服务器，因为从服务器的 TCP 20 无法和内部网络的客户端建立一个新的连接，造成无法工作。</p><p><img src="/images/image-20210812151504335.png" alt="image-20210812151504335"></p></li><li><p>NFS</p><p>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。</p><p>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p></li><li><p>TFTP</p><p>1）简单文件传送协议 TFTP</p><p>TFTP 是一个很小且易于实现的文件传送协议。</p><p>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</p><p>TFTP 只支持文件传输而不支持交互。</p><p>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>2）TFTP 的优点</p><p>是基于 UDP 协议的，可以同时向多台计算机传输文件。</p><p>代码占用内存较小，比较适合小文件的阐述，对特殊的计算机或设备很重要。</p><p>3）TFTP 的主要特点</p><p>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</p><p>数据 PDU 也称为文件块（block），每个块按序编号，从 1 开始。发出文件后等待对方确认。</p><p>支持 ASCII 码或二进制传送。</p><p>可对文件进行读或写。</p><p>使用很简单的首部。</p></li></ol><h2 id="6-5-E-mail-电子邮件服务"><a href="#6-5-E-mail-电子邮件服务" class="headerlink" title="6.5 E-mail 电子邮件服务"></a>6.5 E-mail 电子邮件服务</h2><ol><li><p>电子邮件概述</p><p>电子邮件（E-mail，Electronic Mail）是指在 Internet 上或常规计算机网络上各个用户之间，通过电子信件的形式进行通信的一种现代邮政通信方式。</p></li><li><p>电子邮件的特点</p><p>发送速度快、信息多样化、收发方便、成本低廉和安全等。</p></li><li><p>相关协议</p><p>POP3（Post Office Protocol 3）即邮局协议的第 3 个版本，用来接收电子邮件的。</p><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议，发送电子邮件。</p><p>MIME 在其邮件首部中说明了邮件的数据类型（如文本、声音、图像、视像等），使用 MIME 可在邮件中同时传送多种类型的数据。</p><p><img src="/images/image-20210812151807501.png" alt="image-20210812151807501"></p><p>SMTP 协议与 POP3 协议，SMTP 包括连接建立，主要在在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。邮件传送过程以及连接释放，也就是邮件发送完毕后，SMTP 应释放 TCP 连接。</p><p>SMTP 有以下缺点：不能传送可执行文件或其他的二进制对象。限于传送 7 位的 ASCII 码。SMTP 服务器会拒绝超过一定长度的邮件。</p></li><li><p>地址格式</p><p>Internet 上 E-mail 地址的统一格式是：用户名@域名，“用户名”是用户申请的账号，“域名”是 ISP 的电子邮件服务器的域名，这两部分中间用“@”隔开，如：<a href="mailto:&#49;&#50;&#52;&#x34;&#x35;&#x36;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;">&#49;&#50;&#52;&#x34;&#x35;&#x36;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;</a>。</p></li></ol><h2 id="6-6-telnet-远程登录服务"><a href="#6-6-telnet-远程登录服务" class="headerlink" title="6.6 telnet 远程登录服务"></a>6.6 telnet 远程登录服务</h2><p>Telnet 是 Internet 的远程登录协议的意思，它让用户坐在自己的计算机前通过Internet 网络登录到另一台远程计算机上。</p><p>当登录上远程计算机后，用户的电脑就仿佛是远程计算机的一个终端，就可以用自己的计算机直接操纵远程计算机，享受远程计算机本地终端同样的权力。虚拟终端负责把用户输入的每个字符传递给主机，再将主机输出的每个信息回显在屏幕上。</p><h1 id="7-无线网络"><a href="#7-无线网络" class="headerlink" title="7. 无线网络"></a>7. 无线网络</h1><h2 id="7-1-无线局域网"><a href="#7-1-无线局域网" class="headerlink" title="7.1 无线局域网"></a>7.1 无线局域网</h2><h3 id="7-1-1-定义"><a href="#7-1-1-定义" class="headerlink" title="7.1.1 定义"></a>7.1.1 定义</h3><p>计算机操作系统是方便用户、管理和控制计算机软硬件资源的系统软件（或程序集合）。无线局域网 WLAN 提供了移动接入的功能，这就给许多需要发送数据但又不能坐在办公室的工作人员提供了方便。无线局域网，不仅节省了投资，而且建网的速度也会较快。</p><p>无线局域网常简写为 WLAN（Wireless Local Area Network）。</p><h3 id="7-1-2-组成"><a href="#7-1-2-组成" class="headerlink" title="7.1.2 组成"></a>7.1.2 组成</h3><p>无线局域网有两大类，第一类是有固定基础设施的，第二类是无固定基础设施的。“固定基础设施”是指预先建立起来的、能够覆盖一定范围的一批固定基站。</p><ol><li><p>IEEE802.11 协议</p><p>802.11 协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然 WI-FI 使用了 802.11 的媒体访问控制层（MAC）和物理层（PHY），但是两者并不完全一致。在以下标准中，使用最多的应该是 802.11n 标准，工作在 2.4GHz 频段，可达 600Mbps（理论值）。</p><p>802.11 采用 2.4GHz 和 5GHz 这两个 ISM 频段。</p><p>802.11 是一个相当复杂的标准，可以简单的说 802.11 是无线局域网标准。采用的是星型拓扑结构，其中心点叫做接入点 AP（Access popint），在 MAC 层使用 CSMA/CD协议。凡是使用 802.11 系类协议的局域网又称为 Wi-Fi（Wireless-Fidelity），意思是“无线保真度”。</p></li><li><p>802.11 通信标准</p><p>现在最流行的无线局域网是 802.11b，而另外两种（802.11a 和 802.11g）的产品也广泛存在。</p><p>802.11b 是一种 11Mbps（原文为 11M/s，已修改） 无线标准，可为笔记本电脑或桌面电脑用户提供完全的网络服务。</p><p>802.11a 的传输技术为多载波调制技术。它工作在 5GHzU-NII 频带，物理层速率可达54Mb/s，传输层可达 25Mbps。可提供 25Mbps 的无线 ATM 接口和 10Mbps 的以太网无线帧结构接口，以及 TDD/TDMA 的空中接口；支持语音、数据、图像业务；一个扇区可接入多个用户，每个用户可带多个用户终端。</p><p>IEEE802.11g 草案有以下两个特点：在 2.4GHz 频段使用正交频分复用（OFDM）调制技术，使数据传输速率提高到 20Mbit/s 以上；能够与 IEEE802.11b 的 Wi-Fi 系统互联互通，可共存于同一 AP 的网络里，从而保障了后向兼容性。</p><p><img src="/images/image-20210812153013703.png" alt="image-20210812153013703"></p></li><li><p>无线数据传输</p><p>802.11 标准规定无线局域网的最小构件是基本服务集 BSS（basic service set）。一个基本的服务集 BSS 包括一个基站和若干个移动站。AP 就是基本服务集内的基站（base station）。</p><p>安装 AP 时，必须为 AP 分配一个不超过 32 字节的服务器标识符 SSID（service set IDentifier）和一个信道。一个基本服务集 BSS 所覆盖的范围叫做一个基本服务区 BSA（basic service area）。无线局域网的基本服务区 BSA 的范围直径一般不超过 100m。</p><p><img src="/images/image-20210812153339480.png" alt="image-20210812153339480"></p><p>1）与接入点 AP 建立关联（association）</p><p>建立关联就表示这个移动站加入了选定的 AP 所属的子网，并和这个 AP 之间创建了一个虚拟线路。</p><p>只有关联的 AP 才向这个移动站发送数据帧，而这个移动站也只有通过关联的 AP 才能向其他站点发送数据帧。</p><p>2）移动站与 AP 建立关联的方法</p><p>被动扫描：即移动站等待接收接入站周期性发出的信标帧（beacon frame），（10次/秒或 100 次/秒）。信标帧中包含有若干系统参数（如服务集标识符 SSID 以及支持的速率等）。</p><p>主动扫描：即移动站主动发出探测请求帧（probe request frame），然后等待从 AP 发回的探测响应帧（probe response frame）。 </p><p>3）热点（hot spot）</p><p>现在许多地方，如办公室、机场、快餐店、旅馆、购物中心等都能够向公众提供有偿或无偿接入 Wi-Fi 的服务。这样的地点就叫做热点。</p><p>由许多热点和 AP 连接起来的区域叫做热区（hot zone）。热点也就是公众无线入网点。</p></li></ol><h3 id="7-1-2-无线局域网技术"><a href="#7-1-2-无线局域网技术" class="headerlink" title="7.1.2 无线局域网技术"></a>7.1.2 无线局域网技术</h3><ol><li><p>CSMA/CA 协议</p><p>无线局域网却不能简单地搬用 CSMA/CD 协议。这里主要有两个原因。</p><p>在无线局域网适配器上，接收信号的轻度往往会远小于发送信号的强度，因此若要实现碰撞检测，那么在硬件上花费会很大。CSMA/CD 协议要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但在无线局域网的设备中要实现这种功能就花费过大。</p><p>在无线局域网中，并非所有的站点都能听到对方，但“所有站点都能听到对方” 是CSMA/CD 的基础。即使我们能够实现碰撞检测的功能，并且当我们在发送数据时检测到信道是空闲的，在接收端仍然有可能发生碰撞。</p></li><li><p>隐蔽站问题</p><p>A 和 C 都想和 B 通信，但 A 与 C 的距离较远，彼此听不到对方，当 A 和 C 的检测信道空闲时，就都想 B 发送数据，结果发生碰撞。这种在未能检测出信道上其它站点信号的问题叫做隐蔽站问题（hidden station problem） </p><p><img src="/images/image-20210812153657006.png" alt="image-20210812153657006"></p></li><li><p>暴露站问题</p><p>B 向 A 发送数据，而 C 又想和 D 通信。C 检测到媒体上有信号，于是就不敢向 D 发送数据。其实 B 向 A 发送数据并不影响 C 向 D 发送数据这就是暴露站问题（exposed station problem）</p></li></ol><h3 id="7-1-3-802-11-协议的-MAC-帧格式"><a href="#7-1-3-802-11-协议的-MAC-帧格式" class="headerlink" title="7.1.3 802.11 协议的 MAC 帧格式"></a>7.1.3 802.11 协议的 MAC 帧格式</h3><p>802.11 协议有三种类型，控制帧、数据帧、管理帧。</p><p><img src="/images/image-20210812153804822.png" alt="image-20210812153804822"></p><p>MAC 首部，共 30 字节。帧的复杂性都在帧的首部。</p><p>帧主体，也就是帧的数据部分，不超过 2312 字节。这个数值比以太网的最大长度长很多。不过 802.11 帧的长度通常都是小于 1500 字节。</p><p>帧检验序列 FCS 是尾部，共 4 字节</p><p><img src="/images/image-20210812153937461.png" alt="image-20210812153937461"></p><p>通信过程如下：站点 A 向 B 发送数据帧，但数据帧必须经过 AP 转发。</p><p><img src="/images/image-20210812154004786.png" alt="image-20210812154004786"></p><p>当站点 A 把数据帧发送给 AP1 时，帧控制字段中的“到 DS=l”而“从 DS=0”。因此地址 l 是 AP1 的 MAC 地址（接收地址），地址 2 是 A 的 MAC 地址（源地址），地址 3 是 B 的 MAC 地址（目的地址）。请注意，“接收地址”与“目的地址”并不等同。</p><p>当 AP1 把数据帧发送给站点 B 时，帧控制字段中的“到 DS=0”而“从 DS=1”。因此地址 l 是 B 的 MAC 地址（目的地址），地址 2 是 AP1 的 MAC 地址（发送地址），地址 3 是 A 的 MAC 地址（源地址）。请注意，上述的“发送地址”与“源地址”也不相同。</p><h3 id="7-1-4-无线个人局域网-WPAN"><a href="#7-1-4-无线个人局域网-WPAN" class="headerlink" title="7.1.4 无线个人局域网 WPAN"></a>7.1.4 无线个人局域网 WPAN</h3><p>无线个人局域网 WPAN（wireless personal area netwark）把个人的电子设备用无线技术连接起来的组网方式。一般不需要接入点 AP，整个网络的范围大概在 10m 左右。</p><p>WPAN 使用的是 IEEE802.15 工作组制定。工作在 2.4Ghz 的 ISM 频段。</p><ol><li><p>蓝牙系统</p><p>蓝牙（ Bluetooth® ）：是一种无线技术标准，可实现固定设备、移动设备和楼宇个人域网之间的短距离数据交换（使用 2.4—2.485GHz 的 ISM 波段的 UHF 无线电波）。蓝牙技术最初由电信巨头爱立信公司于 1994 年创制，当时是作为 RS232 数据线的替代方案。蓝牙可连接多个设备，克服了数据同步的难题。</p></li><li><p>蓝牙特点</p><p>1）全球范围适用：蓝牙工作在 2.4GHz 的 ISM 频段，全球大多数国家 ISM 频段的范围是 2.4~2.4835GHz。</p><p>2）同时可传输语音和数据：蓝牙采用电路交换和分组交换技术，支持异步数据信道、三路语音信道以及异步数据与同步语音同时传输的信道。当采用非对称信道传输数据时，速率最高为 721kbit/s，反向为 57.6kbit/s。</p><p>3）可以建立临时性的对等连接（Ad-hoc Connection)：根据蓝牙设备在网络中的角色，可分为主设备（Master）与从设备（Slave）。 通过时分复用技术，一个蓝牙设备便可以同时与几个不同的皮网保持同步。</p><p>4）具有很好的抗干扰能力：为了很好地抵抗来自这些设备的干扰，蓝牙采用了跳频（Frequency Hopping）方式来扩展频谱（Spread Spectrum），将 2.402～2.48GHz 频段分成 79 个频点，相邻频点间隔 1MHz。</p><p>5）蓝牙模块体积很小、便于集成：由于个人移动设备的体积较小，嵌入其内部的蓝牙模块体积就应该更小。</p><p>6）低功耗：蓝牙设备在通信连接（Connection）状态下，有四种工作模式——激活（Active）模式、呼吸（Sniff）模式、保持（Hold）模式和休眠（Park）模式。Active 模式是正常的工作状态，另外三种模式是为了节能所规定的低功耗模式。</p><p>7）开放的接口标准：SIG 为了推广蓝牙技术的使用，将蓝牙的技术标准全部公开，全世界范围内的任何单位和个人都可以进行蓝牙产品的开发，只要最终通过 SIG 的蓝牙产品兼容性测试，就可以推向市场。</p><p>8）成本低：随着市场需求的扩大，各个供应商纷纷推出自己的蓝牙芯片和模块，蓝牙产品价格飞速下降</p></li></ol><h3 id="7-1-5-无线城域网-WMAN-（Wireless-Metropolitan-Area-Network）"><a href="#7-1-5-无线城域网-WMAN-（Wireless-Metropolitan-Area-Network）" class="headerlink" title="7.1.5 无线城域网 WMAN （Wireless Metropolitan Area Network）"></a>7.1.5 无线城域网 WMAN （Wireless Metropolitan Area Network）</h3><p>2002 年 4 月通过了 802.16 无线城域网的标准。欧洲的 ETSI 也制订类似的无线城域网标准 HIPerMAN。</p><p>WMAN 可提供“最后一英里”的宽带无线接入（固定的、移动的和便携的）。</p><p>在许多情况下，无线城域网可用来代替现有的有线宽带接入，因此它有时又称为无线本地环路。 </p><p>WiMAX 常用来表示无线城域网 WMAN，这与 Wi-Fi 常用来表示无线局域网WLAN 相似。</p><p>IEEE 的 802.16 工作组是无线城域网标准的制订者，而 WiMAX 论坛则是802.16 技术的推动者。</p><p>两个正式标准</p><p>802.16d（它的正式名字是 802.16-2004），是固定宽带无线接入空中接口标准（2 ~ 66 GHz 频段）。</p><p>802.16 的增强版本，即 802.16e，是支持移动性的宽带无线接入空中接口标准（2 ~ 6 GHz 频段），它向下兼容 802.16-2004。</p><p><img src="/images/image-20210812154532783.png" alt="image-20210812154532783"></p><h3 id="7-1-6-蜂窝移动通信网"><a href="#7-1-6-蜂窝移动通信网" class="headerlink" title="7.1.6 蜂窝移动通信网"></a>7.1.6 蜂窝移动通信网</h3><ol><li><p>简介</p><p>第一代（1G）蜂窝无线通信是为话音通信设计的模拟 FDM 系统。</p><p>第二代（2G）蜂窝无线通信提供低速数字通信（短信服务），其代表性体制就是最流行的 GSM 系统。</p><p>2.5G 技术是从 2G 向第三代（3G）过渡的衔接性技术，如 GPRS 和 EDGE 等。</p><p>3G 移动通信和计算机网络的关系非常密切，它使用 IP 的体系结构和混合的交换机制（电路交换和分组交换），能够提供移动宽带多媒体业务（话音、数据、视频等，可收发电子邮件，浏览网页，进行视频会议等），如 CDMA2000，WCDMA 和TD-SCDMA。 </p><p><img src="/images/image-20210812154708829.png" alt="image-20210812154708829"></p></li><li><p>移动 IP 技术</p><p>这种技术允许计算机移动到外地时，仍然保留其原来的 IP 地址。</p><p>移动 IP 要解决的问题，就是要使用户的移动性对上层的网络应用是透明的。 </p><p><img src="/images/image-20210812154831881.png" alt="image-20210812154831881"></p><p>1）移动 IP 的概念</p><p>移动 IP 是为了满足网络设备不断移动而设计的一种地址方式，主要是指移动设备是以固定的 IP 上网的一种技术，实现在不同 AP 之间使用同一个 IP 通信，保证通信的不中断的特点。</p><p>移动 IP 有三种设备实体：</p><ul><li>移动节点：IP 地址的使用者（手机等）</li><li>本地代理：当前手机的最初接入点，为计算机分配固定的 IP 地址。设备移动后，使用隧道技术转交移动节点的数据包。</li><li>外部代理：当节点位置变化，帮助移动节点完成数据转发的装置。</li></ul><p>2）移动 IP 通信过程</p><p>在网络中，一个设备获取的 IP 地址是唯一的固定的 IP 地址，在通信过程中，IP地址不发生改变。</p><p>移动 IP 的工作过程如下：</p><ol><li>移动结点在本网时，按传统的 TCP/IP 进行通信。</li><li>移动节点漫游到另一个外部网络时，仍然使用原有固定的 IP 地址。移动结点需向本地代理注册当前的位置地址，这个位置地址就是转交地址。</li><li>本地代理收到转交地址后，构建向转交地址的隧道，将截获的 IP 分组通过隧道转发给转交地址。</li><li>在转交地址处解除隧道封装，恢复原始的 IP 分组，最后送达到移动结点。</li></ol><p>移动节点发送过程正好相反。</p><p>移动终端有两个 IP 地址，即主机地址和辅助地址，主机在本网络时使用的是主机地址，当发生移动时，使用辅助地址。</p></li></ol><h1 id="8-信息安全"><a href="#8-信息安全" class="headerlink" title="8. 信息安全"></a>8. 信息安全</h1><h2 id="8-1-信息安全概述"><a href="#8-1-信息安全概述" class="headerlink" title="8.1 信息安全概述"></a>8.1 信息安全概述</h2><h3 id="8-1-1-信息特征"><a href="#8-1-1-信息特征" class="headerlink" title="8.1.1 信息特征"></a>8.1.1 信息特征</h3><p>由于在信息技术中信息的传递是通过现代的通信技术来完成的，处理信息是通过各种类型的计算机（智能工具）来完成的，而信息要为人类所利用，必须是可以控制的，因此也有人认为信息技术简单地说就是 3C：Computer（计算机）、Communication（通信）和 Control（控制），即 IT—Computer+Communication+Control</p><h3 id="8-1-2-信息安全"><a href="#8-1-2-信息安全" class="headerlink" title="8.1.2 信息安全"></a>8.1.2 信息安全</h3><ol><li><p>安全的内容</p><p>在计算机和网络上信息的处理是以数据的形式进行的，在这种情况下，信息就是数据。因而从这个角度来说，信息安全可以分为<strong>数据安全</strong>和<strong>系统安全</strong>，即信息安全可以从两个层次来看。</p><p>从消息的层次：完整性（Integrity）、保密性（ Confidentiality）、不可否认性（Non-repudiation）。</p><p>从网络层次：可用性（ Availability）、可控性（ Controllability）。</p></li><li><p>安全的属性</p><p>1）完整性</p><p>完整性是指信息在存储或传输的过程中保持未经授权不能改变的特性，即对抗主动攻击，保证数据的一致性，防止数据被非法用户修改和破坏。对信息安全发动攻击的最终目的是破坏信息的完整性。</p><p>保障网络信息完整性的主要方法有：</p><ul><li>协议：通过各种安全协议可以有效地检测出被复制的信息、被删除的字段、失效的字段和被修改的字段；</li><li>纠错编码方法：由此完成检错和纠错功能。最简单和常用的纠错编码方法是奇偶校验法；</li><li>密码校验和方法：它是抗窜改和传输失败的重要手段；</li><li>数字签名：保障信息的真实性；</li><li>公证：请求网络管理或中介机构证明信息的真实性。</li></ul><p>2）保密性</p><p>保密性是指信息不被泄露给未经授权者的特性，即对抗被动攻击，以保证机密信息不会泄露给非法用户。</p><p>常用的保密技术包括：防侦收（使对手侦收不到有用的信息）、防辐射（防止有用信息以各种途径辐射出去）、信息加密（在密钥的控制下，用加密算法对信息进行加密处理。即使对手得到了加密后的信息也会因为没有密钥而无法读懂有效信息）、物理保密（利用各种物理方法，如限制、隔离、掩蔽、控制等措施，保护信息不被泄露）。</p><p>3）可用性</p><p>可用性是指信息可被授权者访问并按需求使用的特性，即保证合法用户对信息和资源的使用不会被不合理地拒绝。对可用性的攻击就是阻断信息的合理使用，例如破坏系统的正常运行就属于这种类型的攻击。</p><p>可用性还应该满足以下要求：身份识别与确认、访问控制、业务流控制、路由选择控制、审计跟踪（审计跟踪的信息主要包括：事件类型、被管客体等级、事件时间、事件信息、事件回答以及事件统计等方面的信息）。</p><p>4）不可否认性</p><p>不可否认性也称为不可抵赖性，即所有参与者都不可能否认或抵赖曾经完成的操作和承诺。发送方不能否认已发送的信息，接收方也不能否认已收到的信息。</p><p>5）可控性</p><p>可控性是指对信息的传播及内容具有控制能力的特性。授权机构可以随时控制信息的机密性，能够对信息实施安全监控。</p></li></ol><h3 id="8-1-3-安全的技术"><a href="#8-1-3-安全的技术" class="headerlink" title="8.1.3 安全的技术"></a>8.1.3 安全的技术</h3><ol><li><p>信息加密</p><p>信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。</p></li><li><p>数字签名</p><p>1）签名过程</p><p>签名过程是利用签名者的私有信息作为密钥，或对数据单元进行加密，或产生该数据单元的密码校验值。</p><p>2）验证过程</p><p>验证过程是利用公开的规程和信息来确定签名是否是利用该签名者的私有信息产生的。</p><p>3）访问控制</p><p>访问控制的目的是防止对信息资源的非授权访问和非授权使用。</p><p>4）数据备份和灾难恢复</p><p>只要发生数据传输、数据存储和数据交换，就有可能产生数据故障，如果没有采取数据备份和灾难恢复手段与措施，就会导致数据的丢失。</p><p>5）防火墙技术</p><p>防火墙技术是一种允许接入外部网络，但同时又能够识别和抵抗非授权访问的安全技术。</p><p>6）入侵检测技术</p><p>入侵检测系统作为一种积极主动的安全防护手段，在保护计算机网络和信息安全方面发挥着重要的作用。</p><p>7）内网安全技术</p><p>商业间谍、黑客、不良员工对网络信息安全形成了巨大的威胁，而网络的普及和USB 接口的大量使用在给各单位获取和交换信息带来巨大方便的同时，也给这些威胁大开方便之门。</p><p>8）安全协议</p><p>整个网络系统的安全强度实际上取决于所使用的安全协议的安全性。</p><p>9）身份鉴别</p><p>鉴别是信息安全的基本机制，通信的双方之间应互认证对方的身份，以保证赋予正确的操作权力和数据的存取控制。</p><p>10）反病毒技术</p><p>由于计算机病毒具有传染的泛滥性、病毒侵害的主动性、病毒程序外形检测的难以确定性和病毒行为判定的难以确定性、非法性与隐蔽性、衍生性、衍生体的不等性和可激发性等特性，所以必须花大力气认真加以对付。</p><p>11）安全审计</p><p>安全审计是防止内部犯罪和事故后调查取证的基础，通过对一些重要的事件进行记录，从而在系统发现错误或受到攻击时能定位错误和找到攻击成功的原因。</p><p>12）业务填充</p><p>所谓的业务填充是指在业务闲时发送无用的随机数据，增加攻击者通过通信流量获得信息的困难。</p><p>13）公证机制</p><p>公证机制是对两个或多个实体间进行通信的数据的性能，如完整性、来源、时间和目的地等，由公证机构加以保证，这种保证由第三方公证者提供。</p></li></ol><h2 id="8-2-安全技术手段"><a href="#8-2-安全技术手段" class="headerlink" title="8.2 安全技术手段"></a>8.2 安全技术手段</h2><h3 id="8-2-1-信息加密技术"><a href="#8-2-1-信息加密技术" class="headerlink" title="8.2.1 信息加密技术"></a>8.2.1 信息加密技术</h3><ol><li><p>对称加密—私钥</p><p>1）概念</p><p>对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。形象地说就是一把钥匙开一把锁。</p><p>2）加密过程</p><p><img src="/images/image-20210812164751685.png" alt="image-20210812164751685"></p><p>3）对称加密算法特点</p><p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。</p><p>不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。</p><p>常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5算法，IDEA 算法。</p></li><li><p>非对称密钥加密</p><p>1）概念</p><p>公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一个。其中一个称为<strong>公钥用于加密</strong>，是公开的，另一个称为<strong>私钥用于解密</strong>，是保密的。</p><p>公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。</p><p>2）工作原理</p><p><img src="/images/image-20210812165624477.png" alt="image-20210812165624477"></p><p>A 要向 B 发送信息，A 和 B 都要产生一对用于加密非对称加密算法和解密的公钥</p><p>和私钥。</p><p>A 的私钥保密，A 的公钥告诉 B；B 的私钥保密，B 的公钥告诉 A。</p><p>A 要给 B 发送信息时，A 用 B 的公钥加密信息，因为 A 知道 B 的公钥。</p><p>A 将这个消息发给 B（已经用 B 的公钥加密消息）。</p><p>B 收到这个消息后，B 用自己的私钥解密 A 的消息。其他所有收到这个报文的人都无法解密，因为只有 B 才有 B 的私钥。</p></li><li><p>RSA 算法</p><p>RSA 是 Rivest、Shamire 和 Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。</p></li></ol><h3 id="8-2-2-数字签名"><a href="#8-2-2-数字签名" class="headerlink" title="8.2.2 数字签名"></a>8.2.2 数字签名</h3><p>数字签名在信息安全（包括身份认证、数据完整性、不可否认性以及匿名性等方面）有重要应用，特别是在大型网络安全通信中的密钥分配、认证及电子商务系统中具有重要作用。数字签名是实现认证的重要工具。</p><ol><li><p>数字签名概念</p><p>数字签名就是通过一个单向 Hash 函数对要传送的报文进行处理，用以认证报文来源并核实报文是否发生变化的一个字母数字串，该字母数字串被称为该消息的消息鉴别码或消息摘要，这就是通过单向 Hash 函数实现的数字签名。数字签名除了具有普通手写签名的特点和功能外，还具有自己独有的特性和功能。</p><p><img src="/images/image-20210812170016360.png" alt="image-20210812170016360"></p></li><li><p>数字签名的特性和功能</p><p>1）数字签名的特性</p><p>签名是可信的：任何人都可以方便地验证签名的有效性。</p><p>签名是不可伪造的：除了合法的签名者之外，任何其他人伪造其签名是困难的。这种困难性指实现时计算上是不可行的。</p><p>签名是不可复制的：对一个消息的签名不能通过复制变为另一个消息的签名。如果一个消息的签名是从别处复制的，则任何人都可以发现消息与签名之间的不一致性，从而可以拒绝签名的消息。</p><p>签名的消息是不可改变的：经签名的消息不能被篡改。一旦签名的消息被篡改，则任何人都可以发现消息与签名之间的不一致性。</p><p>签名是不可抵赖的：签名者不能否认自己的签名。</p><p>2）数字签名的实现方法</p><p>用对称加密算法进行数字签名</p><p>用非对称加密算法进行数字签名和验证</p></li></ol><h3 id="8-2-3-认证和授权"><a href="#8-2-3-认证和授权" class="headerlink" title="8.2.3 认证和授权"></a>8.2.3 认证和授权</h3><ol><li><p>身份认证</p><p>身份认证是人们认证他们是谁的过程。</p><p>1）系统使用用户名和密码组合，包括 Kerberos</p><p>在获悉的密码认证的方法中，计算机发起一个挑战，被认证方提供一个响应。如果该响应能够验证通过，用户就通过了身份认证，允许他访问系统，否则就阻止他进行访问。</p><p>2）基于证书的认证</p><p>证书是一个信息集合，将身份信息（用户、计算机、服务或者设备）与公钥，私钥对里的公钥进行绑定。在组织中用来支持证书的基础设施称作公钥基础设施（PKI）。 </p><p>3）生物识别</p><p>生物识别系统包括面部识别及鉴定、视网膜扫描、虹膜扫描、指纹、手型、语音识别、嘴唇运动和击键分析。</p></li><li><p>授权</p><p>授权通常被认为是建立一种对资源的访问方式，例如文件和打印机，但它也能处理用户在系统或者网络上的特权。在最终使用过程中，授权甚至能指定特定的用户是否能访问系统。有各种类型的授权系统，包括用户权限、基于角色的授权、访问控制列表和基于规则的授权。</p><p>1）用户授权</p><p>用户权限提供授权操作可以影响整个系统的事情。可以创建组、把用户分配到组、登录系统以及分配多个用户的权限。</p><p>2）基于角色的授权（RBAC）</p><p>计算机系统的设计者认为用户对于系统的要求可能会有所不同，并不是所有用户都应该给予系统管理员权限。</p><p>3）访问控制列表（ACL）</p><p>信息系统可能也可以使用 ACL 来确定所请求的服务或资源是否有权限。访问服务器上的文件通常由保留在每个文件的信息所控制．同样，网络设备上不同类型的通信也可以通过 ACL 来控制。</p><ol><li><p>文件访问权：</p><p>window 系统中，Windows NTFS文件系统为每一个文件和文件夹提供一个ACL。文件的权限是完全控制、修改、读取和执行、列出文件内容、读取、写入、特殊权限。</p><p>unix 系统中，不使用 ACL。而是通过限制用户账户和组的访问权限来保护文件。不同用户和组对文件的权限有：读取、写入、执行、拒绝等权限。</p></li><li><p>网络设备的 ACL</p><p>网络设备使用 ACL 来控制网络的访问和授予的访问类型。具体来说，路由器和防火墙的访问控制列表指明了来访流量能够访问哪台计算机的哪个端口。或是设备能接收并路由到其他网络中的流量类型。</p></li></ol></li></ol><h3 id="8-2-4-PKI-技术"><a href="#8-2-4-PKI-技术" class="headerlink" title="8.2.4 PKI 技术"></a>8.2.4 PKI 技术</h3><ol><li><p>PKI 概念</p><p>公钥基础设施（Public Key Infrastructure，PKI）：采用非对称密码算法原理和技术来实现并提供安全服务。通用的办法是采用建立在 PKI 基础之上的数字证书，通过把要传输的数字信息进行加密和签名，保证信息传输的机密性、真实性、完整性和不可否认性，从而保证信息的安全传输。</p><p><img src="/images/image-20210812172431855.png" alt="image-20210812172431855"></p></li><li><p>数字证书</p><p>证书是证明实体所声明的身份和其公钥绑定关系的一种电子文档，是将公钥和确定属于它的某些信息（比如该密钥对持有者的姓名、电子邮件或者密钥对的有效期等信息）相绑定的数字声明。数字证书由 CA 认证机构颁发。</p></li><li><p>PKI 系统功能</p><p>一个完整的 PKI 系统对于数字证书的操作通常包括证书颁发、证书更新、证书废除、证书和 CRL 的公布、证书状态的在线查询、证书认证等。</p><p>1）证书颁发</p><p>申请者在 CA 的注册机构（RA）进行注册，申请证书。CA 对申请者进行审核，审核通过则生成证书，颁发给申请者。证书的申请可采取在线申请和亲自到 RA 申请两种方式。证书的颁发也可采取两种方式，一种是在线直接从 CA 下载，一种是 CA将证书制作成介质（磁盘或 IC 卡）后，由申请者带走。</p><p>2）证书更新</p><p>当证书持有者的证书过期，证书被窃取、丢失时通过更新证书方法，使其使用新的证书继续参与网上认证。证书的更新包括证书的更换和证书的延期两种情况。</p><p>3）证书废除</p><p>CA 通过认证核实，即可履行废除证书职责，通知有关组织和个人，并写入黑名单 CRL。</p><p>4）证书和 CRL 的公布</p><p>CA 通过轻量级目录访问协议（Lightweight Directory Access Protocol，LDAP）服务器维护用户证书和黑名单（CRL）。</p><p>5）证书认证</p><p>在进行网上交易双方的身份认证时，交易双方互相提供自己的证书和数字签名，由 CA 来对证书进行有效性和真实性的认证。</p></li><li><p>系统的组成</p><p>PKI 公钥基础设施是提供公钥加密和数字签名服务的系统或平台，目的是为了管理密钥和证书。</p><p>认证机构（Certificate Authority，CA）、根 CA（Root CA）、注册机构（Registration Authority，RA）、证书目录、管理协议等。</p></li><li><p>PKI 核心服务</p><p>1）认证</p><p>认证即为身份识别与鉴别，即确认实体是其所声明的实体，鉴别其身份的真伪。</p><p>2）完整性</p><p>完整性就是确认数据没有被修改，即数据无论是在传输还是在存储过程中经过检查没有被修改。</p><p>3）保密性</p><p>又称机密性服务，就是确保数据的秘密。PKI 的机密性服务是一个框架结构，通过它可以完成算法协商和密钥交换，而且对参与通信的实体是完全透明的。</p></li></ol><h3 id="8-2-5-风险评估"><a href="#8-2-5-风险评估" class="headerlink" title="8.2.5 风险评估"></a>8.2.5 风险评估</h3><ol><li><p>风险分析</p><p>风险分析必须成为任何安全防御中的一个组成部分。简单来说，风险的常规定义是非期望事件（威胁）的发生概率，而利用漏洞引发不希望的结果就是非期望事件。</p></li><li><p>定性评估</p><p>不对危险性进行量化处理，只做定性的比较。定性评估使用系统工程方法，将系统进行分解，依靠人的观察分析能力，借助有关法规、标准、规范、经验和判断能力进行评估。</p></li><li><p>定量评估</p><p>是在危险性量化的基础上进行评估，主要依靠历史统计数据，运用数学方法构造数学模型进行评估。定量评估法分为：①概率评估法②数学模型计算评估③相对评估法（即指数法）。</p></li></ol><h3 id="8-2-6-防火墙技术"><a href="#8-2-6-防火墙技术" class="headerlink" title="8.2.6 防火墙技术"></a>8.2.6 防火墙技术</h3><p>防火墙是成熟的网络安全技术之一，是企事业单位构筑安全网络系统的基本组件。</p><ol><li><p>概念</p><p>防火墙是一种访问控制技术：在某个机构的网络和不安全的网络之间设置障碍，阻止对信息资源的非法访问，控制进出两个方向的通信。</p><p>防火墙是放置在两个网络之间的一组组件：只允许本地安全策略授权的通信信息通过；双向通信信息必须通过防火墙；防火墙本身不会影响信息的流通。</p><p>防火墙是位于两个信任程度不同的网络之间（ 如企业内部网络和 Internet 之间）的软件或硬件设备的组，它对两个网络之间的通信进行控制，通过强制实施统一的安全策略，防止对重要信息资源的非法存取和访问，以达到保护系统安全的目的。</p></li><li><p>防火墙分类</p><p>根据防火墙组成组件的不同可以将防火墙分为软件防火墙和硬件防火墙。一般情况下，硬件防火墙都是以软件和硬件相结合的方式实现。</p><p>根据防火墙技术的实现平台，防火墙可分为基于 Windows 平台的 Windows 防火墙和基于 Linux 平台的 Linux 防火墙等。</p><p>根据防火墙被保护的对象的不同，防火墙可以分为主机防火墙和网络防火墙。传统防火墙都是网络防火墙。</p><p>根据防火墙自身的体系结构可以分为：包过滤型防火墙，双宿网关等。</p><p>根据防火墙所使用的主要技术：基于包过滤的防火墙、应用层代理、电路级网关、地址翻译防火墙和状态检查防火墙等。</p></li><li><p>防火墙的弊端</p><p>1）限制有用的网络服务</p><p>防火墙为了提高被保护网络的安全性，限制或关闭了很多有用但存在安全缺陷的网络服务。</p><p>2）无法防护内部网络用户的攻击</p><p>防火墙只提供对外部网络用户攻击的防护。对来自内部网络用户的攻击只能依靠内部网络主机系统的安全性。防火墙无法禁止变节者或公司内部存在的间谍将敏感数据拷贝到软盘上，并将其带出公司。</p><p>3）无法防范通过防火墙以外的其他途径的攻击</p><p>从而试图绕过由精心构造的防火墙系统提供的安全系统。</p><p>4）无法完全防止传送已感染病毒的软件或文件</p><p>Internet 防火墙去对每一个文件进行扫描，但无法查出潜在的病毒。对病毒特别关心的机构应在每个桌面部署防病毒软件，防止病毒从软盘或其他来源进入网络系统。</p><p>5）无法防备新的网络安全问题</p><p>防火墙是一种被动式的防护手段，它只能对现在已知的网络威胁起作用。随着网络攻击手段的不断更新和一些新的网络应用的出现，不可能靠一次性的防火墙设置来解决永久的网络安全问题。</p></li><li><p>常见防火墙</p><p>1）包过滤型防火墙</p><p>包过滤型防火墙往往可以用一台过滤路由器来实现对所接收的每个数据包做允许拒绝的决定。路由器审查每个数据包，以便确定其是否与某一条包过滤规则匹配。过滤规则基于 IP 包头信息。</p><p>包头信息中包括 IP 源地址、IP 目标端地址、内装协议（ ICP、UDP、ICMP 或 IP Tunnel）、TCP UDP 目标端口、ICMP 消息类型以及 TCP 包头中的 ACK 位。</p><ol><li><p>技术优点编辑</p><p>对于一个小型的、不太复杂的站点，包过滤比较容易实现。</p><p>因为过滤路由器工作在 IP 层和 TCP 层，所以处理包的速度比代理服务器快。</p><p>过滤路由器为用户提供了一种透明的服务，用户不需要改变客户端的任何应用程序，也不需要用户学习任何新的东西。</p><p>过滤路由器在价格上一般比代理服务器便宜。</p></li><li><p>技术缺点编辑</p><p>一些包过滤网关不支持有效的用户认证。</p><p>规则表很快会变得很大而且复杂，规则很难测试。随着表的增大和复杂性的增加，规则结构出现漏洞的可能性也会增加。</p><p>这种防火墙最大的缺陷是它依赖一个单一的部件来保护系统。</p><p>在一般情况下，如果外部用户被允许访问内部主机，则它就可以访问内部网上的任何主机。</p><p>包过滤防火墙只能阻止一种类型的 IP 欺骗，即外部主机伪装内部主机的 IP，对于外部主机伪装外部主机的 IP 欺骗却不可能阻止，而且它不能防止 DNS 欺骗。</p></li></ol><p>2）双宿网关防火墙</p><p>一个双重宿主主机是一种防火墙，拥有两个连接到不同网络上的网络接口。</p><p>第一种方式需要在双重宿主主机上开许多账号，这是很危险的。</p><p><img src="/images/image-20210812185912436.png" alt="image-20210812185912436"></p><p>双重宿主主机是惟一的隔开内部网和外部因特网之间的屏障，如果入侵者得到了双重宿主主机的访问权，内部网络就会被入侵。</p><p>第二种方式一些服务本身就是“存储转发”型的。在双重宿主主机上，运行各种各样的代理服务器，当要访问外部站点时，必须先经过代理服务器认证，然后才可以通过代理服务器访问因特网。</p><p><img src="/images/image-20210812190042812.png" alt="image-20210812190042812"></p><p>3）屏蔽主机防火墙</p><p>屏蔽主机防火墙强迫所有的外部主机与一个堡垒主机相连接，而不让它们直接与内部主机相连。屏蔽主机防火墙由包过滤路由器和堡垒主机组成。这个防火墙系统提供的安全等级比包过滤防火墙系统要高，因为它实现了网络层安全（包过滤） 和应用层安全（代理服务）。</p><p><img src="/images/image-20210812190151671.png" alt="image-20210812190151671"></p><p>4）代理服务器</p><p>代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联（OSI）模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接 INTERNET（国际互联网）和 Local Area Network（局域网）。</p><p>Proxy Server（代理服务器）是 Internet 链路级网关所提供的一种重要的安全功能，主要的功能有：</p><p>减少的暴露主机的数量，保护内部的网络的安全</p><p>代理服务器上使用公有 IP 地址，内部主机使用私有 IP 地址，节省 IP 地址数量</p><p>代理服务器有私有 IP 和公有 IP 的转换功能（NAT 技术）</p><p>代理服务器本身有缓存功能，加快上网的速度</p></li></ol><h3 id="8-2-7-入侵检测技术"><a href="#8-2-7-入侵检测技术" class="headerlink" title="8.2.7 入侵检测技术"></a>8.2.7 入侵检测技术</h3><ol><li><p>入侵检测概念</p><p>入侵检测是指“通过对行为、安全日志或审计数据或其它网络上可以获得的信息进行操作，检测到对系统的闯入或闯入的企图”。入侵检测是检测和响应计算机误用的学科，其作用包括威慑、检测、响应、损失情况评估、攻击预测和起诉支持。</p></li><li><p>入侵检测分类</p><p>1）根据原始数据的来源</p><p>基于主机的入侵检测系统：主要用于保护运行关键应用的服务器。它通过监视与分析主机的审计记录和日志文件来检测入侵。</p><p>基于网络的入侵检测系统：主要用于实时监控网络关键路径的信息，它侦听网络上的所有分组，采集数据，分析可疑现象。</p><p>基于应用的入侵检测系统：基于主机的入侵检测系统的一个特殊子集，也可以说是基于主机入侵检测系统实现的进一步的细化。</p><p>2）根据检测原理</p><p>特征检测（Signature-based detection）又称 Misuse detection ，这一检测假设入侵者活动可以用一种模式来表示，系统的目标是检测主体活动是否符合这些模式。它可以将已有的入侵方法检查出来，但对新的入侵方法无能为力。其难点在于如何设计模式既能够表达“入侵”现象又不会将正常的活动包含进来。</p><p>异常检测（Anomaly detection）的假设是入侵者活动异常于正常主体的活动。根据这一理念建立主体正常活动的“活动简档”，将当前主体的活动状况与“活动简档”相比较，当违反其统计规律时，认为该活动可能是“入侵”行为。异常检测的难题在于如何建立“活动简档”以及如何设计统计算法，从而不把正常的操作作为“入侵”或忽略真正的“入侵”行为。</p><p>3）根据工作方式</p><p>离线检测：在事件发生后分析审计事件，从中检查入侵事件。这类系统的成本低，可以分析大量事件，调查长期的情况；但由于是在事后进行，不能对系统提供及时的保护，而且很多入侵在完成后都将审计事件去掉，使其无法审计。</p><p>在线检测：对网络数据包或主机的审计事件进行实时分析，可以快速反应，保护系统的安全；但在系统规模较大时，难以保证实时性。</p></li></ol><h2 id="8-3-计算机病毒"><a href="#8-3-计算机病毒" class="headerlink" title="8.3 计算机病毒"></a>8.3 计算机病毒</h2><h3 id="8-3-1-计算机病毒"><a href="#8-3-1-计算机病毒" class="headerlink" title="8.3.1 计算机病毒"></a>8.3.1 计算机病毒</h3><ol><li><p>病毒的破坏性</p><p>直接破坏计算机上的重要信息，主要表现为删除、篡改文件，格式化硬盘等；</p><p>抢占系统资源，降低系统性能，有的病毒大量复制垃圾文件，不断占用系统内存，甚至导致系统崩溃；</p><p>窃取主机上的重要信息，如信用卡密码、管理员账号密码等；</p><p>破坏计算机硬件，有的主板的 BIOS 允许在正常电压下升级，容易受到类似 CIH病毒的攻击，新型主板采用“软跳线”的越来越多，这也给了病毒破坏硬件的机会；</p><p>导致网络阻塞，甚至瘫痪;</p><p>使邮件服务器、Web 服务器不能提供正常服务。</p></li><li><p>病毒的定义</p><p>计算机病毒，是指人为编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据，影响计算机使用，并能够自我复制的一组计算机指令或者程序代码。</p></li></ol><h3 id="8-3-2-计算机病毒基本特征"><a href="#8-3-2-计算机病毒基本特征" class="headerlink" title="8.3.2 计算机病毒基本特征"></a>8.3.2 计算机病毒基本特征</h3><p>计算机病毒还有传染性、传播性、破坏性、寄生性、欺骗性、隐蔽性、潜伏性和衍生性等特征。它一般都隐蔽在合法程序（ 被感染的合法程序称作宿主程序） 中，当计算机运行时，它与合法的程序争夺系统的控制权，从而对计算机系统实施干扰和破坏作用。</p><ol><li><p>可执行性</p><p>计算机病毒是一段能够执行的代码，既可以是二进制代码，也可以是一段脚本，或者宏病毒利用 Office 对 Word 文档进行操作的时候获得执行权限，执行脚本进行破坏。</p></li><li><p>传染性与传播性</p><p>病毒要进行传染，就需要进行自我复制，常用的方法就是把自己的病原体代码注入到宿主程序中，当宿主程序运行时，病毒代码也能随之运行。病毒的传染性主要作用于一台主机上，而病毒要从一台主机蔓延到另一台主机，其所需要的另一种特性就是传播性，即通过网络或者存储介质（包括软盘、硬盘） 进行传播。</p></li><li><p>破坏性</p><p>计算机病毒的破坏性是多种多样的，例如损坏数据、导致系统的异常、窃取用户数据、阻塞网络等等。</p></li><li><p>寄生性</p><p>狭义的病毒一般不是完整的程序，它通常附加在其他程序中，就像生物界中的寄生现象。被寄生的程序称为宿主程序，或者称为病毒载体。当然，现在的某些病毒本身就是一个完整的程序，特别是广义病毒中的网络蠕虫。</p></li><li><p>欺骗性</p><p>黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字，比如把自己命名成微软补丁，或者是动画的名字，欺骗用户执行这个程序。“爱虫”病毒就是利用标题为“I LOVE YOU”的邮件欺骗用户点击。</p></li><li><p>隐蔽性和潜伏性</p><p>计算机病毒要获得有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。因为用户一旦发现，计算机病毒就有可能被清除，这将影响到计算机病毒本身的生存性。</p></li><li><p>衍生性</p><p>既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。</p></li><li><p>可触发性</p><p>编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如，系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。</p></li></ol><h3 id="8-3-3-计算机病毒的分类"><a href="#8-3-3-计算机病毒的分类" class="headerlink" title="8.3.3 计算机病毒的分类"></a>8.3.3 计算机病毒的分类</h3><ol><li><p>按攻击的操作系统分类</p><p>1）攻击 DOS 系统的病毒</p><p>这种病毒也称作 DOS 病毒，出现最早，变种也最多，传播也非常广泛，如小球病毒等。</p><p>2）攻击 Windows 系统的病毒</p><p>攻击 Windows 的病毒主要是宏病毒，有感染 Word 的宏病毒，有感染 Excel 的宏病毒，还有感染 Access 的宏病毒，其中感染 Word 的宏病毒最多。</p><p>3）攻击 Unix 或 OS/ 2 系统的病毒</p><p>世界上也已经发现攻击 OS/2 系统的病毒。</p></li><li><p>按传播媒介分类</p><p>1）单机病毒</p><p>单机病毒的载体是磁盘，常见的是病毒从软盘传入硬盘，感染系统，然后再感染其他软盘，进而再感染其他系统。</p><p>2）网络病毒</p><p>网络病毒的传播媒介是网络。随着网上用户的增加，网络病毒的传播速度更快，范围更广，造成的危害更大。网络病毒往往造成网络堵塞，修改网页，甚至与其他病毒结合修改或破坏文件。</p></li><li><p>按链接方式分类</p><p>1）源码型病毒</p><p>这类病毒在高级语言（ 如 Fortran 、C、Pascal 等语言）编写的程序被编译之前，插入目标源程序之中，经编译，成为合法程序的一部分。这类病毒程序一般寄生在编译处理程序或链接程序中。</p><p>2）入侵型病毒</p><p>入侵型病毒也叫嵌入型病毒，在感染时往往对宿主程序进行一定的修改，通常是寻找宿主程序的空隙将自己嵌入进去，并变为合法程序的一部分，使病毒程序与目标程序成为一体。一旦病毒侵入宿主程序，对其杀毒是十分困难的，清除这类病毒时往往会破坏合法程序。</p><p>3）外壳型病毒</p><p>这类病毒程序一般链接在宿主程序的首尾，对原来的主程序不做修改或仅做简单修改。当宿主程序执行时，首先执行并激活病毒程序，使病毒得以感染、繁衍和发作。这类病毒易于编写，数量也最多。</p></li><li><p>按表现（ 破坏） 情况分类</p><p>1）良性病毒</p><p>良性病毒是指那些只表现自己，而不破坏计算机系统的病毒。它们多是出自一些恶作剧者之手。病毒制造者编制病毒的目的不是为了对计算机系统进行破坏，而是为了显示他们在计算机编程方面的技巧和才华。</p><p>2）恶性病毒</p><p>恶性病毒的目的就是有意或无意地破坏系统中的信息资源。常见的恶性病毒的破坏行为是删除计算机系统内存储的数据和文件；也有一些恶性病毒不删除任何文件，而是对磁盘乱写一气，表面上看不出病毒破坏的痕迹，但文件和数据的内容已被改变；还有一些恶性病毒对整个磁盘或磁盘的特定扇区进行格式化，使磁盘的信息全部消失。</p></li><li><p>按寄生方式分类</p><p>1）引导型病毒</p><p>引导型病毒也称磁盘引导型、引导扇区型、磁盘启动型、系统型病毒等。引导型病毒就是把自己的病毒程序放在软磁盘的引导区以及硬磁盘的主引导记录区或引导扇区，当作正常的引导程序，而将真正的引导程序搬到其他位置。</p><p>2）文件型病毒</p><p>文件型病毒是指所有通过操作系统的文件系统进行感染的病毒。文件型病毒以感染可执行文件（ .bat 、.exe 、.com、.sys 、.dll、.ovl、.vxd 等） 的病毒为主，还有一些病毒可以感染高级语言程序的源代码、开发库或编译过程中所生成的中间文件。</p><p>3）混合型病毒</p><p>混合型病毒，也称综合型、复合型病毒，既具有引导型病毒的特点，又具有文件型病毒的特点，即这种病毒既可以感染磁盘引导扇区，又可以感染可执行文件。这类病毒的危害性更大。</p></li><li><p>宏病毒</p><p>宏病毒是一种存储于文档、模板或加载宏程序中的计算机病毒。当打开已受感染的文件（ 如 Word 文档） 或执行触发宏病毒的操作时，病毒就会被激活，并存储到Normal.dot 模板或 Personal.xls 文件中。从此以后，保存的每个文档都会自动被病毒“感染”，如果其他人打开受病毒感染的文件，那么宏病毒就会传播到他们的计算机中。</p><p>宏病毒与以往的传统计算机病毒不同，它是只感染微软的文档（ .doc 或.xls 等）的一种专向病毒。</p></li><li><p>网络病毒</p><p>网络病毒有很多种类，例如脚本病毒、邮件病毒等。依据病毒的攻击手段，可将网络型病毒分为<strong>蠕虫</strong>和<strong>木马</strong>两大类型。</p><p>1）蠕虫</p><p>蠕虫（ Worm） 是通过分布式网络来扩散传播特定信息或错误，破坏网络中的信息或造成网络服务中断的病毒。</p><p>“蠕虫”一般由两部分组成：一个主程序和一个引导程序。主程序一旦在机器上执行，就会通过读取公共配置文件以及收集当前网络状态信息，获得与当前机器联网的其他机器的信息和软件缺陷，主动尝试利用所获得的信息以及其他机器的缺陷在这些远程机器上建立其引导程序。</p><p>2003 年1 月25 日首次发作的Win32 .SQLExp . Worm 病毒就是一个非常典型的蠕虫病毒，它具备了蠕虫病毒所有的典型特征。</p><p>2）木马</p><p>木马又称特洛伊木马（ Trojan horse） ，它原本属于一类基于远程控制的工具。木马的运行模式属于客户/ 服务模式，它包括两大部分，即客户端和服务端。其原理是一台主机提供服务（ 服务器），另一台主机接收服务（ 客户机） 。作为服务器的主机一般会打开一个默认的端口进行监听。木马之所以能够运行的原因是由于用户的程序通常继承了与用户相同、惟一的优先权和存取权。</p></li></ol><h3 id="8-3-4-计算机病毒的传播"><a href="#8-3-4-计算机病毒的传播" class="headerlink" title="8.3.4 计算机病毒的传播"></a>8.3.4 计算机病毒的传播</h3><ol><li><p>移动设备</p><p>最易传播的途径是网络，其次是 U 盘，再次是光盘，由于硬盘一般在机器内，不会传播到其它电脑上，除非你把有毒的硬盘换到其它机器上。</p></li><li><p>计算机网络</p><p>最可恶的传播是通过网络，可以通过系统漏洞，IE，办公软件漏洞，无需运行病毒服务端，直接可以获得最高权限，从而控制对方机器，还有一类网络攻击是在提供互联网服务的主机（一般通过网页方式），在被访问的网页中植入病毒或恶意代码，客户通过访问这种页面就会中毒，传播面很大（知名网站的访问量也很大），一天之内（也可能更短）可以传播到全世界。</p></li><li><p>E-mail 传输</p><p>其它的传播方式是通过 E-MAIL，在图片中植入木马等方式用得也多，不过危害面比第一种稍小，第一类网络传播途径中，还有一种所谓的“钓鱼”网站，现在也流行，就是不法分子通过收买，自建一个网站，伪造一个某官方网站（一般客户看不出真假），通常是一些游戏、银行、购物网站被仿冒，目的是为了骗取账号密码，赚取钱财或个人隐私，受害面也大。 </p></li></ol><h3 id="8-3-5-计算机病毒的防御"><a href="#8-3-5-计算机病毒的防御" class="headerlink" title="8.3.5 计算机病毒的防御"></a>8.3.5 计算机病毒的防御</h3><ol><li><p>提高安全意识</p><p>树立病毒防范意识，从思想上重视计算机病毒。用户是计算机的使用者，很多攻击事件就是由于用户的安全意识薄弱，无意中触发了黑客设下的机关、打开了带有恶意攻击企图的邮件或网页造成的。</p></li><li><p>安装杀毒软件</p><p>一定要安装正版的杀毒软件和防火墙，并及时升级到最新版本（如瑞星、江民、卡巴斯基、等）。另外还要及时升级杀毒软件病毒库，同时还要启动杀毒软件的“自动防护”功能，这样才能防范新病毒，为系统提供真正安全环境。</p></li><li><p>传输介质要扫描</p><p>插入软盘、光盘和其他可插拔介质前，一定对它们进行病毒扫描。在使用这些光盘、U 盘以及从网络上下载的程序之前必须使用杀毒工具进行扫描，查看是否带有病毒，确认无病毒后，再使用。</p></li><li><p>网站的安全</p><p>不从不受信任的网站下载软件，不要随便登录不明网站、黑客网站或色情网站。用户不要随便登录不明网站或者黄色网站，不要随便点击打开 QQ、MSN 等聊天工具上发来的链接信息，不要随便打开或运行陌生、可疑文件和程序，如邮件中的陌生附件，外挂程序等，这样可以避免网络上的恶意软件插件进入你的计算机。</p></li><li><p>备份数据</p><p>最后应注意养成经常备份重要数据的习惯，要定期与不定期地对磁盘文件进行备份，特别是一些比较重要的数据资料，以便在感染病毒导致系统崩溃时可以最大限度地恢复数据，尽量减少可能造成的损失。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>职测英语</title>
    <link href="/2021/08/10/8.%20%E8%81%8C%E6%B5%8B%E8%8B%B1%E8%AF%AD/"/>
    <url>/2021/08/10/8.%20%E8%81%8C%E6%B5%8B%E8%8B%B1%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单项选择之词汇"><a href="#1-单项选择之词汇" class="headerlink" title="1. 单项选择之词汇"></a>1. 单项选择之词汇</h1><p>英语科目的单项选择题是银行招考中常考的题型，通常考查词汇、词组和语法的运 用能力。其中70%-80%的考题无需完整阅读文句，只需浏览空格的前后部分就能得出 答案，此类题目通常与语法知识相关，如句子成分分析、固定词组搭配以及与代词、连 词、强调句等，其余部分的考题则需要大致掌握文意方可正确解答。</p><p><img src="/images/image-20210810230013685.png" alt="image-20210810230013685"></p><h2 id="1-1-名词"><a href="#1-1-名词" class="headerlink" title="1.1 名词"></a>1.1 名词</h2><p>名词是表示人、事物、抽象概念等名称的词。一般用作主语、宾语、表语或者宾语补足语。名词分为<strong>可数名词</strong>和<strong>不可数名词</strong>两类：可数名词是指能以数目来计算，可以分成个体的人或物；不可数名词是指不能以数目来计算，不可以分成个体的概念、状态、 品质、感情或表示物质材料的东西。</p><h3 id="1-1-1-可数名词与不可数名词"><a href="#1-1-1-可数名词与不可数名词" class="headerlink" title="1.1.1 可数名词与不可数名词"></a>1.1.1 可数名词与不可数名词</h3><ol><li><p>可数名词复数变化规则</p><p>1）一般情况下可数名词后直接加S变复数</p><p>e.g. card -&gt; cards, map -&gt; maps;</p><p>2）以字母s, x, ch或sh结尾的单词加es</p><p>e.g. church —&gt; churches, brush —&gt; brushes, bus t buses, box —&gt; boxes</p><p>3）以“辅音字母+y”结尾的单词，变y为i再加es</p><p>e.g. family —&gt; families, country —&gt; countries</p><p>4）以f/fe结尾的词，变f/fe为ves</p><p>e.g. life t lives, knife t knives, wife t wives, thief t thieves, leaf t leaves;</p><p>5）以辅音字母+o结尾无生命的名词，直接加s</p><p>e.g. piano t pianos, photo photos, radio —&gt; radios;</p><p>6）可数名词复数不规则变化</p><p>e.g. child t children, foot t feet, tooth —&gt; teeth, man t men, German t Germans</p><p>7）单复数同形</p><p>e.g. fish — fish, sheep — sheep, cattle t cattle, deer t deer</p></li><li><p>复合名词的复数形式</p><p>1）以名词+名词构成的复合名词变复数时，通常变形最后一个名词为复数</p><p>e.g. a boy friend t boy friends;</p><p>2）以可数名词+介词（短语）构成的复合名词变复数时，把中心名词变复数</p><p>e.g. a father-in-law 一&gt; fathers-in-law;</p><p>3）以man或woman加其它名词构成的复合名词变复数时，前后两个名词都变成复数</p><p>e.g. woman doctor ~&gt; women doctors;</p><p>4）动词/过去分词+副词构成的复合名词变复数时，在词尾加s</p><p>e.g. a grown-up -&gt; grown-ups, a stand-by -&gt; stand-bys.</p></li><li><p>不可数名词量的表示</p><p>不可数名词无复数形式，前面不能直接加a/an,但可以加some, any, a little等修饰词或者用量词表示复数。</p><p>e.g. two pieces of paper, a drop of oil.</p></li><li><p>以-s结尾的名词的数</p><p>1）表示学科、游戏、疾病的名称以及像the United States这样的专有名词，用作单数</p><p>e.g. Physics is the mother of science.</p><p>​        Statistics is a branch of mathematics.</p><p>2）表示衣物（如jeans, trousers, pants, pajamas）, 表示两部分的工具器械（如 scissors, glasses, binoculars, scales, spectales）,表示山脉、群岛、瀑布的专有名词， 某些以-ing结尾的名词earnings, savings, surroundings）,表示某类东西的总称（如 clothes）以及不表示学科的以-ics结尾的词（如politics）,都用作复数。</p><p>e.g. My clothes are dirty.</p><p>​        My earnings this year are not half of yours.</p></li></ol><h3 id="1-1-2-名词的所有格"><a href="#1-1-2-名词的所有格" class="headerlink" title="1.1.2 名词的所有格"></a>1.1.2 名词的所有格</h3><ol><li><p>名词+’s或of+名词，表示……的</p><p>e.g. my father’s friend the title of the novel</p></li><li><p>由and连接的，’s所有格</p><p>e.g. John’s and Anne’s 和 John and Anne’s</p><p>前者表示John和Anne分别所有的，后者表示John和Anne共同所有的。</p></li><li><p>名词所有格表场所、店铺、某人的家等地点，常常省略所有格后面的名词</p><p>a butcher’s， a baker’s， at White’s,   a dentist’s</p></li><li><p>表示时间、距离、重量、集体、世界、国家、城市等无生命的名词也可用，’s构成所有关系</p><p>e.g. twenty minutes’ walk = twenty-minute walk</p><p>one pound’s weight =one-pound weight</p><p>a master’s degree</p><p>a night’s sleep</p><hr><p>以下情况，只能用of</p><ul><li>of词组表示同位关系时（名词属格不可以表示同位关系）</li><li>名词后跟有从句或短语修饰时</li><li>以定冠词加分词或形容词表示一类人时</li><li>代词宾格之前用of词组</li></ul><p>e.g. the city of Rome</p><p>the articles of the students who attended the class yesterday</p><p>the livelihood of the poor</p><p>the struggle of the exploited</p><p>three of us</p></li><li><p>双重所有格of+’s</p><p>双重所有格是一种表示部分概念或含有感情色彩的结构，表示整体中的一个或者部分，它还有强调或突出的作用，其含义是 “其中之一” 或 “其中一部分” 。另外，物主代词不可与 a, an, this, that, these, those, some, any, several, no, each, every, such, as, another, which等限定词一起前置修饰名词，而必须用双重格。结构为：a, an, this, that + 名词+ of + 名词性物主代词。</p><p>e.g. a friend of mine = one of my friends;</p><p>a pig of Shawn‘s = one of Shawn’s pigs.</p><p>a picture of my aunt’s</p><p>each brother of his</p></li></ol><p><strong>例题</strong></p><p>略</p><h2 id="1-2-动词"><a href="#1-2-动词" class="headerlink" title="1.2 动词"></a>1.2 动词</h2><p>动词是表示动作或者状态的词语。动词分为<strong>实义动词</strong>、<strong>系动词</strong>、<strong>情态动词</strong>和<strong>助动词</strong>四类。在一个完整的句子中，一般都有一个动词，要使用第二个动词时，一般借助非谓语动词、从属连接词或者增加从句的形式。</p><p>考査方式：考査情态动词的用法及意义、表推测的情态动词的具体用法；考査动词的时态、语态；考査非谓语动词的特殊用法。</p><p>解题技巧：掌握情态动词、动词的时态、非谓语动词的知识点；根据标志词解答时态题；根据主语与动词的关系解答语态和非谓语动词题。</p><h3 id="1-2-1-动词的时态"><a href="#1-2-1-动词的时态" class="headerlink" title="1.2.1 动词的时态"></a>1.2.1 动词的时态</h3><p><img src="/images/image-20210811230032257.png" alt="image-20210811230032257"></p><p><img src="/images/image-20210811230107452.png" alt="image-20210811230107452"></p><h3 id="1-2-2-动词的语态"><a href="#1-2-2-动词的语态" class="headerlink" title="1.2.2 动词的语态"></a>1.2.2 动词的语态</h3><ol><li><p>主动语态</p><p>主语是动作的执行者。</p><p>e.g. The teacher told a story.</p><p>The girl sang a song.</p></li><li><p>被动语态</p><p>主语是动作的受动者，用be+done形式。</p><p>e.g. A story is told by the teacher.</p><p>The old man was taken to the hospital.</p></li><li><p>不及物动词、系动词无被动形式</p><p>1）不及物动词或不及物动词短语无被动语态</p><p>e.g. appear, die, disappear, end, fail, happen, last, lie, remain, sit, stand, break out, come true, fall asleep, keep silence, lose heart, take place.</p><p>e.g. After the fire, very little remained of my house.</p><p>2）系动词无被动语态</p><p>be 动词 am, is, are；感官系动词 feel, look, smell, sound, taste, seem；变化类系动词 get, become, turn, grow；保持类系动词 keep, stay</p><p>e.g. It seems great.</p><p>Great changes have taken place here since 2008.</p><p>After the fire, nothing remained.</p><p>3）表示某种状态而非动作的动词不能用于被动语态</p><p>如拥有、容纳、适合、缺少、 明白等，这类动词有些是及物动词，常见的有have, hold, posses, contain, suit, fits lack, beg, resemble, cost, fail, benefit, equal 等。</p><p>e.g. The book costs me ten yuan.</p><p>She lacks confidence and courage.</p></li><li><p>被动语态的用法</p><p>1）感官动词主动语态的宾语补足语是不带to的不定式，变为被动语态时，该不定式前要加“to”</p><p>e.g. We saw him play football on the playground.</p><p>He was seen to play football on the playground.</p><p>2）情态动词+ be +过去分词，构成被动语态</p><p>e.g. Coal can be used to produce electricity for agriculture and industry.</p><p>3）表示“据说”或“相信”的词和词组</p><p>e.g. believe, consider, declare, expect, feel, report, say, see, suppose, think, understand.</p><p><img src="/images/image-20210811231301233.png" alt="image-20210811231301233"></p><p>e.g. It was believed that he would succeed.</p><p>He was believed to succeed.</p><p>4）主动形式表示被动意义</p><p>谓语动词为 wash, clean, cook, iron, look, cut, sell, read, wear, feel, draw, write, sell 等。</p><p>e.g. The book sells well.</p><p>This knife cuts easily.</p><hr><ul><li><p>在need, require, want, worth后用动名词表示主动形式。</p><p>e.g. The door needs repairing. = The door needs to be repaired.</p><p>This book is worth reading.</p><p>特殊结构：make sb. heard/understood使别人能听见/理解自己等。</p><p>e.g. Explain it clearly and make you understood.</p></li></ul><p>5）被动形式表示主动意义</p><p>e.g. be determined, be pleased, be graduated from, be prepared for, be occupied in, get married.</p><p>He is graduated from a famous university.</p><p>注意：表示同某人结婚，用marry sb.或get married to sb.均可。</p><p>e.g. He married a rich girl.</p><p>He got married to a rich girl.</p><p>6）当need, want, require, be worth后面接doing时，表示的是被动意义 e.g. Your hair wants cutting.</p><p>The floor requires washing.</p></li></ol><h3 id="1-2-3-非谓语动词"><a href="#1-2-3-非谓语动词" class="headerlink" title="1.2.3 非谓语动词"></a>1.2.3 非谓语动词</h3><p><img src="/images/image-20210812210030567.png" alt="image-20210812210030567"></p><ol><li><p>动词不定式</p><p>1）动词不定式的否定式：not to do</p><p>2）动词不定式的句法功能：在句子中可作主语、表语、宾语、宾语补足语、定语和状语等</p><p>主语：To learn a foreign language is not easy for us.</p><p>动词不定式短语作主语时，常用it作形式主语，真正的主语不定式置于句后。</p><p>e.g. It is not easy for us to learn a foreign language.</p><p>常用句式有：</p><p>It+be+ 名词 +to do</p><p>It takes sb.+some time+to do</p><p>It+be+ 形容词 +of sb. +to do</p><p>常用 careless, clever, good, foolish, honest, kind, lazy, nice, right, silly, stupid, wise等表示赞扬或批评的形容词，不定式前的sb.可作其逻辑主语。</p><p>宾语：常与不定式连用做宾语的动词有decide, want, hope, wish, offer, fail, plan, learn, pretend, refuse, manage, help, agree, promise, prefer,如果不定式宾 语后面有宾语补足语，则用it作形式宾语。</p><p>e.g. Marx found it important to study the situation in Russia.</p><p>只能跟不定式作宾语的动词：</p><p>choose, refuse, need, remember, forget, agree, decide, begin, hesitate, fail, continue 等。</p><p>e.g. He wanted to spend more time with his family.</p><p>疑问词what, how, when, where, who, which和连词whether+不定式作宾语的动词有： ask, consider, understand, discuss, inquire, explain, find out, wonder, loam 等</p><p>表语： My job is to work with people and money. = To work with people and money is my job.</p><p>定语：动词不定式作定语，放在所修饰的名词或代词后。</p><p>e.g. Lily lost the ability to communicate with people.</p><p>状语：He worked day and night to get the money.（表目的）</p><p>He arrived late only to find the train had gone.（表结果）</p><p>They were very sad to hear the news,（表原因）</p></li><li><p> 动名词</p></li></ol><p>   1）  动名词的否定式：not+v-ing</p><p>   2）  动名词的句法功能</p><p>   在句子中可作主语、宾语、表语、定语等。</p><p>   主语：Learning a foreign language is not easy for us.</p><p>   宾语： My brother enjoys playing computer games.</p><p>   部分动词只能跟动名词作宾语：</p><p>   Consider, enjoy, finish, imagine, keep, mind, practice, permit, suggest, forbid, appreciate 等。</p><p>   表语：She is collecting all kinds of balls= Collecting all kinds of balls is his hobby. His favorite sport is running.</p><p>   定语：She tries to find a better learning method.</p><ol start="3"><li><p>分词</p><p>分词的句法功能：在句子中可作表语、定语、补足语和状语等。</p><p>现在分词：动词ing过去分词；动词ed。</p><p>表语：现在分词作表语相当于形容词，形容人用动词ed,形容物用动词ing。</p><p>e.g. The news is exciting.</p><p>She is excited to hear the news.</p><p>定语：分词作定语相当于定语从句，-ed表被动，-ing表主动。</p><p>单个分词作定语时通常放在名词前，分词短语作定语时放在名词之后，相当于一个 定语从句。</p><p>e.g. Polluted air and water are harmful to people’s health.</p><p>Most of the young teachers working in this university are Ph.Ds. = who work in this university.</p><p>在分词作前置定语时，-ed表示完成，-ing表示正在逬行。</p><p>e.g. Boiled water/Boiling water</p><p>Developing country/Developed country</p><p>宾语补足语： see, watch, hear, feel, find, get, keep, notice, observe, listen to, look at, leave, catch等可跟现在分词、过去分词作宾语补足语。</p><p>e.g. I heard Mary singing in the music room.</p></li><li><p>情态动词</p><p>1）情态动词在句中放在谓语动词之前；谓语动词前若有助动词则在助动词之前； 疑问句中，情态动词则在主语之前</p><p>e.g. You must obey the school rules.</p><p>2）情态动词无人称和数的变化，情态动词后面跟的动词需用原形，其否定式是 在情态动词后面加“not”。个别情态动词有现在式和过去式两种形式：过去式用来表 达更加客气、委婉的语气，时态性不强，可用于过去、现在或将来</p><p>He minght go to shool himself.</p><p>3）情态动词不能单独构成谓语，只能和行为动词一起构成谓语成分；用法是情态动词+动词原形</p><p>May I have your name?</p><p>4）情态动词表推测</p><p>must对过去事实的推测,may/might对将来的推测,can/could否定、疑问句中的推测； 否定句中用can’t/couldn’t不可能，may not/might not可能不。</p><p>e.g. The road is wet. It must have rained last night, didn’t it?</p><p>It is cold in the room. They must have turned off the heating.</p><p>5）表示对过去情况的推测，用情态动词+have done；对现在的推测用，情态动 词+be/v；对将来情况的推测，用情态动词+v</p><p>might have done可能已经做了某事，但实际上没有；should have done过去本应 该做某事，实际上却没做；needn’t have done过去本不必做，却做了 ； can/could have done本来能够做某事，而实际上未做。</p><p>e.g. You could have done better, but you were too careless.</p><p>He might have given him more help.</p><p>She needn’t have arrived before five o’clock.</p></li></ol><p><strong>例题</strong></p><p>略</p><h2 id="1-3-形容词-副词"><a href="#1-3-形容词-副词" class="headerlink" title="1.3 形容词/副词"></a>1.3 形容词/副词</h2><p>形容词主要用来修饰名词和代词，说明人或事物的性质、特征或状态。一般放在它 所修饰的名词前作定语，也可独立作表语或宾语补足语等。副词主要修饰动词、形容词、 整个句子、其它副词等，在句中充当状语等。副词可分为地点副词、频率副词、程度副词、方式副词。</p><p>考査方式：考査形容词作定语、表语，副词修饰动词、形容词或整个句子作状语等； 考查多个形容词修饰的排序原则；-ed和-ing形容词的区别；形容词和副词的原级、比 较级和最高级。</p><p>解题技巧：熟练掌握形容词在句中所做的成分，便能快速解出此类型题；牢记多个 形容词修饰的排序原则口诀和-ed /-ing形容词的区别；由标志词来判断词级。</p><p>1、形容词的形式与用法</p><ol><li><p>形容词的形式</p><p>一般以-able, -al, -ful, -ic, -ish, -less, -ous, -y 等结尾；</p><p>特殊的以ly结尾。</p><p>e.g. friendly, deadly, lovely, only, likely, lively, ugly, brotherly.</p></li><li><p>形容词的用法</p><p>the+形容词，表示一类人或事物，相当于名词，用作主语及宾语；</p><p>e.g. The old often think of old things.</p><p>少数形容词只能作表语，不能作定语。</p><p>e.g. ill, asleep, awake, alone, alive, well, worth, glad, unable, afraid.</p></li><li><p>多个形容词的修饰顺序</p><p>原则：限定词+好大颜国材</p><p>限定词（冠词/物主代词/指示代词/数词）+好（描绘性形容词）+大（大小/长 短/高低/新旧/年龄）+颜（颜色）+国（国家/产地/出处）+材（材料）+用途、类 别+名词</p><p>e.g. a good small red American iron cup.</p></li><li><p>以-ed和-ing词缀结尾的形容词</p><p>1）以-ed结尾的形容词通常修饰人，如果所修饰的名词是物，那它指的也是与 该事物相关的人。</p><p>e.g. He feels excited. / He had a pleased smile on his face.</p><p>2）以-ing结尾的形容词修饰物，表示事物的性质或特征，若用来说明人则表示 此人具有此性质或特征。</p><p>e.g. The story is interesting. / He is an interesting man.</p></li></ol><p>2、副词的用法</p><p>3、    形容词变副词的一般规律</p><ol><li><p>一般情况下直接加ly</p><p>e.g. careful -&gt; carefully, quiet t quietly;</p></li><li><p>变e为y</p><p>e.g. possible t possibly, comfortable comfortably;</p></li><li><p>以y结尾，发音为/i/,变y为i加ly,发音为/ai/直接加ly</p><p>e.g, easy easily; shy t shyly;</p></li><li><p>形容词和副词同形的词有：fast, high, hard, late等</p><p>注意：区分hard困难的/地和hardly几乎不。</p></li></ol><p>4、形容词、副词的原级、比较级和最高级</p><p><img src="/images/image-20210812213040827.png" alt="image-20210812213040827"></p><p><img src="/images/image-20210812213622602.png" alt="image-20210812213622602"></p><p>5、形容词、副词的比较级、最高级变化规则</p><p><img src="/images/image-20210812213842379.png" alt="image-20210812213842379"></p><p>6、比较级和最高级的用法</p><ol><li><p>as many/few+可数名词复数+as或as much/little（少的）+不可数名词+as,前者 描述数目上的接近，后者描述量的相近</p><p>e.g. You may borrow as many books as you can.</p><p>“Drink as much water as you can.” the doctor said to him.</p></li><li><p>主语+比较级+than any other…表示主语所描述的事物比其他任何一个都……， 比较级形式表示最高级含义</p><p>e.g. Li Ming is much cleverer than any other student in their class. 注意：若比较范围不同，than后应用any+可数名词的复数形式+其他。</p><p>e.g. China is larger than any countries in Africa.</p></li><li><p>否定词与形容词或副词的比较级连用，如not, never等，表示最高级含义，意为：再没有比……更……的了</p><p>e.g. I have never heard such an interesting story.</p></li><li><p> no+比较级+than表示对两个比较对象都进行否定，可由neither…nor…结构来改写 </p></li></ol><p>   e.g. I’m no more foolish than you. = Neither I nor you are foolish.</p><ol start="5"><li><p>not more+比较级+than表示在程度上前者不如后者</p><p>e.g. This book is not more interesting than that one. =The book is less interesting than that one.</p></li><li><p> 形容词比较级+than+形容词，意为：与其……倒不如……</p></li></ol><p>   e.g. Jack is much harder than clever.</p><ol start="7"><li><p>would rather…than, prefer…to…, prefer to do…rather than…这三个句型表示宁愿……而不愿……；喜欢……胜过……；宁愿做……而不愿做……的含义。虽无比较级 形式，但表示比较级含义</p><p>e.g. He preferred to go out rather than stay home.</p></li></ol><p><strong>例题</strong></p><p>略</p><h2 id="1-4-介词"><a href="#1-4-介词" class="headerlink" title="1.4 介词"></a>1.4 介词</h2><p>介词一般位于名词或代词等之前，表示名词、代词等与句中其他词的关系。</p><p>考查方式：考查介词的位置（介词+名词）；考查介词的介宾搭配；考查常用介词 的意义。</p><p>解题技巧：熟练掌握介词知识点相关规律知识及各个介词的意义。</p><p>1、常用的介词</p><ol><li><p>表时间的介词</p><p>at表示某一具体的时间点。</p><p>e.g. at 3 o’clock</p><p>in泛指在一般意义的上午、下午或晚上，以及星期/月份/季节/年份等较长的时间。</p><p>e.g. in the morning, in 2004, in two weeks</p><p>on表示在具体的某一天及某天的上午/下午/晚上。</p><p>e.g. on Sunday, on Sunday morning</p><p>by表示不迟于某个时间。</p><p>e.g. by now</p><p>during表示在时间段内，自始至终的时间。</p><p>e.g. during 2016</p><p>for表示时间的累计。</p><p>e.g. for ten years</p></li><li><p>表地点的介词</p><p>at表示在小地方或在某处。</p><p>e.g. at police office</p><p>in表示在大地方及在内部或某范围内。</p><p>e.g. in Beijing, in the hospital</p><p>on表示在…. 上面或接壤及在左、右边。</p><p>e.g. on the table, on the left side</p><p>outside表示某范围之外。</p><p>e.g. outside the home</p><p>under表示在……底下。</p><p>e.g. under a chair </p><p>by表示靠近。</p><p>by the window</p></li><li><p>表示方式、方法的介词</p><p>with 一般表示用具体的工具和手段。</p><p>e.g. with hands</p><p>也用某种语言/颜色/材料。</p><p>e.g. in Chinese</p><p>by表示以……方法、手段或泛指乘坐某种交通工具。</p><p>e.g. by bike</p></li><li><p>表示原因的介词（词组）</p><p>e.g. because of rain</p><p>for表示动作或活动的目的、意图。</p><p>e.g. for sale</p><p>out of表示起源、缘由、出于。</p><p>e.g. out of work</p></li></ol><p>2、介词短语</p><p>介词短语相当于形容词或副词，在句中可作状语、定语和表语。</p><p>e.g. Anne came down the stairs.（状语）</p><p>The woman with a long hair is from the America.（定语）</p><p>The doctor is now with the patients.（表语）</p><p><img src="/images/image-20210812215327697.png" alt="image-20210812215327697"></p><p>3、介词短语的句法和功能</p><p>介词和其他宾语构成介词短语，其用法如下:</p><ol><li><p>作定语</p><p>e.g. The girl in red is my sister.</p></li><li><p>作状语</p><p>e.g. Can you say it in English?</p></li><li><p>作表语</p><p>e.g. The teacher is in the office.</p></li><li><p>作补语</p><p>e.g. I always find her at her studies.</p></li><li><p>作介词的宾语</p><p>e.g. I saw her from across the street.</p></li></ol><p><strong>例题</strong></p><p>略</p><h2 id="1-5-代词"><a href="#1-5-代词" class="headerlink" title="1.5 代词"></a>1.5 代词</h2><p>代词是指代替名词或名词短语的词。代词可以分为人称代词、指示代词、疑问代词、 连接代词和不定代词。</p><p>考査方式：考查人称代词在句中的成分（作主语、宾语、定语等）；不定代词的辨析。 解题技巧：掌握人称代词的格，分析句中所缺成分便能得出答案；熟练掌握常用的 不定代词的用法。</p><p>1、人称代词</p><p><img src="/images/image-20210812215931746.png" alt="image-20210812215931746"></p><p><img src="/images/image-20210812220000651.png" alt="image-20210812220000651"></p><p>注意：反身代词表示我自己、你自己、他自己；此类型重点考查固定搭配：dress oneslf, teach onself, by oneself 等。</p><p>2、指示代词</p><ol><li><p>this/these; that/those</p><p>this/these表近指或下文将提及之事；that/those表远指或前文刚提之事。this/fhat 指单数；these/those指复数。</p></li><li><p>one/ that/ it</p><p>one表示泛指；that和it表示特指；that与所指名词为同类，但不是同一个；it与 所指名词为同一个。</p></li></ol><p>3、疑问代词和连接代词</p><ol><li>疑问代词有：what, where, what, who, when 等</li><li>连接代词有：who, where, when, what, who, which, wherever, whatever 等</li></ol><p>4、不定代词</p><ol><li><p>some/any</p><p>some用于肯定句、建议/请求的疑问句，any用于否定句</p></li><li><p>each/ every</p><p>each强调个体/个别，可做形容词、代词，常与of连用;every强调整体，仅为形容词</p></li><li><p>both/neither/either</p><p>both指两者都；neither指两者都不；either指两者选其一</p></li><li><p>all/none</p><p>all指三者及以上都；none指三者及以上都不</p></li><li><p>another/other/the other</p><p>another指三者及以上的另一个；other指另外的、其它的；the other指两者中的另一个。</p></li></ol><p><strong>例题</strong></p><p>略</p><h2 id="1-6-固定搭配"><a href="#1-6-固定搭配" class="headerlink" title="1.6 固定搭配"></a>1.6 固定搭配</h2><p>固定词组搭配是单项选择题中比较常见的考点。考查固定词组搭配时，常考介词、 同义词组固定搭配的辨析，以及冠词、数词相关的固定搭配。因此需要熟知常考、常用 固定词组搭配以及常用的英语表达方式。</p><p>1、近年真题中的固定词组搭配</p><p><img src="/images/image-20210812221650847.png" alt="image-20210812221650847"></p><p><img src="/images/image-20210812221914681.png" alt="image-20210812221914681"></p><p>2、常见的固定词组搭配补充</p><p><img src="/images/image-20210812222044159.png" alt="image-20210812222044159"></p><p><img src="/images/image-20210812222241264.png" alt="image-20210812222241264"></p><p><img src="/images/image-20210812222315270.png" alt="image-20210812222315270"></p><p>3、冠词相关的固定搭配</p><p>冠词作为一种虚词，在英语中只能和名词一起使用。英语中的冠词包括不定冠词a/ an以及定冠词the。</p><p>考查方式：考査a/an区别的用法；考查句中名词的泛指/特指；考査名词前有无定冠词the；考査冠词搭配的固定词组。</p><p>解题技巧：先根据不定冠词和定冠词的特点和句中所要限定的词，确定使用不定冠词还是定冠词；再根据不定冠词和定冠词各自的规则，确定答案。</p><ol><li>不定冠词a/an （表泛指）</li><li>定冠词the （表特指）</li></ol><p><img src="/images/image-20210812222949413.png" alt="image-20210812222949413"></p><ol start="3"><li><p>冠词词组搭配</p><p>1）不定冠词</p><p><img src="/images/image-20210812223331354.png" alt="image-20210812223331354"></p><p>2）定冠词</p><p><img src="/images/image-20210812223213556-1628778781658.png" alt="image-20210812223213556"></p><p>3）零冠词</p><p><img src="/images/image-20210812223432943.png" alt="image-20210812223432943"></p></li><li><p>数词相关的固定搭配</p><p>数词是表数量和顺序的词。数词可以分为两类：基数词和序数词。基数词表数量； 序数词表顺序。</p><p>考查方式：考査基数词中hundred, million, billion和dozen的用来指具体明确数 目和指计数概念两种不同用法的考査；序数词+名词所表示的单复数概念；分数的读法； 年份和年代。</p><p>解题技巧：熟练掌握数词的语法知识点。</p><p>1）基数词常考点</p><ol><li><p>hundred, million, billion, dozen用来指具体明确的数目时不用复数；</p><p>e.g. three hundred                             four million</p></li><li><p>计数概念后接 of 时用复数，dozens/scores/hundreds/thousands/millions of 等。</p><p>e.g. thousands of 数千的 hundreds of 成百上千的</p></li></ol><p>2）序数词常考点</p><ol><li><p>序数词的一般形式是“基数词+th “；</p><p>e.g. sixth          seventh</p></li><li><p>需要特殊记忆的序数词有：first, second, third, fifth, eighth, ninth, twelfth；</p></li><li><p>the+序数词+名词单数结构作主语时，谓语动词用单数形式；</p><p>e.g. The third girl with long hair is my little sister</p></li><li><p>the+序数词，强调顺序；a/an+序数词，表示又……再……。</p><p>e.g. His parents have three children, and the third one is a girl.表示第三个是女孩</p><p>His parents have two children, but they want a third one,表示在前两个孩子的基础 上，想再要一个。</p></li></ol><p>3）分数/百分数的表达</p><ol><li><p>分数借助“基数词+序数词”的形式表达，分子用基数词表示，分母用序数词表示；当分子＞1时，分母序数词要用复数</p><p>e.g. a /one fourth 四分之一        three fourths 四分之三</p></li><li><p>百分数用percent表示，无复数形式</p><p>e.g. 90%通常读成90 percent；另可表达为nine in ten</p></li></ol><p>4）年份和年代的表达</p><p>区分年份和年代的读法。</p><p>e.g. 1990 年读成 in 1990, 20 世纪 90 年代读成 in the 1990s</p></li></ol><h2 id="1-7-近义词辨析"><a href="#1-7-近义词辨析" class="headerlink" title="1.7 近义词辨析"></a>1.7 近义词辨析</h2><p>英语中常有一些词，它们的意思相似，但其侧重点却有所不同，如最常见的spend 和cost, 这类词也是英语考试出题的重点，考生需要掌握最常见近义词各自不同的特点, 才能快速准确的答题。</p><p>1、近年真题中的近义词</p><ol><li><p>avoid/escape均有“避免、逃避”的意思</p><p>avoid v.指努力避开被认为是困难和危险的根源</p><p>e.g. The mistake could have been avoided.</p><p>escape v.指脱离或避开即将来临或近在眼前的伤害、危险、<em>灾祸</em></p><p>e.g. She managed to escape from the big fire.</p></li><li><p>accommodate/contain 均有“容纳”的意思</p><p>contain v.强调一个整体内含有某些组成成分</p><p>e.g. The drink contains alcohol.</p><p>accommodate v.指宽松的容纳能力</p><p>e.g. Over 80 minutes can be accommodated in one CD.</p></li><li><p>forecast/predict均有“预言、预测”的意思</p><p>forecast v,根据明显的证据或迹象对近期可能发生事态的预言</p><p>e.g. Economists are forecasting a recovery in the economy,</p><p>predict v.对远期要发生的事态的预言或预测，且证据或迹象不确定</p><p>e.g. The trial is predicted to last for months.</p></li><li><p>complex/complicated 均有”复杂的”意思</p><p>complex adj,指构成机器的零件/事件的因素/数学题的元素多，相互的关系复杂</p><p>e.g. Complex machinery is difficult for human to operate.</p><p>complicated adj.具有complex的一切意义，但更强调复杂得难以解释或理解</p><p>e.g. The instruction is extremely complicated to understand.</p></li><li><p>arrange/plan均有“安排”的意思</p><p>plan.指为做某事事先做出的详细的精心安排</p><p>e.g. Both sides agreed to a detailed plan for keeping peace, </p><p>arrange v.指安排、准备</p><p>e.g. The part is soon arranged.</p></li><li><p>elaborate/sophisticated 均有“复杂的”意思</p><p>elaborate adj,指计划/制作/装饰精心设计的、阐述详尽的、精美的、精密的</p><p> e.g. The wife has prepared an elaborate supper.</p><p>sophisticated adj.指系统/结构/流程复杂的、精密的；人老练的、世故的 </p><p>e.g. It is a highly sophisticated computer.</p></li><li><p> immediate/straight/direct 均有“直的”的意思</p></li></ol><p>   immediate adj,直接的，尤指直系亲属或直接上司</p><p>   e.g. immediate family </p><p>   straight adj.指径直的、清晰明了的</p><p>   e.g. keep straight </p><p>   direct adj,指笔直的、直截了当的</p><p>   e.g. direct selling.</p><ol start="8"><li><p>variety/diversity均有”种类多”的意思</p><p>variety n.侧重同一种类东西的多样性</p><p>e.g. I was surprised by the variety of flowers on show, </p><p>diversity n.侧重多元化，即在本质/性质上完全不同的一些东西</p><p>e.g. There is a need for greater diversity in education.</p></li><li><p>class/category均有”种类”的意思</p><p>class v./n.指门类、种类或优劣等级；用于指动植物的分类时，表示“纲”</p><p>e.g. Immigrant workers can be classed as aliens.</p><p>category n.指在某一类分类系统中特别定义的部分，是书面用词</p><p>e.g. The result of survey can be divided into three categories. </p></li><li><p>include/contain/comprise 均有“包括、包含”的意思 </p><p>contain v,可用于表示包含物的全部或部分</p><p>e.g. The drink contains alcohol.</p><p>include v,则只指包含的一部分</p><p>e.g. The tour includes a visit to the Great Wall.</p><p>comprise v.指由许多部分构成一个整体</p><p>e.g. Twelve departments comprise this university.</p></li><li><p>bundle/attach/pack 均有“捆、附”的意思</p><p>bundle v,指收集、归拢、额外免费提供，还指成捆出售的电脑软硬件</p><p>e.g. A further six applications are bundled with the computer.</p><p>attach v.指附加、附带、张贴标签等</p><p>e.g. Attach your photo at the front of your letter.</p><p>packv.指打包、把东西紧压便于折叠</p><p>e.g. He packed some things into the bag and went for a tour.</p></li><li><p>abstract/summary均有“摘要、梗概”的意思</p><p>abstract n,侧重学术/法律方面文章的摘要</p><p>e.g. The abstract of a thesis is very important.</p><p>summary n.侧重把一篇文章/ 一本书的内容或主旨加以概述</p><p>e.g. This is a two-page summary of government report.</p></li><li><p>expense/spending/consumption 均有“花费、消费”的意思 </p><p>expense n.指开支、费用，在财务报表中用得较多</p><p>e.g. The building was transformed at great expense, </p><p>spending n.指政府或其他机构的开支、花销</p><p>e.g. It is very necessary to reduce public spending, </p><p>consumption n.多指能量/食物/材料的消耗</p><p>e.g. Oil consumption always increases in cold weather.</p></li><li><p>consequence/outcome/harvest 均有“结果、后果”的意思</p><p>consequence n.   般是指不好的结局，常译成“后果”</p><p>e.g. The decision could have a serious consequence fbr the future IT business, </p><p>outcome n.常指某项活动、比赛或者悬而未决的事情最后见分晓、见输赢</p><p>e.g. The athletes are waiting for the final outcome of the competition, </p><p>harvest n.更加侧重“收获”</p><p>e.g. Farmers are very busy during harvest seasons.</p></li><li><p>initially/originally 均有“首先”的意思</p><p>initially adv.强调在起始阶段，常与数字或顺序有关</p><p>e.g. Initially, the teacher didn’t agree with him.</p><p>originally adv.表最初时，强调的是起源，原本的事实或情况是怎么样</p><p>e.g. The school was originally very small.</p></li><li><p>intake/input均有“输入、摄入”的意思</p><p>input n.指电子设备的信息输入，通过感官获得的信息/想法/建议的投入</p><p>e.g. His specialist input is very useful for us.</p><p>intake n.指营养物质的摄入、空气的吸入、学校/公司人员的纳入</p><p>e.g. Also, try to limit your intake of caffeine and alcohol.</p></li><li><p>entry/entrance均有“进入、允许进入、入口”的意思 </p><p>entrance n.为一般用语</p><p>e.g. There were people at the entrance giving out leaflets, </p><p>entry n,较为正式，还表示词条，参加竞赛的人/物等意思 </p><p>e.g. Entry to this prize draw is limited to UK residents.</p></li></ol><p>2、易混淆的词</p><ol><li><p>deceive/perceive</p><p>Deceive欺骗、蒙骗</p><p>e.g. He deceived his friends about his income.</p><p>Perceive感觉、察觉、领悟</p><p>e.g. She has perceived the danger.</p></li><li><p>receive/receipt</p><p>Receive收到、接待</p><p>e.g. Our TV receives well since we had a new antenna put on. </p><p>Receipt收据、发票</p><p>e.g. I asked for a receipt.</p></li><li><p>result/insult</p><p>Result结果、效果</p><p>e.g. The result was quite opposite to what we had expected. </p><p>Insult侮辱、冒犯</p><p>e.g. He turned crimson under the insults.</p></li><li><p>deduce/reduce/reproduce</p><p>Deduce推论、演绎</p><p>e.g. On the basis of evidence we deducted that he was guilty.</p><p>Reduce减少、降低</p><p>e.g. He won’t reduce the rent of our house.</p><p>Reproduce复制、繁殖</p><p>e.g. Rabbits reproduce quickly.</p></li><li><p>compose/dispose/propose</p><p>Compose组成、构成、创作</p><p>e.g. These twelve men are believed to compose the jury. </p><p>Dispose处理、布置</p><p>e.g. He disposed his books on the shelves.</p><p>Propose提议、求婚</p><p>e.g. They proposed to make arrangement beforehand.</p></li><li><p>radius/radiate</p><p>Radius半径</p><p>e.g. He has visited every shop within a radius of two miles.</p><p>Radiate发射出（光、热等）；向四周伸出</p><p>e.g. The sun radiates light and heat.</p></li><li><p>assist/ consist/ resist/ insist/ persist</p><p>Assist援助</p><p>e.g. He assisted in designing the new bridge.</p><p>Consist组成、构成</p><p>e.g. A university consists of teachers, administrators and students.</p><p>Resist 抵制、对立</p><p>e.g. Lack of proper nourishment reduces their power to resist disease.</p><p>Insist 坚持要求、坚持认为</p><p>e.g. I will have another glass if you insist.</p><p>Persist 坚持、存留</p><p>e.g. On the tops of very high mountains snow persists throughout the year.</p></li><li><p> statue/status</p></li></ol><p>   Statue雕像</p><p>   e.g. statue of liberty</p><p>   Status地位、身份、情形、状况</p><p>   e.g. Age has status in the villages.</p><ol start="9"><li><p>affect/effect/infect</p><p>Affect影响</p><p>e.g. The tax increases have affected us all.</p><p>Effect效果、影响</p><p>e.g. When does the new law come into effect?</p><p>Infect感染、影响</p><p>e.g. Mary’s high spirits infected all the girls in the class.</p></li><li><p>conserve/deserve/preserve</p><p>Conserve保护、保藏、保存</p><p>e.g. Conserve your energy, you’ll need it.</p><p>Deserve应受、值得</p><p>e.g. What crime have they committed to deserve such cruelty?</p><p> Preserve保护、维持</p><p>e.g. We must preserve our natural resources.</p></li><li><p>spontaneous/simultaneous</p><p>Spontaneous自发的、无意识的</p><p>e.g. To be thoroughly enjoyed, reading must be entirely spontaneous. </p><p>Simultaneous同时发生的</p><p>e.g. We need a simultaneous interpreter.</p></li></ol><p>3、常见的近义词补充</p><p><img src="/images/image-20210812230812780.png" alt="image-20210812230812780"></p><h2 id="1-8-形似词辨析"><a href="#1-8-形似词辨析" class="headerlink" title="1.8 形似词辨析"></a>1.8 形似词辨析</h2><p>英语词汇中存在着许多词形相似，但是意思不同的单词，如favorable和favorite, 是英语考试出题的重难点，需要考生精准掌握并能准确辨别词义。</p><p>1、近年真题中的形似词</p><p><img src="/images/image-20210812231036542.png" alt="image-20210812231036542"></p><p><img src="/images/image-20210812231059465.png" alt="image-20210812231059465"></p><p>2、常见的形似词补充</p><p><img src="/images/image-20210812231145105.png" alt="image-20210812231145105"></p><p><img src="/images/image-20210812231227914.png" alt="image-20210812231227914"></p><h2 id="1-9-词义辨析"><a href="#1-9-词义辨析" class="headerlink" title="1.9 词义辨析"></a>1.9 词义辨析</h2><p>词义辨析类题目中，需要考生从选项所给的四个词语中选择最符合题目原话中的意思的词，即需要考生对选项中的词义加以辨析，涉及到词的性质有名词、动词、形容词、 副词等。对于上述词性的一些基础知识，在之前的篇幅中已详细介绍，在这里就不加以赘述了。</p><h2 id="1-10-词组辨析"><a href="#1-10-词组辨析" class="headerlink" title="1.10 词组辨析"></a>1.10 词组辨析</h2><p>与词义辨析类题目类似，区别是在该类题目中是要对题目选项中给定的词组的意思加以辨析，并从中选出最符合题意的一项。在平时对词汇的学习中，需要关注每个单词在短语之中的一些用法，达到对词组积累记忆的作用。</p><h2 id="1-11-词形辨析"><a href="#1-11-词形辨析" class="headerlink" title="1.11 词形辨析"></a>1.11 词形辨析</h2><p>词形辨析类题目通常需要辨析同一词根衍生出不同词性的词汇，以及对于同一词性 的单词的不同形式（对于名词，考虑应使用其单数还是复数形式；对于动词，使用哪种 时态和语态；以及形容词形式和副词形式的甄别使用等）。</p><p>1、近年真题中的同词缀单词</p><p><img src="/images/image-20210812231624054.png" alt="image-20210812231624054"></p><p><img src="/images/image-20210812231705862.png" alt="image-20210812231705862"></p><p>2、常见的词缀补充</p><p><img src="/images/image-20210812231731881.png" alt="image-20210812231731881"></p><p><img src="/images/image-20210812231836118.png" alt="image-20210812231836118"></p><h1 id="2-单项选择之语法"><a href="#2-单项选择之语法" class="headerlink" title="2. 单项选择之语法"></a>2. 单项选择之语法</h1><p>语法学习是提高英语水平的关键，词汇只有通过一定语法规律组成句子才具有完整的意义。在银行招聘考试中，单项选择题、完形填空题均涉及语法知识点的考查。尤其 对于名词、动词、形容词、副词及从句的考査。另外历年银行真题中对于虚拟语气、倒装结构以及强调句型也有考查。因此，考生在备考过程中需要重视语法知识的积累和提升。</p><p><img src="/images/image-20210813120449617.png" alt="image-20210813120449617"></p><h2 id="2-1-名词性从句"><a href="#2-1-名词性从句" class="headerlink" title="2.1 名词性从句"></a>2.1 名词性从句</h2><p><strong>在句子中起名词作用的句子叫名词性从句</strong>。名词性从句的功能相当于名词词组，它在复合句中能担任主语、宾语、表语、同位语、介词宾语等。</p><p>考查方式：名词性从句的连接词和定语从句的关系词混搭；考查名词性从句的连接词。</p><p>解题技巧：掌握名词性从句和定语从句的区别以及两个从句各自的连接词及含义； 如何解名词性从句题：确定从句类型——从句成分是否缺——缺什么补什么，不缺用 that,表达“是否”意义时用whether或if。</p><ul><li><p>名词性从句与定语从句的区别</p><p>例：What I do is to get a higher salary.（名词性从句充当名词作用）</p><p>This is the pen that I bought yesterday,（定语从句修饰名词）</p></li></ul><p>1、名词性从句的连接词</p><p><img src="/images/image-20210813120913340.png" alt="image-20210813120913340"></p><p>2、名词性从句的四种类型</p><p><img src="/images/image-20210813121034830.png" alt="image-20210813121034830"></p><ol><li><p>主语从句</p><p>基本构成：主语从句+谓语动词+其他</p><p>主语从句的时态不受主句的时态影响和限制。</p><p>主语从句通常由从属连词that, whether, if和连接代词what, who, which, whatever, whoever以及连接副词how, when, where, why等词引导。that在句中无实际意义，只起连接作用；连接代词和连接副词在句中既保留自己的疑问含义又起连接 作用，在从句中充当从句的成分。</p><p>e.g. Whether she comes or not makes no difference.</p><p>Who will be our monitor hasn’t been decided yet.</p><p>主语从句的特殊形式：it作形式主语，把主语从句放在句末，有以下几种类型：</p><p>1）It is + 名词 + 主语从句 It is a fact/ an honor that…</p><p>e.g. It’s a great pity that they didn’t get married.</p><p>It’s a good thing that you were insured.</p><p>2）It is + 形容词 + 主语从句     It is natural /obvious/possible that…</p><p>e.g. It’s splendid that you passed your exam.</p><p>It’s strange that there are no lights on.</p><p>3）It + 过去分词 + 主语从句     It is reported/said that…</p><p>e.g. It is reported that problems cannot be solved by traditional methods.</p><p>It is said that Jack will fly to Beijing next month.</p><p>4）(1)  It + 不及物动词 + 主语从句    It seems/happened/has turned out that…</p><p>e.g. It seemed that he didn’t tell the truth.</p><p>It happened that I was out when he called.</p><p>注意：在主语从句中用来表示惊奇、不相信、惋惜、理应如此等语气时，谓语动词 要用虚拟语气(should)+do,常用的句型有：</p><p>It is necessary (important, natural, strange, etc.) that …</p><p>It is a pity (a shame, no wonder, etc.) that…</p><p>It is suggested (requested, proposed, desired, etc.) that…</p></li><li><p>宾语从句</p><p>基本构成：主语+及物动词+宾语从句</p><p>1）由连接词that引导的宾语从句，that在句中不作任何成分，在口语或非正式 的文体中常被省去，但如从句是并列句时，第二个分句前的that不可省。</p><p>e.g. He has told me that he will go to Shanghai tomorrow.</p><p>We must never think （that） we are good in everything while others are good in nothing.</p><p>注意：在 demand, order, suggest, decide, insist, desire, request, command, doubt等表示要求、命令、建议、决定等意义的动词后，宾语从句常用（should）+动词原形。</p><p>e.g. I insist that she （should） do her work alone.</p><p>2）用 who, whom, which, whose, what, when, where, why, how, whoever, whatever, whichever等关联词引导的宾语从句相当于特殊疑问句，应注意句子语序要用 陈述语序。</p><p>e.g. I want to know what he has told you.</p><p>She will give whoever needs help a warm support.</p><p>3）whether或if引导的宾语从句，表示是否，在口语或间接引语中两者可以互 换使用，其主语和谓语的顺序也不能颠倒，仍保持陈述句语序。</p><p>e.g. I wonder whether the news is true or not.</p><p>I want to know if you can pass the contest.</p><p>whether引导的从句常可以与连词or或or not直接连用，而if 一般不能。当宾语从 句提到句首时，只能用whether引导，而不能用if。whether可以引导带to的不定式，if 则不能。whether及其引导的成分可放于介词之后，作介词的宾语，但if不能。</p><p>4）宾语从句的时态：主现从不限，主过从必过，,客观事实永不变。</p><p>当主句动词是现在时，从句的时态可根据实际情况而定；</p><p>e.g. I know （that） he studies English every day.（从句用一般现在时） he studied English last term.（从句用一般过去时） he will study English next year.（从句用一般将来时） he has studied English since 1990.（从句用现在完成时） 当主句动词是过去时态（could, would除外）从句则要用相应的过去时态； e.g. The teacher told us that Tom had left us for America.</p><p>She said that she had been to the beach many times.</p><p>当从句表示的是客观真理、科学原理、自然现象则从句仍用一般现在时。</p><p>e.g. All of us know that the moon moves round the earth.</p><p>My teacher told us that light travels much faster than sound.</p><p>5）否定转移：当主句动词是think, believe, suppose, imagine等时，从句中的谓语动词的否定必须转移到主句中去，主句的主语必须为第一人称。</p><p>e.g. I don’t believe he will do so.</p><p>We don’t think that watching movie is a good way to relax.</p><p>6）动词 make, find, think, feel, consider, believe 等后面有宾语补足语的时， 需用it作形式宾语，而将that引导的宾语从句后置。</p><p>e.g. I find it crucial that we should keep calm in danger.</p><p>He has made it clear that the meeting will not be postponed.</p></li><li><p>表语从句</p><p>基本构成：主语+系动词+表语从句</p><p>1）表语从句位于系动词be, seem, appear等后，有时用as if / though和 because引导。</p><p>e.g. My idea is that you should make good use of your time.</p><p>It seems that no one knew what had happened.</p><p>2）由从属连词that, whether等，if不能引导表语从句。</p><p>e.g. The question is whether we can make good preparation in such a short time.</p><p>The problem is whether we can solve the problem.</p><p>3）由 who, what, which, when, where, why, how 等引导。</p><p>e.g. The problem is who will stay.</p><p>That is how I figure it.</p><p>4）why引导表语从句，强调结果。</p><p>e.g. You don’t love me. That’s why you go away.</p><p>The reason why 从句 +be+thato</p><p>e.g. The reason why he was late was that he missed the train by one minute this morning, because引导表语从句，强调原因。</p></li><li><p>同位语从句</p><p>跟在名词后用以说明其前面名词的具体内容的作同位语的从句。</p><p>通常放在 answer, belief, decision, evidence, fact, information, news, truth, suggestion等名词后。</p><p>e.g. The king’s decision that the prisoner would be set free surprised all the people. The order that all the soldiers should stay still is given by the general.</p><p>同位语从句常用的引导词为that,也用where, when, which, who, what, why 等疑问词。</p><p>e.g. I have no idea when she will be back.</p><p>I don’t know which dictionary is hers.</p><p>同位语从句与名词之间有时会出现插入成分，形成间隔性同位语从句。</p><p>e.g. We’ve just heard a warning on the radio that a typhoon may be on its way.</p></li></ol><h2 id="2-2-定语从句"><a href="#2-2-定语从句" class="headerlink" title="2.2 定语从句"></a>2.2 定语从句</h2><p>定语从句是修饰名词、代词的从句，相当于“……的”名词。被修饰的词称为“先行词”。定语从句通过关系词连接，关系词又分为关系代词和关系副词。关系代词在从 句中充当成分，关系副词在从句中不充当成分。</p><p>考查方式：考査关系代词与关系副词的区别用法；考査关系代词that / which的区别； 考查混合其它从句的连接词。</p><p>解题技巧：掌握定语从句关系代词和关系副词的区别；根据解题思路三步法解题: 先行词——从句成分完整与否——确定关系词。</p><p>1、限制性定语从句</p><p>引导词：分为关系代词和关系副词</p><p><img src="/images/image-20210813155810176.png" alt="image-20210813155810176"></p><p><strong>限制性定语是指定语从句紧跟它所修饰的中心名词或代词之后，没有逗号分开</strong>。</p><ol><li><p>关系代词引导的定语从句</p><p>1）that指代人、事物，作主语、宾语，做宾语时可以省略</p><p>e.g. The train that has just left is for Shanghai.</p><p>2）who指代人，做主语、宾语</p><p>e.g. The girl who is playing the piano is my daughter.</p><p>3）whom指代人，做动宾、介宾，可以省略</p><p>e.g. The man whom you met just now is my brother. </p><p>4）which指代事物，做主语、宾语，做宾语可以省略</p><p>e.g. The flowers which grow in the garden are very beautiful.</p><p>5）whose指代人、物的，做定语，其后直接加名词</p><p>e.g. He has a friend whose father is a doctor.</p></li><li><p>关系副词引导的定语从句</p><p>1）where指地点，在定语从句中做地点状语</p><p>e.g. The house where I live ten years ago has been pulled down.</p><p>2）when指时间，在定语从句中做时间状语</p><p>e.g. I still remember the day when I first came to the school.</p><p>3）why指原因，在定语从句中做原因状语</p><p>e.g. Please tell me the reason why you missed the plane.</p><p>注意：关系副词引导的定语从句可以用“介词+关系代词”引导的定语从句来代替。</p><p>e.g. I still remember the day when\on which I first came to the school.</p></li></ol><p>2、非限制性定语从句</p><p>先行词和从句用逗号隔开，既可修饰先行词也可修饰整个主句，对主句所描述的人 或物起补充说明作用。如果去掉从句，并不影响它所修饰的先行词的意义。</p><p>先行词和从句用逗号隔开，既可修饰先行词也可修饰整个主句，对主句所描述的人 或物起补充说明作用。如果去掉从句，并不影响它所修饰的先行词的意义。</p><p>比较：Mr Zhang has a son who likes to play football.（限制性定语从句）</p><p>Mr Zhang has a son, who likes to play football.（非限制性定语从句）</p><p>引导词：</p><ol><li><p>关系代词：who、 whom、whose、which</p><p>1）Professor Wang, who is over sixty, still works hard day and night.</p><p>2）Peter, whom you met in London, lives in Paris now.</p><p>Mr Smith, from whom I have learned a lot, is a famous scientist.（介词在非限定性定语从句中不能后置，关系代词也不能省略）</p><p>3）The boy, whose father is an engineer, studies very hard.</p><p>4）She is always careless, which we should not be.</p></li><li><p>关系副词：when、where</p><p>1）Edgar will put off the picnic until May 1st, when he will be free.</p><p>2）They reached there yesterday, where a negotiation of sale will be held.</p></li><li><p>as和which引导的非限制性定语从句</p><p>as和which都可在句子中做主语或宾语，它们指代的是整个句子。as有“正如、像” 之意，可放在主句之前也可放在主句之后，还可分割整个主句。which弓I导的非限制性 定语从句只能放在主句之后。</p><p>e.g. He is honest, as\which we can see.</p><p>As is known to us, China is a developing country.</p></li></ol><p>3、介词+关系代词引导的定语从句</p><ol><li><p>介词的确定</p><p>介词应根据定语从句的谓语动词部分中的习惯搭配或介词与先行词的搭配来确定。</p><p>e.g. Who is the girl with whom you just shook hands?  (根据 shake hands with 确定) </p><p>He built a telescope through which he could study the skies. (根据 through the telescope 确定)</p></li><li><p>不定代词或数词 + of + 关系代词</p><p>常在定语从句中作主语，说明整体中的一部分。</p><p>e.g. There are a lot of students here, none of whom like the film.</p><p>There are forty students in our class, most of whom are from cities.</p></li><li><p>名词 + of which常代替 whose + 名词在定语从句中的位置</p><p>e.g. I saw some trees, the leaves of which (=whose leaves) were black with disease. </p><p>He mentioned a book, the title of which (=whose title) I’ve forgotten.</p></li><li><p>介词+关系代词结构的省略</p><p>当主从句主语一致时，介词+关系代词引导的定语从句可以省略成“介词+关系代词+不定式”。</p><p>e.g. I have a computer with which I can look for much information.</p><p>I have a computer with which to look for much information.</p></li></ol><h2 id="2-3-连词和状语从句"><a href="#2-3-连词和状语从句" class="headerlink" title="2.3 连词和状语从句"></a>2.3 连词和状语从句</h2><p>连词是表示某种逻辑关系的虚词，常用来连接词、词组、从句或句子。连词可以表 并列、因果、转折、承接、选择、假设、比较、让步等关系。根据连词的不同性质，可 以大致把连词分为两类：并列连词和从属连词。</p><p>考查方式：辨析选项四个连词的词义、表示的关系。</p><p>解题技巧：熟练掌握常用连词的词语，根据语境或语句中的关键词解答。</p><p>1、并列连词</p><p><strong>并列连词用于连接两个及以上的地位平等的词、词组、从句和句子</strong>。可以分为三类： 转折并列连词、因果关系连词和并列关系连词。</p><ol><li><p>转折并列连词有：but, while, however, yet, on the contrary, yet 等</p><p>e.g. I am sorry, but I have already had another appointment.</p></li><li><p> 因果关系连词有：for, so, because等</p></li></ol><p>   e.g. Most workers have a good income, so they look very happy.</p><ol start="3"><li><p>并列关系连词有：and, or, not only…but also…, neither… nor…, on (the) one hand…on the other hand 等</p><p>e.g. She likes going out with friends or playing outdoor games.</p></li></ol><p>2、从属连词</p><p>从属连词主要用于引导名词性从句和状语从句。引导名词性从句的从属连词主要有 三个：that无词义，不做成分；if/whether表达是否的意义，但不做句子成分。大部分 从属连词用于引导状语从句。具体如下：</p><ol><li><p>时间状语从句连词：when, while, as, before, after, since, until, till, as soon as, the moment, the minute, the second, the instant, immediately</p><p>e.g. I didn’t realize how special my mother was until I became an adult.</p></li><li><p>地点状语从句连词：where, wherever, everywhere, anywhere</p><p>e.g. You should make it a rule to leave things where you can find them again.</p></li><li><p>原因状语从句连词：because, as, since, seeing that, now that, considering that</p><p>e.g. Parents should take seriously their children’s requests for sunglasses because eye protection is necessary in sunny weather.</p></li><li><p>条件状语从句连词：if, unless, as /so long as, in case</p><p>e.g. You must keep on working in the evening unless you are sure you can finish the task in time.</p></li><li><p>目的状语从句连词：in order that, so that, in case, for fear that</p><p>e.g. Roses need special care so that they can live through winter.</p></li><li><p>让步状语从句连词：although, though, even though, even if, while, however, whatever, whoever, whenever</p><p>e.g. There was never any time for Kate to feel lonely, even though she was an only child.</p></li><li><p>比较状语从句连词：than, as…as</p><p>e.g. Mr.Smith owns a larger collection of coins than anyone else I have ever met.</p></li><li><p>结果状语从句连词：so … that, such … that</p><p>e.g. It‘s such a good chance that we must not miss it.</p></li><li><p>方式状语从句连词： as, as if, as though, how, the way</p><p>e.g. When in Rome, do as the Romans do.</p></li></ol><h2 id="2-4-虚拟语气"><a href="#2-4-虚拟语气" class="headerlink" title="2.4 虚拟语气"></a>2.4 虚拟语气</h2><p>虚拟语气表示虚假的、与事实相反的或难以实现的情况。另外，表达主观愿望或某种强烈情感时也用虚拟语气。</p><p>考查方式：考查虚拟语气的与过去、现在、将来相反的时态的用法。</p><p>解题技巧：熟记虚拟语气的各个知识点。</p><p>1、if条件从句中的虚拟语气</p><p><img src="/images/image-20210813194736596.png" alt="image-20210813194736596"></p><p>2、其他的虚拟语气</p><ol><li><p>as if/as though + 从句</p><p><img src="/images/image-20210813194912362.png" alt="image-20210813194912362"></p></li><li><p>wish/if only + 从句</p><p><img src="/images/image-20210813195007212.png" alt="image-20210813195007212"></p></li><li><p>would rather+ 从句</p><p><img src="/images/image-20210813195055416.png" alt="image-20210813195055416"></p></li><li><p>It is （high/about） time that sb. did/ should do sth.是时候要做某事</p><p>e.g. It is （high） time that you should study hard.</p></li><li><p>表示坚持、建议、命令、要求的四类动词及相应的名词后面用that （should） do </p><p>此类动词有：desire （想要）；prefer （宁愿）；insist （坚持）；order, command （命令）；advise, suggest, propose, recommend （建议）；demand, require, request, ask （要求）。</p><p>e.g. He suggested that we should leave early.</p><p>Our suggestion is that you should be the first to go.</p></li></ol><h2 id="2-5-倒装结构"><a href="#2-5-倒装结构" class="headerlink" title="2.5 倒装结构"></a>2.5 倒装结构</h2><p>为了强调、突出某些句子成分而颠倒原有语序的句式叫做倒装句。倒装句可分为<strong>全部倒装</strong>和<strong>部分倒装</strong>两种：全部倒装是指将句子中的谓语全部置于主语之前；部分倒装是指将谓语的一部分，如助动词或情态动词倒装至主语之前，而谓语动词无变化。</p><p>1、全部倒装</p><ol><li><p>there be/come/live/stand/lie 等结构中</p><p>e.g. There stands a temple on the top of the mountain.</p></li><li><p>表示地点、方向、时间的副词或状语置于句首，here, away, down, in, off, over, round, up, then 及表示运动的不及物动词，如 go, come, leave, move, jump 等</p><p>e.g. Here cames the teacher.</p></li><li><p>状语与表语位于句首</p><p>e.g. Among these people was his friend Jim.</p></li><li><p>分词和不定式置于句首</p><p>e.g. Standing beside the table was his wife.</p></li></ol><p>2、部分倒装</p><ol><li><p>否定副词 never, rarely, little, hardly, scarcely, few, seldom 等表示几乎不；not until…句型介词短语有：in no way, in no case, by no means, under no circumstances 绝不；hardly/scarcely /barely… when… <em>一</em>….. 就…. ,no sooner… than… 一…… 就…. o</p><p>e.g. Seldom have we felt as comfortable as at home.</p><p>Not until the rain stopped did he leave the room.</p><p>注意：</p><p>1）Not until放在句首时在复合句中主句倒装，而until引导的从句不倒装；放在强调句型中不用倒装。</p><p>e.g. Not until he came to Beijing did he begin to learn English.</p><p>It was not until he came to Beijing that he began to learn English.</p><p>2）将hardly /no sooner置于句首时，要部分倒装；注意搭配与时态。</p><p>e.g. Hardly had sb. done sth. when sb. did sth.</p><p>No sooner had sb. done sth. than sb. did sth.</p></li><li><p>only+状语位于句首</p><p>e.g. Only in this way did I finish the homework.</p><p>Only in this way are you able to do it well.</p><ul><li>only + 主语时，不倒装；</li><li>only + 状语从句时，主句倒装，从句不倒装</li><li>在强调句型中不用倒装</li></ul></li><li><p>So/such… that引导的结果状语从句，表示“如此……以致于……”，如果将so/such及其所修饰部分提到句首时要倒装</p><p>e.g. So difficult did I find it to work out the problem that I decided to ask him for advice.</p><p>Such a good one was his idea that we all agree to use it.</p></li><li><p>as/though引导让步状语从句表“尽管”时，要将表语、状语和动词原形提到句首 e.g. Child as he is, he knows <em>a</em> lot.</p><p>Try as he might, he couldn’t reach his goal.</p><p>注意：表“尽管”时，as必倒；though可倒可不倒；although / while必不倒。</p></li><li><p>if 引导的虚拟条件句中含有had, were, should等，若将if省略，were, had, should要提前</p><p>e.g. Should it rain tomorrow, we would stay at home.</p><p>Had you come yesterday, you would have seen him.</p></li><li><p>以neither, nor或so开头的句子或分句，通常用倒装；表示前面所说的情况也 适合于后者时，neither或nor用于否定句中，so用于肯定句中</p><p>e.g. They can answer the question. So can I.</p><p>He didn’t attend the party last night, neither did she.</p></li><li><p>not only…but also位于句首时，not only后面的句子通常用部分倒装，but (also) 引导的句子不倒装</p><p>e.g. Not only did he speak more correctly, but he spoke more easily.</p></li><li><p>在表祝愿的句子中</p><p>may sb. do sth.</p><p>e.g. May you be in good health.</p></li></ol><h2 id="2-6-强调句型"><a href="#2-6-强调句型" class="headerlink" title="2.6 强调句型"></a>2.6 强调句型</h2><p>考查方式：考查强调句的结构、时态is/waso</p><p>解题技巧：判断句子结构是否为强调句，如果是，则根据强调句型结构来解答。</p><h3 id="2-6-1-强调句的含义"><a href="#2-6-1-强调句的含义" class="headerlink" title="2.6.1 强调句的含义"></a>2.6.1 强调句的含义</h3><p>强调句是一种修辞。是人们为了表达自己的意愿或情感而使用的一种形式。通过各种方式对句子中的某个部分进行强调，从而起到修辞的作用。</p><h3 id="2-6-2-强调句的用法"><a href="#2-6-2-强调句的用法" class="headerlink" title="2.6.2 强调句的用法"></a>2.6.2 强调句的用法</h3><ol><li><p>强调句的结构</p><p>It is/was + 被强调部分（通常为主语、宾语和状语）+ that/who + 从句的其他部分。</p><p>被强调部分指人时用who；指事物时用that,但that也可以指人。在美国英语中指 事物时常用which来代替that, 此类强调句删除it is/was和that,句子成分仍是完整的。 that不能省略，只有两种时态：一般现在时与一般过去时。</p><p>e.g. My father did the experiment in the lab on the yesterday morning.</p><p>强调主语：It was my father who did the experiment in the lab on the yesterday morning.</p><p>强调宾语： It was experiment that my father did in the lab on the yesterday morning. </p><p>强调地点：It was in the lab that my father did the experiment on the yesterday morning. 强调时间: It was on the yesterday morning that my father did the experiment in the lab.</p></li><li><p>强调句型的一般疑问式</p><p>直接把is或was提到it之前即可。</p><p>e.g. Was it Tom that found your pen in the classroom yesterday?</p><p>Was it in 1939 that the Second World War broke out?</p></li><li><p>强调句型的特殊疑问式</p><p>特殊疑问词+ is （was） it + that +句子的其他成分，特殊疑问词即是被强调的成分。</p><p>e.g. Who was it that found your pen in the classroom yesterday?</p><p>When was it that the Second World War broke out?</p></li><li><p>not… until… 句型的强调句</p><p>句型：It is/was not until +被强调部分+that +其他部分</p><p>普通句：He didn’t come home until 12 last night.</p><p>强调句：It was not until 12 last night that he came home.</p><p>注意：此句型只用until,不用till。但如果不是强调句型，till, until可通用；因 为句型中it is/ was not…已经是否定句了，that后面的从句要用肯定句，切勿再用否定句了。</p><p>在强调句式中，虽然not被提前，但not…until…句型不要到装。</p><p>that后的强调句如果是原因状语从句，从句只能用because引导，不能用since, as 或 why。</p><p>e.g. It was because the water had risen that they could not cross the river.</p></li></ol><h1 id="3-阅读理解"><a href="#3-阅读理解" class="headerlink" title="3. 阅读理解"></a>3. 阅读理解</h1><p>阅读理解是各类商业银行招聘考试英语学科中的必考题型。其题型特点有以下三点：</p><p>一、 内容涵盖范围广。既包括政治、经济、社会、科学、心理健康等热门话题， 也包括一些应用型文章，如：招聘启事、会议邀请、商务信函、求职建议等，体现 了对考生的全方位考察。如：2020年中国银行阅读题就有一篇是教读者如何写求职 信，2020年交通银行阅读题考察了当今社会人的焦虑对周围事物的影响，2020年工商银行的阅读题考察了对本行中期财务报告的解读。从以上观察来看，银行近年来 的考查范围越来越广，阅读形式也越来越灵活，不再拘泥于传统模式的阅读理解。 因此，考生在备考的过程中不但要关注国际国内的热点话题，也要学着阅读一些应用型文章，这样才能快速把握文章主题，选出正确的选项。</p><p>二、 阅读篇幅长。历年商业银行的阅读题字数基本都在500字左右，个别银行， 如工商银行、国开银行，文章篇幅达到700字以上，个别比较短小的文章也是由于该文章只设置了 2-3道题，这种长篇幅的阅读主要考察考生快速搜索关键信息的能力， 因此需要考生掌握相应的答题技巧，而不是盲目通篇阅读。</p><p>三、 题量大。英语考査一直在各大银行的考试中都占有较大的比重，尤其以中国银行、农业银行、邮储银行、国开银行等银行为主，以中国银行2019年的考试为例， 要求考生在60分钟内解答100题，其中50道单项选择及50道阅读题，每道题的平均答题时间只有36秒，这就要求考生具备良好的快速解题能力。</p><p>总之，阅读理解是银行招考的重要考查方式，不仅考査考生的基础知识、阅读 能力，还考察考生在时间压力下快速解题的能力，因此学会解题技巧对应对银行英 语考试有着非常重要的作用。</p><p><img src="/images/image-20210813215020206.png" alt="image-20210813215020206"></p><h2 id="3-1-细节题"><a href="#3-1-细节题" class="headerlink" title="3.1 细节题"></a>3.1 细节题</h2><p>细节题是对原文的事实信息进行提问，是阅读理解考査的主体。主要考査考生的信息检索能力和阅读能力，需要考生培养快速、准确找到答案的能力。</p><p>细节题一般分为两种提问方式，一种是考察文章中的时间、地点、人物、情节和结局，主要以what, who, which, when, where, how, why等词引导，就文中某句、某段或某一具体细节进行提问，并要求考生回答。一种是针对文章中出现内容的真确性进行辨析，常见的提问方式有：</p><p>Which of the folloing is right/not right?</p><p>Which of the following is mentioned/nor mentioned?</p><p>From the passage, we know or learn that         </p><p>According to the paragraph, …would /would not         </p><p>这类题的特点是：凡针对特定细节的题目，其正确答案大多都可以在阅读材料中找到相应的文字描述作为依据。可能是原文中的某一个句子，也有可能是文中的若干句子， 但有时题干与原文的表述方式不同，往往是同义句或同义词的关系。</p><p>细节题有两种分类：一般细节题和是非细节题。解答这两种类型的题目要根据题目选项的不同及依托阅读做题原则，灵活运用各种阅读技法，快速有效地解题。</p><ol><li><p>一般细节题</p><p>顺序定位，一般出题都会按照文章段落的顺序出题。</p><p>具体定位：如果选项答案有数字、人名、地名等关键信息，那么在定位就定位在这些信息上，再看其后的中心语成分与题目中心词是否一致。</p><p>同义替换原则 e.g. dangerous = in danger; ability = capability; dull = boring 等，如果出现同义词替换的地方恰恰就是答案所在。</p></li><li><p>解答是非对错题时，题目如果对具体内容作出说明（限定状语居多时）以题目中的中心词来定位；如果题目只是对某一具体内容的陈述，那么就需要通过选项的中心词来寻找答案。四个选项可能有同一个中心词或者四个选项为四个不同的中心词，需要根据中心词分别到文章中一一对应原文，然后再判定答案。</p></li><li><p>   解题技巧——快速定位法</p></li></ol><p>   快速定位是秒杀细节题首要的步骤。定位题目、题目的中心内容、主题，题干中如果出现具体且独特的信息，如：数字类信息（数量、日期、金额、名称等），一般主语、 宾语、特殊词、数字、人名及地名等专有名词是解题的关键。抓住中心内容或特殊词迅速在文章中定位相应内容，便能快速有效地找到答案所在之处。同时要熟练掌握英语 文章结构和英语阅读的出题顺序，以便快速定位题目。</p><h2 id="3-2-主旨题"><a href="#3-2-主旨题" class="headerlink" title="3.2 主旨题"></a>3.2 主旨题</h2><p>主旨题是是英语阅读中常见的考查形式。考査学生对于文章整体把握的能力，对于考试而言，需要掌握如何在有限的时间内快速掌握文章的主旨。</p><p>主题句原则，一般英语文章的思维都是开门见山。因此，第一段和每一段的第一句话及最后一句话都有可能体现文章的主题。注意交点重合，即每段重复最多的或者选项 中不断出现的内容，很有可能和该文段的主旨有关。</p><ol><li><p>主旨题的判定方法</p><p>题干中出现 the most appropriate /the best title, subject, mainly discuss / about, main them / point / idea等词或词组的时候，就可以判定该题为主旨题，常见的提问方式有：</p><p>What’s the main idea of this passage?</p><p>What is the best title for this passage?</p><p>The passage is most likely       </p><p>Which statement best describes the writing purpose of this article?</p></li><li><p>解题技巧——选项主体处理法</p><p>选项主体处理法是解答主旨题的有效方法，其关键在于首先对选项进行处理。 选项的主要内容一般用名词或者动词来表达，提炼选项中的名词和动词等关键词，然后快速与原文中的句子进行匹配，前后对照之后快速找到正确选项。对于较长的选项， 拥住选项的主体，也有利于考量与定位句的主体是否构成意义一致或者存在同义词替换的情况。</p><p>如果文章主旨题在该篇阅读中的第一题出现，那么答案一般在段首，依据英语文章结构和出题顺序，特别是信件、备忘录之类都是开门见山指明主题；如果文章主旨句，出现在该篇的最后一题，那么可以根据前面所做的题目提取文章主旨，而不用再回头阅读。</p></li></ol><h3 id="3-3-语义题"><a href="#3-3-语义题" class="headerlink" title="3.3 语义题"></a>3.3 语义题</h3><p>语义题主要考查对特殊语境中单词或词组意思的理解，其考查方式往往是要求对某 个词、词组或句子的含义进行推测，有时也会考查名词或代词的指代。对于考査单词的题型来说，往往需要结合上下文的语境来判定词义，而不是该单词的直接意义。如果是短语或句子，则要通过其出现的位置进行上下文阅读，进一步确认其语境含义，从而找 到正确答案。</p><ol><li><p>语义题的判定方法</p><p>语义题的判定比较容易，往往在题干中会直接提问某个段落的某个单词或短语的真实含义，常见的提问方式有：</p><p><img src="/images/image-20210813220244603.png" alt="image-20210813220244603"></p></li><li><p>解题技巧——同义词原则</p><p>解答语义题时，可以使用同义词原则。表现为：选项主体和原文中的定位句的主体为同义词，再结合语境做进一步判断，就能锁定正确选项了。要注意多积累常用同义词及同义短语，对做语义题有很大的帮助。</p></li></ol><h2 id="3-4-推断题"><a href="#3-4-推断题" class="headerlink" title="3.4 推断题"></a>3.4 推断题</h2><ol><li><p>推断题的判定方法</p><p>推断题是根据文章表面的文字信息，推断出作者没有提到或没有明说的事实或隐含信息。这种题目旨在考查考生通过词语的字面意义去理解作者的言外之意的能力，属于 深层理解题。推断题又可分为部分内容的推测（小推）和对全文的推测（大推），对部分内容的推测可以通过定位原文的方式，联系上下文内容进行解答，对全文的推测需要掌握文段的主旨、作者的态度和写作目的，因此难度较大。推断题的常见提问方式有：</p><p>According to the passage, we can infer that        </p><p>We may conclude from the passage that        </p><p>What is the purpose of…?</p><p>What can be inferred from paragraph 3?</p><p>It can be inferred from the article that         </p><p>What may the author discuss later?</p></li><li><p>解题技巧——关键信息定位法</p><p>针对文段部分内容的推断题，一般是针对文中的事实或细节而设置，因此可以根据题干中的人物、地点、时间、陈述对象等关键词语在原文中定位，然后根据原文内容逬 行正确的推理和判断。如果是针对全文的推断，可以通过判定主旨句的方式判定大致范围，然后通过排除干扰选项找到正确笞案。干扰选项一般具有如下特点：</p><ul><li>选项内容与文段完全无关</li><li>推理过度，概括过度</li><li>只是对原文的简单复述，而非结论</li></ul><p>因此在做推断题时，需要考生在理解的基础上做出进一步的判断，结合做题技巧， 顺利找到答案。</p></li></ol><h3 id="3-5-观点态度题"><a href="#3-5-观点态度题" class="headerlink" title="3.5 观点态度题"></a>3.5 观点态度题</h3><ol><li><p>观点态度题的判定方法</p><p>观点态度题主要是针对作者的写作意图、观点态度和对事件的评价设问的题目，作 者在文中表达某种态度或观点，有的开门见山，直截了当；有的含蓄委婉，旁敲侧击； 有的通过用词的褒贬来体现，考生需要从作者的措辞、语气和对某个细节的把握来推断 作者在整篇文章中所表现出的态度和写作意图以及对事物的评价。常见的提问方式有：</p><p>Wha’s the attitude of the author?</p><p>What do you think is the author’s attitude by saying</p><p>What is the author’s opinion about…?</p><p>What is the author’s attitude towards …?</p><p>What does the author mean by saying （Paragraph 3）?</p><p>The author says （Paragraph 5）, because          </p><hr><p>常见的态度有以下几种：</p><p>积极类: </p><p>impartial （公正的）、helpful （有帮助的）＞ positive （正确的）、supporting （支 持的）、unbiased （没有偏见的）、concerned （关心的）、confident （自信的）、 optimistic （乐观的）favorable （赞成的）、impressive （给人印象深刻的）、confident （自信的）等；</p><p>中立类：</p><p>objective （客观的）、neutral （中立的）、indifferent （不感兴趣的）、 cautious （谨慎的）、uncertain （不确定的）等；</p><p>消极类：</p><p>critical （批评的）、negative （否定的）、doubtful （怀疑的） pessimistic （悲观的）、biased （有偏见的）、vicious （恶意的）、worried （担心的）、disappointed （失望的）、subjective （主观的）等。</p></li><li><p>解题技巧——首尾结合法</p><p>英语文章的写作习惯是，作者往往倾向于在首句或尾句表明自己的观点和态度，所以抓住首句和尾句是做题的突破口，同时注意区分作者的态度和作者引用的别人的态度。 在解答观点态度题时，建议将该题放在最后一道来做，有时也可以通过对其他题目的解答判断出作者的态度。</p></li></ol><h1 id="4-完形填空"><a href="#4-完形填空" class="headerlink" title="4. 完形填空"></a>4. 完形填空</h1><h1 id="5-职测英语词汇补充"><a href="#5-职测英语词汇补充" class="headerlink" title="5. 职测英语词汇补充"></a>5. 职测英语词汇补充</h1><p><img src="/images/image-20210813221313342.png" alt="image-20210813221313342"></p><p><img src="/images/image-20210813221342542.png" alt="image-20210813221342542"></p><p><img src="/images/image-20210813221409347.png" alt="image-20210813221409347"></p><p><img src="/images/image-20210813221438026.png" alt="image-20210813221438026"></p><p><img src="/images/image-20210813221504359.png" alt="image-20210813221504359"></p><p><img src="/images/image-20210813221534867.png" alt="image-20210813221534867"></p><p><img src="/images/image-20210813221557192.png" alt="image-20210813221557192"></p><p><img src="/images/image-20210813221709711.png" alt="image-20210813221709711"></p><p><img src="/images/image-20210813221812286.png" alt="image-20210813221812286"></p><p><img src="/images/image-20210813221839721.png" alt="image-20210813221839721"></p><p><img src="/images/image-20210813221913646.png" alt="image-20210813221913646"></p><p><img src="/images/image-20210813221940578.png" alt="image-20210813221940578"></p><p><img src="/images/image-20210813222011584.png" alt="image-20210813222011584"></p>]]></content>
    
    
    <categories>
      
      <category>职测基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/08/10/7%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/08/10/7%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><h2 id="1-1-操作系统的概念"><a href="#1-1-操作系统的概念" class="headerlink" title="1.1 操作系统的概念"></a>1.1 操作系统的概念</h2><h3 id="1-1-1-操作系统的定义"><a href="#1-1-1-操作系统的定义" class="headerlink" title="1.1.1 操作系统的定义"></a>1.1.1 操作系统的定义</h3><p>操作系统（OS，Operating System）是计算机系统中最重要的系统软件，它是控制计算机软、硬件资源和方便用户管理的程序集合。</p><h3 id="1-1-2-操作系统的特性"><a href="#1-1-2-操作系统的特性" class="headerlink" title="1.1.2 操作系统的特性"></a>1.1.2 操作系统的特性</h3><ol><li><p>并发性</p><p>并发性是指两个或多个事件在同一时间间隔内发生。并发性和并行性两个概念既相似又有区别：并行性是指两个或多个事件在同一时刻发生。</p><p>在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，在单处理机系统中，每一时刻仅能有一道程序执行，因此微观上这些程序只能分时交替地执行。</p><p>并发特征是操作系统最重要的特征，后续三个特征都以并发特征为前提。</p></li><li><p>共享性</p><p>由于操作系统具有并发性，整个系统的软、硬件资源不再为某个程序所独占，而是由许多程序共同使用，即许多程序共享系统中的各种资源。并发性和共享性相辅相成，是操作系统的两个基本的特征。</p></li><li><p>虚拟性</p><p>虚拟性是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</p><p>用于实现虚拟的技术被称为虚拟技术。操作系统中利用两种方式来实现虚拟技术：</p><ul><li><p>时分复用技术</p><p>在计算机领域中，广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，以提高资源的利用率。</p></li><li><p>空分复用技术</p><p>使用空分复用技术来提高存储空间的利用率，如虚拟磁盘等。</p></li></ul></li><li><p>异步性</p><p>异步性是指在多道程序环境下，每个程序何时执行、何时暂停未知，即以不可预知的速度向前推进。</p><p>只要在操作系统中配置有完善的进程同步机制，且运行环境相同，作业经多次运行都会获得完全相同的结果。</p></li></ol><h3 id="1-1-3-操作系统的作用"><a href="#1-1-3-操作系统的作用" class="headerlink" title="1.1.3 操作系统的作用"></a>1.1.3 操作系统的作用</h3><ol><li><p>用户与计算机硬件系统之间的接口</p><p>从一般用户的角度看，操作系统是用户与计算机硬件系统之间的接口，用户可通过<strong>命令</strong>、<strong>系统调用</strong>、<strong>图形及窗口</strong>方式使用计算机：</p><ol><li><p>命令方式</p><p>OS提供了一组联机命令接口，以允许用户通过键盘输入有关命令来取得操作系统的服务，并控制用户程序的运行。</p></li><li><p>系统调用方式</p><p>OS提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来实现与操作系统的通信，并取得它的服务。</p></li><li><p>图形、窗口方式</p><p>这是当前使用最为方便、最为广泛的接口，它允许用户通过屏幕上的窗口和图标来实现与操作系统的通信，并取得它的服务。</p></li></ol></li><li><p>计算机系统资源的管理者</p><p>从资源管理的角度看，<strong>操作系统是计算机系统资源的管理者</strong>。</p><p><strong>在一个计算机系统中，资源可分为处理器、存储器、I/O 设备及信息（数据和程序）四类</strong>。</p><p>相应地，操作系统也针对这四类资源进行有效管理：</p><ol><li>处理机管理，分配和控制处理机</li><li>存储器管理，负责内存的分配与回收</li><li>I/O 设备管理，负责 I/O 设备的分配与操纵</li><li>文件管理，负责文件的存取、共享和保护</li></ol></li><li><p>实现对计算机资源的抽象</p><p>操作系统还实现了对计算机资源的抽象，隐藏了对硬件操作的细节，使用户能够更方便地使用机器。</p></li></ol><h3 id="1-1-4-操作系统的目标"><a href="#1-1-4-操作系统的目标" class="headerlink" title="1.1.4 操作系统的目标"></a>1.1.4 操作系统的目标</h3><p>在计算机硬件上配置操作系统，主要目标是为了实现方便性、有效性、可扩充性和开放性。</p><p>方便性是为了使得计算机系统更容易使用，有效性是为了提高系统资源利用率和吞吐量，方便性和有效性是设计操作系统时最重要的两个目标。</p><p>可扩充性使得操作系统能适应计算机硬件、体系结构以及应用发展的要求；开放性指操作系统能遵循世界标准规范，特别是遵循开放系统互连（OSI Open System Interconnect）国际标准，开放性是操作系统能否被广泛应用的重要因素。</p><h2 id="1-2-操作系统的发展"><a href="#1-2-操作系统的发展" class="headerlink" title="1.2 操作系统的发展"></a>1.2 操作系统的发展</h2><h3 id="1-2-1-无操作系统的计算机系统"><a href="#1-2-1-无操作系统的计算机系统" class="headerlink" title="1.2.1 无操作系统的计算机系统"></a>1.2.1 无操作系统的计算机系统</h3><ol><li><p>人工操作方式</p><p>计算机发展早期，还未出现操作系统，计算机的操作由用户采用人工操作方式直接使用计算机硬件系统。这种人工操作方式的缺点是：用户独占全机，CPU 等待人工操作，故严重降低了计算机资源的利用率。此外，高速 CPU 与低速 I/O 设备之间速度不匹配的矛盾也日益突出。</p></li><li><p>脱机输入/输出方式</p><p>为解决上述问题引入了脱机输入/输出技术，此名称的由来源于程序和数据的输入和输出是在脱离主机的情况下进行：脱机输入方式是指在一台外围机的控制下，先将程序和数据从低速的输入设备输入到磁带，当 CPU 需要这些程序和数据时，再从磁带高速地读入内存；脱机输出方式则正好相反。</p><p>这种方式下，由外围机而不是 CPU 等待人工操作，并且 CPU 直接通过高速磁带进行输入/输出，因而较好地缓和了 CPU 与 I/O 设备之间速度不匹配的问题。</p></li></ol><h3 id="1-2-2-批处理系统"><a href="#1-2-2-批处理系统" class="headerlink" title="1.2.2 批处理系统"></a>1.2.2 批处理系统</h3><ol><li><p>单道批处理系统</p><p>单道批处理系统是指系统对作业的处理都是成批地进行，且在内存中始终只保持一道作业。单道批处理系统是最早出现的一种操作系统，其主要特征有自动性、顺序性、单道性。</p></li><li><p>多道批处理系统</p><p>为了进一步提高资源的利用率和系统吞吐量，又引入了多道程序设计技术，由此形成了多道批处理系统：用户所提交的作业都先存放在外存上并排成一个后备队列，然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享 CPU 和系统中的各种资源。</p><p>多道批处理系统的主要优缺点如下：</p><ol><li>资源利用率高</li><li>系统吞吐量大</li><li>平均周转时间长。作业的周转时间是指从作业进入系统开始，到作业完成为止的这段时间间隔</li><li>无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极为不便</li></ol></li></ol><h3 id="1-2-3-分时系统"><a href="#1-2-3-分时系统" class="headerlink" title="1.2.3 分时系统"></a>1.2.3 分时系统</h3><p>分时系统是指在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p><p>分时系统可以归纳成以下四个特点：</p><ol><li><p>多路性（同时性）</p><p>允许在一台主机上同时连接多台联机终端，系统按分时原则为每个用户服务。宏观上，是多个用户同时工作；而微观上，则是每个用户作业轮流运行一个时间片。</p></li><li><p>独立性</p><p>每个用户各占一个终端，彼此独立操作，互不干扰，用户感觉像是自己一人独占主机。</p></li><li><p>及时性</p><p>用户的请求能在很短的时间内获得响应。</p></li><li><p>交互性</p><p>用户可通过终端与系统进行广泛的人机对话。</p></li></ol><h3 id="1-2-4-实时系统"><a href="#1-2-4-实时系统" class="headerlink" title="1.2.4 实时系统"></a>1.2.4 实时系统</h3><p>实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p><p>实时系统有以下五个特点：</p><ol><li><p>多路性</p><p>实时控制系统的多路性主要表现在系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。</p></li><li><p>独立性 </p><p>实时控制系统中，对信息的采集和对对象的控制彼此互不干扰。</p></li><li><p>及时性 </p><p>实时控制系统的及时性，以控制对象所要求的开始截止时间或完成截止时间来确定，一般为秒级到毫秒级，甚至更低。</p></li><li><p>交互性 </p><p>实时信息处理系统也具有交互性，但仅限于访问系统中某些特定的专用服务程序。</p></li><li><p>可靠性 </p><p>分时系统虽然也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性，因为任何差错都可能带来巨大的经济损失，甚至是无法预料的灾难性后果。</p></li></ol><h3 id="1-2-5-微机操作系统"><a href="#1-2-5-微机操作系统" class="headerlink" title="1.2.5 微机操作系统"></a>1.2.5 微机操作系统</h3><p><strong>批处理系统</strong>、<strong>分时系统</strong>和<strong>实时系统</strong>是操作系统的三种基本类型。</p><p>随着计算机的不断发展和应用需求的不断扩大，操作系统也先后形成了微机操作系统、网络操作系统等。</p><p>配置在微型机上的操作系统称为微机操作系统，按运行方式可分为如下几类：</p><ol><li><p>单用户单任务操作系统</p><p>单用户单任务操作系统只允许一个用户上机，且只允许用户程序作为一个任务运行，这是最简单的微机操作系统，最有代表性的单用户单任务微机操作系统是 MS-DOS。</p></li><li><p>单用户多任务操作系统</p><p>单用户多任务操作系统只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行，从而有效地改善了系统的性能。最有代表性的单用户多任务操作系</p><p>统是由微软公司推出的 Windows7 等。</p></li><li><p>多用户多任务操作系统</p><p>多用户多任务操作系统允许多个用户通过各自的终端使用同一台机器，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中所配置的大多是多用户多任务操作系统，最有代表性的是 Unix 和 Linux。</p></li></ol><h3 id="1-2-6-网络操作系统"><a href="#1-2-6-网络操作系统" class="headerlink" title="1.2.6 网络操作系统"></a>1.2.6 网络操作系统</h3><p>网络操作系统是使计算机在网络中能方便地传送信息和共享资源，并能为网络用户提供各种所需服务的操作系统。</p><p>由于网络计算的出现和发展，现代操作系统的主要特征之一就是具有上网功能，因此，除了在 20 世纪 90 年代初期时，Novell 公司的 Netware 等系统被称为网络操作系统之外，一般不再特指某个操作系统为网络操作系统。</p><h2 id="1-3-操作系统的功能"><a href="#1-3-操作系统的功能" class="headerlink" title="1.3 操作系统的功能"></a>1.3 操作系统的功能</h2><p>操作系统具有处理机管理，存储器管理，设备管理和文件管理的功能。此外，还须向用户提供用户接口和面向网络的服务功能。</p><h3 id="1-3-1-处理机管理功能"><a href="#1-3-1-处理机管理功能" class="headerlink" title="1.3.1 处理机管理功能"></a>1.3.1 处理机管理功能</h3><p>处理机的管理主要是对进程的管理，在引入了线程的操作系统中，也包含对线程的管理，其主要功能是创建和撤销进程，对各进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理机分配给进程。</p><ol><li><p>进程控制</p><p>进程控制的主要功能是为作业创建进程，撤销已结束的进程，以及控制进程在运行过程中的状态转换。</p></li><li><p>进程同步</p><p>进程是以异步方式运行的，为使多个进程能有条不紊地运行，系统中必须设置进程同步机制。进程同步的主要任务是为多个进程的运行进行协调，有两种协调方式： 进程互斥和同步方式。</p></li><li><p>进程通信</p><p>进程通信的任务就是用来实现在相互合作的进程之间的信息交换。</p></li><li><p>调度</p><p>在后备队列上等待的每个作业都需经过调度才能执行。调度主要包括作业调度和进程调度。</p></li></ol><h3 id="1-3-2-存储器管理功能"><a href="#1-3-2-存储器管理功能" class="headerlink" title="1.3.2 存储器管理功能"></a>1.3.2 存储器管理功能</h3><p>存储器管理的主要任务是为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及能从逻辑上扩充内存。为此，存储器管理应具有<strong>内存分配</strong>、<strong>内存保护</strong>、<strong>地址映射</strong>和<strong>内存扩充</strong>等功能。</p><h3 id="1-3-3-设备管理功能"><a href="#1-3-3-设备管理功能" class="headerlink" title="1.3.3 设备管理功能"></a>1.3.3 设备管理功能</h3><p>设备管理用于管理计算机系统中所有的外围设备，具有缓冲管理、设备分配、设备处理及虚拟设备等功能。</p><h3 id="1-3-4-文件管理功能"><a href="#1-3-4-文件管理功能" class="headerlink" title="1.3.4 文件管理功能"></a>1.3.4 文件管理功能</h3><p>文件管理的主要任务是对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。为此，文件管理应具有<strong>对文件存储空间的管理</strong>、<strong>目录管理</strong>、<strong>文件的读/写管理</strong>，以及<strong>文件的共享与保护</strong>等功能。</p><h3 id="1-3-5-操作系统与用户之间的接口"><a href="#1-3-5-操作系统与用户之间的接口" class="headerlink" title="1.3.5 操作系统与用户之间的接口"></a>1.3.5 操作系统与用户之间的接口</h3><p>为了方便用户使用，操作系统又提供了用户与操作系统的接口，该接口通常可分为两大类：</p><ol><li><p>用户接口</p><p>为了便于用户直接或间接地控制自己的作业，操作系统向用户提供了命令接口。用户可通过该接口向作业发出命令以控制作业的运行。该接口可分为联机用户接口和脱机用户接口。</p><ol><li><p>联机用户接口</p><p>终端用户利用该接口可以调用操作系统的功能，取得操作系统的服务。用户可以使用联机控制命令来对自己的作业进行控制。联机用户接口可以实现用户与计算机间的交互。</p></li><li><p>脱机用户接口</p><p>该接口是专为批处理作业的用户提供的，也称批处理用户接口。操作系统提供了一个作业控制语言 JCL（Job Control Language），用户使用 JCL 语言预先写好作业说明书，将它和作业的程序与数据一起提交给计算机，当该作业运行时，OS 将逐条按照用户作业说明书的控制语句，自动控制作业的执行。</p><p>脱机用户接口不能实现用户与计算机间的交互。</p></li></ol></li><li><p>程序接口</p><p>程序接口是操作系统专门为用户程序设置的，由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，是操作系统与应用程序之间的接口，它是用户程序取得操作系统服务的唯一途径。可以说，系统调用提供了用户程序和操作系统之间的接口，应用程序通过系统调用实现其与操作系统的通信，并可取得它的服务。</p><p>通常，在操作系统的核心中都设置了一组用于实现各种系统功能的子程序，并将它们提供给应用程序调用。由于这些程序是 OS 系统本身程序模块中的一部分，为了保护操作系统程序不被用户程序破坏，一般都不允许用户程序访问操作系统的程序和 数据，也不允许应用程序采用一般的过程调用方式来直接调用这些过程，而是向应用程序提供了一系列的系统调用命令，让应用程序通过系统调用去调用所需的系统过程。</p><p>在计算机系统中，通常运行着两类程序：<strong>系统程序</strong>和<strong>应用程序</strong>，为了保证系统程序不被应用程序有意或无意地破坏，为<strong>计算机设置了两种状态：系统态（也称为管态 或核心态）和用户态（也称为目态）</strong>。操作系统在系统态运行，而应用程序只能在用户态运行。在实际运行过程中，处理机会在系统态和用户态间切换。相应地，<strong>现代多数操作系统将 CPU 的指令集分为特权指令和非特权指令两类</strong>：</p><ol><li><p>特权指令</p><p>特权指令是在系统态时运行的指令，是关系到系统全局的指令。特权指令只允许操作系统使用，不允许应用程序使用，否则会引起系统混乱。</p></li><li><p>非特权指令</p><p>非特权指令是在用户态时运行的指令。一般应用程序所使用的都是非特权指令，它只能完成一般性的操作和任务。</p></li></ol><p>当应用程序中需要操作系统提供服务如请求 I/O 资源或执行 I/O 操作时，应用程序必须使用系统调用命令。操作系统捕获到该命令后，便将 CPU 的状态从用户态转换到系统态，然后执行操作系统中相应的子程序，完成所需的功能。执行完成后，系统又将 CPU 状态从系统态转换到用户态，再继续执行应用程序。</p></li></ol><h2 id="1-4-操作系统的结构"><a href="#1-4-操作系统的结构" class="headerlink" title="1.4 操作系统的结构"></a>1.4 操作系统的结构</h2><h3 id="1-4-1-无结构操作系统"><a href="#1-4-1-无结构操作系统" class="headerlink" title="1.4.1 无结构操作系统"></a>1.4.1 无结构操作系统</h3><p>在早期开发操作系统时，设计者缺乏首尾一致的设计思想。此时的操作系统只是一组过程的集合，每个过程可以任意地调用其它过程，致使操作系统内部复杂而混乱，这种操作系统是无结构的。</p><h3 id="1-4-2-模块化结构操作系统"><a href="#1-4-2-模块化结构操作系统" class="headerlink" title="1.4.2 模块化结构操作系统"></a>1.4.2 模块化结构操作系统</h3><p>模块化程序设计技术是基于“分解”和“模块化”原则来控制大型软件的复杂度。 为使操作系统具有较为清晰的结构，将操作系统按其功能划分为若干个具有一定独立性和大小的模块，每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能通过该接口实现交互。然后，再将各模块细分为若干个具有一定功能的子 模块，同样也要规定好各子模块之间的接口。若子模块较大时，可再进一步将它细分。这种设计方法称为模块-接口法，由此构成的操作系统就是具有模块化结构的操作系统。</p><p>模块化结构设计中，各模块的设计齐头并进，无法寻找到一个可靠的决定顺序， 造成各种决定的无序性，因此模块–接口法又被称为无序模块法。</p><p><img src="/images/image-20210810102227006.png" alt="image-20210810102227006"></p><h3 id="1-4-3-分层式结构操作系统"><a href="#1-4-3-分层式结构操作系统" class="headerlink" title="1.4.3 分层式结构操作系统"></a>1.4.3 分层式结构操作系统</h3><p>为了将模块–接口法中“决定顺序”的无序性变为有序性，引入了有序分层法。分层法的设计任务是，在目标系统和裸机系统之间，铺设若干个层次的软件，使目标 系统通过这些层，最终能在裸机系统上运行。在操作系统中，常采用自底向上法来铺 设这些中间层，其基本原则是：每一步设计都是建立在可靠的基础上。为此规定每一层仅能使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得更容易。</p><p>分层结构的主要优点有：易保证系统的正确性、易扩充和易维护性。其主要缺点是：系统效率降低。由于层次结构是分层单向依赖的，操作系统每执行一个功能，通常要自上而下地穿越多个层次，增加了系统的通信开销，从而导致系统效率的降低。</p><h3 id="1-4-4-微内核操作系统结构"><a href="#1-4-4-微内核操作系统结构" class="headerlink" title="1.4.4 微内核操作系统结构"></a>1.4.4 微内核操作系统结构</h3><p>当前比较流行的、能支持多处理机运行的操作系统，几乎都采用了微内核结构。下面从四个方面对微内核结构的操作系统进行描述。</p><ol><li><p>足够小的内核</p><p>在微内核操作系统中，内核是指精心设计的、能实现现代操作系统最基本的核心功能的部分。微内核并非是一个完整的操作系统，而只是操作系统中最基本的部分，它通常用于：实现与硬件紧密相关的处理；实现一些较基本的功能；负责客户和服务器之间的通信。它们只是为构建通用操作系统提供一个重要基础，这就确保把操作系统内核做得很小。</p></li><li><p>基于客户/服务器模式</p><p>由于客户/服务器模式具有很多的优点，故在单机微内核操作系统中几乎都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器进程中实现。</p></li><li><p>应用“机制与策略分离”原理</p><p>在现代操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造操作系统结构。机制是指实现某一功能的具体执行机构，策略则是在机制的基础上，借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。在微内核操作系统中，通常将机制放在操作系统的微内核中，因此才有可能将内核做得很小。</p></li><li><p>采用面向对象技术</p><p>操作系统是一个极其复杂的大型软件系统，不仅可以通过结构设计来分解操作系统的复杂度，还可以基于面向对象技术中的“抽象”和“隐蔽”原则控制系统的复杂性，再进一步利用“对象”、“封装”和“继承”等概念来确保操作系统的正确性、可靠性、易扩展性等，面向对象技术被广泛应用于现代操作系统的设计中。</p></li></ol><p>微内核结构的操作系统具有如下优点：提高了系统的可扩展性，增强了系统的可靠性、可移植性，提供了对分布式系统的支持，融入了面向对象技术。</p><p>在微内核操作系统中，采用了非常小的内核，以及客户/服务器模式和消息传递机制，这些虽给微内核操作系统带来了许多优点，但由此也使微内核操作系统的运行效 率有所降低。</p><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h1><h2 id="2-1-进程的概念"><a href="#2-1-进程的概念" class="headerlink" title="2.1 进程的概念"></a>2.1 进程的概念</h2><h3 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h3><ol><li><p>程序</p><p>程序是指令的有序集合，是一个在时间上严格按次序前后相继的操作序列，仅当前一操作执行完后，才能执行后继操作，它是一个静态的概念。</p><p>程序的执行方式有顺序执行和并发执行两种，这两种方式间有着显著不同的特征。</p><ol><li><p>程序的顺序执行</p><p>程序顺序执行时的特征包括：</p><ol><li><p>顺序性 </p><p>—个程序各个部分的执行，严格地按照某种先后次序执行。</p></li><li><p>封闭性 </p><p>程序在封闭的环境下运行，即程序运行时独占全部系统资源，资源的状态（除初始状态外）只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。</p></li><li><p>可再现性 </p><p>只要程序执行时的环境和初始条件相同，当程序重复执行时，都将获得相同的结果。</p></li></ol></li><li><p>程序的并发执行</p><p>程序的并发执行，虽然提高了系统吞吐量，但也产生了一些与顺序执行时不同的特征：</p><ol><li><p>间断性 </p><p>程序在并发执行时，由于它们共享资源或为完成同一任务而相互合作，致使在并发执行的程序之间形成了相互制约的关系，具有“执行–暂停–执行”的特征。</p></li><li><p>失去封闭性 </p><p>程序在并发执行时，系统中的资源状态将由多个程序来改变，使程序的运行失去了封闭性。</p></li><li><p>不可再现性 </p><p>程序在并发执行时，由于失去了封闭性，其计算结果与并发程序的执行速度有关，程序经过多次执行后，虽然执行时的环境和初始条件相同，但得到的结果却大不相同。</p></li></ol></li></ol></li><li><p>进程</p><p>为使程序能并发执行，并且为了对并发执行的程序加以描述和控制，引入了进程的概念。进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>进程的特征包括：</p><ol><li><p>动态性 </p><p>进程的实质是进程实体的一次执行过程，故动态性是进程最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤销而消亡”。可见，进程实体有 一定的生命期，而程序则只是一组有序指令的集合，其本身并不具有运动的含义，因而是静态的。</p></li><li><p>并发性</p><p>并发性是指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征，同时也成为操作系统的重要特征。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行，而程序是不能并发执行的。</p></li><li><p>独立性 </p><p>独立性是指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。</p></li><li><p>异步性 </p><p>异步性是指进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行。</p></li><li><p>结构特征</p><p>为使程序能独立运行，应为之配置一进程控制块，即 PCB（Process Control Block）；而由<strong>程序段、相关的数据段和 PCB 三部分便构成了进程实体</strong>。在许多情况下所说的进 程，实际上是指进程实体，创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程的 PCB。</p><p>PCB 是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB 中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。</p><p>在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，即<strong>系统是根据进程的 PCB 感知该进程的存在，PCB 是进程存在的唯一标志。</strong>因为 PCB 经常被系统访问，故 PCB 应常驻内存。</p><p>进程控制块中主要包括四方面的信息：进程标识符、处理机状态、进程调度信息和控制信息。</p></li></ol></li><li><p>线程</p><ol><li><p>概念</p><p>在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使操作系统具有更好的并发性。</p><p>在多线程操作系统中，将拥有资源的基本单位与调度和分派的基本单位分开处理，<strong>进程只是拥有资源的基本单位，而不再是一个可执行的实体</strong>，<strong>每个线程都是一个可执行的实体，是 CPU 调度和分派的基本单位</strong>。此时，一个进程中含有一个或多个相对独 立的线程，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效地提高系统内多个程序间并发执行的程度。</p><p>线程可以利用线程标识符和一组状态参数（包括寄存器、运行状态等现场信息）来描述，并具有下述属性：</p><ol><li><p>轻型实体 </p><p>除了一点在运行中必不可少的资源外，线程基本上不拥有系统的资源。</p></li><li><p>独立调度和分派的基本单位 </p><p>线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。</p></li><li><p>可并发执行 </p><p>同一个进程中的多个线程，以及不同进程中的多个线程均可以并发地执行。</p></li><li><p>共享进程资源 </p><p>同一个进程中的各线程可以共享该进程所拥有的全部资源，如进程的地址空间、已打开的文件等。</p></li></ol></li><li><p>线程和进程的比较 </p><p>下面从调度、并发、资源和系统开销等方面对线程和进程进行比较：</p><ol><li><p>调度 </p><p>在传统的操作系统中，作为拥有资源的基本单位和独立调度、分派的基本单位都是进程。在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位，线程基本上不拥有资源。</p></li><li><p>并发 </p><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可并发执行。</p></li><li><p>资源 </p><p>不论是传统的操作系统，还是引入了线程的操作系统，进程都可以拥有资源，是系统中拥有资源的一个基本单位。一般而言，线程自己不拥有系统资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源。</p></li><li><p>系统开销 </p><p>在创建或撤销进程时，系统都要为之创建和回收进程控制块，分配或回收资源，操作系统所付出的开销明显大于线程创建或撤销时的开销。</p></li></ol></li></ol></li></ol><h3 id="2-1-2-进程状态"><a href="#2-1-2-进程状态" class="headerlink" title="2.1.2 进程状态"></a>2.1.2 进程状态</h3><ol><li><p>三种基本状态</p><p>进程具有以下三种基本状态：</p><ol><li><p>就绪 </p><p>进程已获得除了 CPU 以外的所有必要资源，只要再获得 CPU，便可立即执行，此时的状态称为就绪状态。</p></li><li><p>执行（或运行） </p><p>进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</p></li><li><p>阻塞（或等待） </p><p>正在执行的进程由于发生某事件（如请求 I/O）而暂时无法继续执行时，便放弃处理机而处于暂停状态，这种暂停状态称为阻塞状态，有时也称等待状态。</p><p><img src="/images/image-20210810110615568.png" alt="image-20210810110615568"></p></li></ol></li><li><p>挂起状态</p><ol><li><p>引入挂起状态的原因 </p><p>不少系统中进程只有上述三种状态，但在另一些系统中，又增加了挂起状态。引入挂起状态的原因有：</p><ol><li>终端用户的请求 </li></ol><p>当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来，以便用户研究其执行情况或对程序进行修改。这种静止状态称为挂起状态。</p><ol start="2"><li>父进程请求 </li></ol><p>有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。</p><ol start="3"><li>负荷调节的需要 </li></ol><p>当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。</p><ol start="4"><li>操作系统的需要 </li></ol><p>操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</p></li><li><p>进程状态的转换 </p><p>在引入挂起状态后，又将增加从挂起状态（也称静止状态）到非挂起状态（又称活动状态）的转换；或者相反。可有以下几种情况：</p><ol><li>活动就绪→静止就绪 </li></ol><p>当进程处于未被挂起的就绪状态时，称它为活动就绪状态。当该进程挂起后，该进程便转变为静止就绪状态，进程不再被调度执行。</p><ol start="2"><li>静止就绪→活动就绪 </li></ol><p>处于静止就绪状态的进程被激活后，该进程将转变为活动就绪状态。</p><ol start="3"><li>活动阻塞→静止阻塞 </li></ol><p>当进程处于未被挂起的阻塞状态时，称它处于活动阻塞状态。当进程挂起后，便转变为静止阻塞状态。处于该状态的进程在其所期待的事件出现后，将从静止阻塞变为静止就绪。</p><ol start="4"><li>静止阻塞→活动阻塞 </li></ol><p>处于静止阻塞状态的进程被激活后，该进程将转变为活动阻塞状态。</p></li></ol></li><li><p>创建状态和终止状态</p><p>在目前实际的系统中，还存在着两种比较常见的进程状态，即创建状态和终止状态：</p><ol><li><p>创建状态 </p><p>当一个新进程被创建时，系统已为其分配了 PCB，但进程自身还未进入内存，即创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。</p></li><li><p>终止状态 </p><p>当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。</p></li></ol></li></ol><h2 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h2><p>进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个已完成的进程，或终止一个因出现某事件而使其无法运行下去的进程，还可负责进程运行中的状态转换。</p><p><strong>原语（Primitive）是由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于：它们是“原子操作”。原子操作是指一个操作中的所有动作要么全做，要么全不做，即它是一个不可分割的基本单位，因此，在执行过程中不允许被中断。</strong>原子操作在管态下执行，常驻内存。</p><h3 id="2-2-1-进程的创建"><a href="#2-2-1-进程的创建" class="headerlink" title="2.2.1 进程的创建"></a>2.2.1 进程的创建</h3><p>在多道程序环境中，只有进程才能在系统中运行。因此，为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的典型事件有以下四类：用户登录；作业调度；提供服务；应用请求。</p><h3 id="2-2-2-进程的终止"><a href="#2-2-2-进程的终止" class="headerlink" title="2.2.2 进程的终止"></a>2.2.2 进程的终止</h3><p>引起进程终止的事件主要有：</p><ol><li>正常结束</li><li>异常结束。常见的异常事件有：越界错误、非法指令、运行超时、等待超时、I/O 故障等</li><li>外界干预。指进程应外界的请求而终止运行。外界干预有：操作员或操作系统干预、父进程请求、父进程终止</li></ol><h3 id="2-2-3-进程的阻塞与唤醒"><a href="#2-2-3-进程的阻塞与唤醒" class="headerlink" title="2.2.3 进程的阻塞与唤醒"></a>2.2.3 进程的阻塞与唤醒</h3><p>引起进程阻塞和唤醒的事件主要有：请求系统服务；启动某种操作；新数据尚未到达；无新工作可做。</p><h2 id="2-3-进程通信"><a href="#2-3-进程通信" class="headerlink" title="2.3 进程通信"></a>2.3 进程通信</h2><p>进程通信，是指进程之间的信息交换。进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。</p><p>随着操作系统的发展，用于进程之间实现通信的机制也在发展，并已由早期的低级进程通信机制发展为能传送大量数据的高级通信工具机制。高级通信机制可归结为三大类：共享存储器通信、消息传递以及管道通信。</p><h3 id="2-3-1-共享存储器系统"><a href="#2-3-1-共享存储器系统" class="headerlink" title="2.3.1 共享存储器系统"></a>2.3.1 共享存储器系统</h3><p>在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。主要分为以下两种类型：</p><ol><li><p>基于共享数据结构的通信方式 </p><p>在这种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。这种通信方式低效，只适于传递相对少量的数据。</p></li><li><p>基于共享存储区的通信方式 </p><p>为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读或写来实现通信。</p></li></ol><h3 id="2-3-2-消息传递"><a href="#2-3-2-消息传递" class="headerlink" title="2.3.2 消息传递"></a>2.3.2 消息传递</h3><p>消息传递系统是当前应用最为广泛的一种进程间的通信机制。</p><p>在该机制中，进程间的数据交换是以格式化的消息为单位的。程序员直接利用操作系统提供的一组通信命令（原语），不仅能实现大量数据的传递，而且还隐藏了通信的实现细节，使通信过程对用户是透明的，从而大大减化了通信程序编制的复杂性，因而获得了广泛的应用。</p><p>在当今最为流行的微内核操作系统中，微内核与服务器之间的通信都采用了消息传递机制。</p><p>根据其实现方式的不同，可分成<strong>直接通信方式</strong>和<strong>间接通信方式</strong>两种：</p><ol><li><p>直接通信方式 </p><p>这是指发送进程利用 OS 所提供的发送命令，直接把消息发送给目标进程。此时，要求发送进程和接收进程都以显式方式提供对方的标识符。通常，系统提供两条通信命令（原语）：发送消息 Send 和接收消息 Receive 两条原语，前者向一个给定的目标发送一个消息，后者则从一个给定的源接收一条消息。</p></li><li><p>间接通信方式 </p><p>间接通信方式指进程之间的通信需要通过作为共享数据结构的实体。该实体用来暂存发送进程发送给目标进程的消息；接收进程则从该实体中取出对方发送给自己的消息。通常把这种中间实体称为信箱。消息在信箱中可以安全地保存，只允许核准的目标用户随时读取。信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类：</p><ol><li>私用信箱 </li></ol><p>用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。当拥有该信箱的进程结束时，信箱也随之消失。</p><ol start="2"><li>公用信箱 </li></ol><p>它由操作系统创建，并提供给系统中的所有核准进程使用。核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。通常，公用信箱在系统运行期间始终存在。</p><ol start="3"><li>共享信箱 </li></ol><p>它由某进程创建，在创建时或创建后指明它是可共享的，同时须指出共享进程的名字。信箱的拥有者和共享者都有权从信箱中取走发送给自己的消息。</p></li></ol><h3 id="2-3-3-管道通信"><a href="#2-3-3-管道通信" class="headerlink" title="2.3.3 管道通信"></a>2.3.3 管道通信</h3><p><strong>“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又称 pipe 文件</strong>。管道是单向的，写进程视管道文件为输出文件，以字符流的形式把大量数据送入管道；读进程视管道文件为输入文件，从管道中接收数据。这种方式首创于 Unix 系统。</p><h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><p>进程同步的主要任务是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p><h3 id="2-4-1-临界资源和临界区"><a href="#2-4-1-临界资源和临界区" class="headerlink" title="2.4.1 临界资源和临界区"></a>2.4.1 临界资源和临界区</h3><p><strong>在一段时间内只允许一个进程访问的资源称为临界资源</strong>。计算机系统中的许多硬件资源如打印机、磁带机等，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。 </p><p><strong>每个进程中访问临界资源的那段代码被称为临界区</strong>。</p><p>如果此刻该临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区。相应地，在临界区后面也要加上一段称为退出区的代码，用于将临界区正被访问的标志恢复为未被访问的标志。</p><h3 id="2-4-2-同步机制应遵循的规则"><a href="#2-4-2-同步机制应遵循的规则" class="headerlink" title="2.4.2 同步机制应遵循的规则"></a>2.4.2 同步机制应遵循的规则</h3><p>为实现进程互斥地进入自已的临界区，可在系统中设置专门的同步机制来协调各进程间的运行。所有的同步机制都应遵循以下四条准则：</p><ol><li>空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</li><li>忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</li><li>有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</li><li>让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。</li></ol><h3 id="2-4-3-信号量机制"><a href="#2-4-3-信号量机制" class="headerlink" title="2.4.3 信号量机制"></a>2.4.3 信号量机制</h3><p>信号量机制是一种进程同步工具，它用信号量及 P(通过)、V（释放） 操作来实现进程的同步和互斥。<strong>信号量的数值与相应资源的使用情况有关：当数值&gt;0 时，表示当前可用资源数量；当数值&lt;0 时，其绝对值表示等待使用该资源的进程个数。</strong>该值仅能由 P 操作、V操作改变（P、V 操作是低级通信方式）。</p><p>P 操作 P(S)包含两步：</p><ol><li>S=S－1；</li><li>若 S&lt;0，表示该类资源已分配完毕，该进程进入等待队列；否则继续执行。</li></ol><p>V 操作 V(S)包含两步：</p><ol><li>S=S+1；</li><li>若 S&lt;=0，释放等待队列中第一个等待信号量的进程；否则继续执行。</li></ol><p>信号量的应用示例：</p><p><img src="/images/image-20210810114231062.png" alt="image-20210810114231062"></p><p><img src="/images/image-20210810114307005.png" alt="image-20210810114307005"></p><h3 id="2-4-4-管程"><a href="#2-4-4-管程" class="headerlink" title="2.4.4 管程"></a>2.4.4 管程</h3><p>信号量机制虽然是一种方便、有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作 P 操作和 V 操作，这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。因此产生了一种<strong>新的进程同步工具管程（Monitors）</strong>。</p><p>管程概念的思路来源：利用共享数据结构抽象地表示系统中的共享资源，把对该共享数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放和其它操作，都通过这组过程对共享数据结构的操作来实现，这组过程还可以根据资源的情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。</p><p>代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，该模块被称为管程。</p><p>管程被请求和释放资源的进程所调用，是一种程序设计语言结构成分，和信号量有同等的表达能力，主要有以下特性：</p><ol><li>模块化。管程是一个基本程序单位，可以单独编译。</li><li>抽象数据类型。管程中不仅有数据，而且有对数据的操作。</li><li>信息掩蔽。管程中的数据结构只能被管程中的过程访问，这些过程在管程内部定义，供管程外的进程调用，管程中的数据结构以及过程（函数）的具体实现外部不可见。</li></ol><p>管程和进程不同，主要体现在以下几个方面：</p><ol><li>虽然二者都定义了数据结构，但进程定义的是私有数据结构 PCB，管程定义的是公共数据结构，如消息队列等；</li><li>二者都存在对各自数据结构上的操作，但进程是由顺序程序执行有关的操作，而管程主要是进行同步操作和初始化操作；</li><li>设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题；</li><li>进程通过调用管程中的过程对共享数据结构实行操作，该过程就如通常的子程序一样被调用，因而管程为被动工作方式，进程则为主动工作方式；</li><li>进程之间能并发执行，而管程则不能与其调用者并发；</li><li>进程具有动态性，由“创建”而诞生，由“撤销”而消亡，而<strong>管程则是操作系统中的一个资源管理模块</strong>，供进程调用。</li></ol><h1 id="3-处理机调度"><a href="#3-处理机调度" class="headerlink" title="3. 处理机调度"></a>3. 处理机调度</h1><h2 id="3-1-分级调度"><a href="#3-1-分级调度" class="headerlink" title="3.1 分级调度"></a>3.1 分级调度</h2><h3 id="3-1-1-处理机调度的层次"><a href="#3-1-1-处理机调度的层次" class="headerlink" title="3.1.1 处理机调度的层次"></a>3.1.1 处理机调度的层次</h3><ol><li><p>作业调度</p><p>1）作业的概念</p><p>作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的那些作业调入内存。</p><p>作业是一个比程序更为广泛的概念，是用户要求计算机所做的关于一次业务处理的全部工作。</p><p>一个作业通常包括程序、数据和操作说明书三部分，系统根据作业说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。</p><p>在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，这其中的每一个加工步骤称为一个作业步。<strong>一个典型的作业可分为编译、链接、运行三个作业步。</strong></p><p>作业控制块（Job Control Block，JCB）是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。在 JCB 中所包含的内容因系统而异，通 常应包含的内容有：作业标识、用户名称、用户帐户、作业类型、调度信息、资源使用情况等。</p><p>2）作业状态 </p><p>一个作业从提交给计算机系统到执行结束退出系统，一般都要经历提交、收容、执行和完成等四个状态。</p><p>一个作业在其处于从输入设备进入外部存储设备的过程称为提交状态。处于提交状态的作业，因其信息尚未全部进入系统，所以不能被调度程序选取。</p><p>收容状态也称为后备状态。输入管理系统不断地将作业输入到外存中对应部分（也称输入井，即专门用来存放待处理作业信息的一组外存分区）。若一个作业的信息已全部被输入到输入井，那么，在它还未被调度去执行之前，该作业处于收容状态。</p><p>作业调度程序从后备作业中选取若干个作业到内存投入运行。它为被选中作业建立进程并分配必要的资源，这时，这些被选中的作业处于执行状态。从宏观上看，这 些作业正处在执行过程中，但从微观上看，在某一时刻，由于处理机总数少于并发执 行的进程数，因此，不是所有被选中作业都占有处理机，其中的大部分处于等待资源 或就绪状态中。那么，究竟哪个作业的哪个进程能获得处理机而真正的执行，要依靠进程调度来决定。</p><p>当作业运行完毕，但它所占用的资源尚未全部被系统回收时，该作业处于完成状态。在这种状态下，系统需做诸如打印结果、回收资源等的善后处理工作。</p></li><li><p>中级调度 </p><p>中级调度又称中程调度，引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程调至外存上去等待，把此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。</p></li><li><p>进程调度 </p><p>进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。</p><p>进程调度的方式有两种：非抢占方式和抢占方式，其中，抢占方式基于的原则有三个：优先权原则、短进程优先原则、时间片原则。</p></li></ol><h3 id="3-1-2-调度算法的准则"><a href="#3-1-2-调度算法的准则" class="headerlink" title="3.1.2 调度算法的准则"></a>3.1.2 调度算法的准则</h3><ol><li><p>面向用户的准则</p><p>1）周转时间短</p><p><strong>从作业被提交给系统开始，到作业完成为止的这段时间间隔称为作业周转时间</strong>。 假设 *T<sub>i</sub>*为作业 <em>i</em> 的周转时间，则平均周转时间 <em>T</em> 的计算公式为：</p><p><img src="/images/image-20210810145041079.png" alt="image-20210810145041079"></p><p>**作业的周转时间 *T<sub>i</sub>*与系统为它提供服务的时间 <em>Ts<sub>i</sub></em> 之比，称为带权周转时间**，则平均带权周转时间 <em>W</em> 的计算公式为：</p><p><img src="/images/image-20210810145205121.png" alt="image-20210810145205121"></p><ol start="2"><li>响应时间快 </li></ol><p>响应时间是从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。</p><ol start="3"><li>截止时间的保证 </li></ol><p>截止时间是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则将可能造成难以预料的后果。</p><ol start="4"><li>优先权准则 </li></ol><p>在批处理、分时和实时系统中选择调度算法时，都可遵循优先权准则，以便让某些紧急的作业能得到及时处理。</p></li><li><p>面向系统的准则</p><ol><li>系统吞吐量高 </li></ol><p><strong>吞吐量是指在单位时间内系统所完成的作业数</strong>，这是用于评价批处理系统性能的另一个重要指标，因而是选择批处理作业调度的重要准则。</p><ol start="2"><li>处理机利用率好 </li></ol><p>对于大、中型多用户系统，由于 CPU 价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标，因此在大、中型系统中，在选择调度方式和算法时，应考虑到这一准则。而对于单用户微机或某些实时系统，此准则就不那么重要。</p><ol start="3"><li>各类资源的平衡利用 </li></ol><p>在大、中型系统中，不仅要使处理机的利用率高，而且还应能有效地利用其它各类资源，如内存、外存和 I/O 设备等。</p></li></ol><h2 id="3-2-调度算法"><a href="#3-2-调度算法" class="headerlink" title="3.2 调度算法"></a>3.2 调度算法</h2><p>在 OS 中调度的实质是一种资源分配。调度算法是指：根据系统的资源分配策略所规定的资源分配算法。对于不同的系统和系统目标，通常采用不同的调度算法：在批处理系统中，为了照顾为数众多的短作业，应采用短作业优先的调度算法；在分时系统中，为了保证系统具有合理的响应时间，应采用轮转法进行调度。目前存在的多种调度算法中，有的算法适用于作业调度，有的算法适用于进程调度，但也有些调度算法既可用于作业调度，也可用于进程调度。</p><h3 id="3-2-1-先来先服务调度算法"><a href="#3-2-1-先来先服务调度算法" class="headerlink" title="3.2.1 先来先服务调度算法"></a>3.2.1 先来先服务调度算法</h3><p>先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。</p><p>假设有 5 个进程 A、B、C、D、E，到达时间分别是 0，1，2，3，4，每个进程所需 CPU 的服务时间是 3，6，4，5，2，利用 FCFS 算法进程的调度顺序是 A、B、C、D、E，调度的平均周转时间和平均带权周转时间见表 </p><p><img src="/images/image-20210810145844855.png" alt="image-20210810145844855"></p><h3 id="3-2-2-短作业-进程优先调度算法"><a href="#3-2-2-短作业-进程优先调度算法" class="headerlink" title="3.2.2 短作业/进程优先调度算法"></a>3.2.2 短作业/进程优先调度算法</h3><p>短作业/进程优先调度算法（Shortest Job/Process First，SJ/PF），是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间 最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><p>进程调度的顺序是 A、C、E、D、B。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程，因此在此例中进程 A 首先被调度，当进程 A 运行完成后，在已进入系统的B、C、D 三个进程中，选择要求服务时间最短的 C 进程进行调度，然后当 C 进程运行完成后，E 进程也已经进入系统，此时在 B、D、E 三个未被调度的进程中选择，根据每个进程的要求服务的时间，依次执行 E、D、B。</p><p><img src="/images/image-20210810150025089.png" alt="image-20210810150025089"></p><p>SJ/PF 调度算法也存在不容忽视的缺点：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于作业/进程的长短只 是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</p><h3 id="3-2-3-高优先权优先调度算法"><a href="#3-2-3-高优先权优先调度算法" class="headerlink" title="3.2.3 高优先权优先调度算法"></a>3.2.3 高优先权优先调度算法</h3><p>作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。优先权调度算法可分为：非抢占式优先权算法、抢占式优先权调度算法。</p><p>对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。</p><ol><li><p>静态优先权 </p><p>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。</p></li><li><p>动态优先权 </p><p>动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</p><p>动态优先权的变化规律可描述为： </p><p>优先权 =（等待时间+要求服务时间）/要求服务时间 </p><p>​            = 响应时间/要求服务时间 </p><p>​            = 响应比</p><p>这种算法即为高响应比优先调度算法（Highest Response-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><p>在该例中进程的调度顺序是 A、B、E、C、D。开始时系统首先调度进程 A，当进程 A 执行完后分别计算巳进入系统的 B，C，D 三个进程的响应比：</p><p><img src="/images/image-20210810150437329.png" alt="image-20210810150437329"></p><p>得到 B 进程的响应比最高，因此先被调度，当进程 B 运行完后再次计算进程 C、D、E 当前的响应比，根据结果调度进程 E，当进程 E 运行完后重新计算 C、D 两个进程当前的响应比，然后依次调度 C、D。</p><p><img src="/images/image-20210810150542408.png" alt="image-20210810150542408"></p></li></ol><h3 id="3-2-4-基于时间片的轮转调度算法"><a href="#3-2-4-基于时间片的轮转调度算法" class="headerlink" title="3.2.4 基于时间片的轮转调度算法"></a>3.2.4 基于时间片的轮转调度算法</h3><ol><li><p>时间片轮转法 </p><p>其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将 CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪队列的末尾，同时将 CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。</p><p><img src="/images/image-20210810150810972.png" alt="image-20210810150810972"></p><p>上表给出了当时间片大小 q=1 时调度的过程以及进程的周转时间和带权周转时间。每个进程运行一个时间片就进行轮转。进程 E 需要服务时间为 2，因此经过两 轮循环在时间为 10 处结束运行。第三轮循环时进程 A、B、C、D 进行轮转调度，进程 A 在时间为 11 处结束运行。第四轮循环时进程 B、C、D 进行轮转调度，进程 C 在时间 16 处结束运行。第五轮循环只有 B、D 两个进程参与，进程 D 在时间 19 处结束运行，最后进程 B 在时间 20 处运行完成。</p></li><li><p>多级反馈队列调度算法</p><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目 前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程是：</p><ol><li><p>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。</p><p><img src="/images/image-20210810151138042.png" alt="image-20210810151138042"></p></li><li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业（进程）从第一队列依次降到第 n 队列后，在第 n 队列中便采取按时间片轮转的方式运行。</p></li><li><p>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～（i-1）队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列（第 1～（i-1）中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i 队列的末尾，把处理机分配给新到的高优先权进程。</p></li></ol></li></ol><h2 id="3-3-实时调度"><a href="#3-3-实时调度" class="headerlink" title="3.3 实时调度"></a>3.3 实时调度</h2><p>为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。在含有硬实时任务的实时系统中，广泛采用抢占机制。对于一些小型实时系统，如果能预知任务的开始截止时间，则对实时任务的调度可采用非抢占调度机制。</p><h3 id="3-3-1-分类"><a href="#3-3-1-分类" class="headerlink" title="3.3.1 分类"></a>3.3.1 分类</h3><p>实时调度算法的分类有：</p><ol><li><p>非抢占式调度算法 </p><ul><li><p>非抢占式轮转调度算法； </p></li><li><p>非抢占式优先调度算法。</p></li></ul></li><li><p>抢占式调度算法</p><ul><li>基于时钟中断的抢占式优先权调度算法在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务。此算法可用于大多数的实时系统中。</li><li>立即抢占的优先权调度算法在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</li></ul></li></ol><h3 id="3-3-2-常用算法"><a href="#3-3-2-常用算法" class="headerlink" title="3.3.2 常用算法"></a>3.3.2 常用算法</h3><p>常用的实时调度算法有：</p><ol><li><p>最早截止时间优先算法（Earliest Deadline First，EDF）</p><p>该算法是根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。</p></li><li><p>最低松弛度优先算法（Least Laxity First，LLF） </p><p>该算法是根据任务紧急（或松弛）的程度，来确定任务的优先级。紧急程度（松弛程度）的计算公式为：</p><p>​    松弛度＝任务必须完成时间－其本身的运行时间－当前时间。</p><p>任务的紧急程度越高（即松弛度越低），其优先级就越高。该算法主要用于可抢占调度方式中，当一任务的最低松弛度减为 0 时，它必须立即抢占 CPU，以保证按截止时间的要求完成任务。</p><p>假设在一实时系统中，有两个周期性实时任务 A 和 B，任务 A要求每 20ms 执行一次，执行时间为 10ms；任务 B 要求每 50ms 执行一次，执行时间为 25ms，则任务 A 和 B 每次必须完成的时间分为为 A1，A2，…和 B1，B2，…。</p><p><img src="/images/image-20210810151723944.png" alt="image-20210810151723944"></p><p><img src="/images/image-20210810151757379.png" alt="image-20210810151757379"></p><p>当刚开始 t1=0 时，A1 的松弛度为 20－10－0=10ms，而 B1 的松弛度为 50－25－0=25ms，故应先调度 A1 执行；</p><p>当 t2=10ms 时，A2 的松弛度为 40－10－10=20ms，B1 的松弛度为 50－25－10=15ms，故此时选择 B1 执行；</p><p>当 t3=30ms 时，A2 的松弛度减为 0，此时程序应抢占 B1 的处理机而调度 A2 运行；</p><p>当 t4=40ms 时，A3 的松弛度为 60－10－40=10ms，而 B1 的松弛度为 50－5－40=5ms，故此时应重新选择调度 B1 执行；</p></li></ol><h2 id="3-4-死锁"><a href="#3-4-死锁" class="headerlink" title="3.4 死锁"></a>3.4 死锁</h2><h3 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h3><p>死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p>有两个资源 R1 和 R2 供进程 P1 和 P2 共享，P1 已占用资源 R1，P2 已占用资源 R2，此时若 P2 继续要求 R1,P1 要求 R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。 </p><p><img src="/images/image-20210810152107486.png" alt="image-20210810152107486"></p><ol><li><p>死锁产生的原因</p><p>产生死锁的原因可归结为如下两点：</p><ol><li>**竞争资源 **</li></ol><p>当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。</p><ol start="2"><li>**进程间推进顺序非法 **</li></ol><p>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。</p></li><li><p>死锁产生的必要条件 </p><p>死锁的发生必须具备下列四个必要条件：</p><ol><li><p><strong>互斥条件</strong> </p><p>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。</p></li><li><p><strong>请求和保持条件</strong> </p><p>指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p><strong>不剥夺条件</strong> </p><p>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>**环路等待条件 **</p><p>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…， Pn}中的 P0正在等待一个 P1占用的资源；P1正在等待 P2占用的资源，……，Pn正在等待已被 P0占用的资源。</p></li></ol></li><li><p>死锁的处理 </p><p>为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：</p><ol><li><p>预防死锁 </p><p>这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。</p></li><li><p>避免死锁 </p><p>该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</p></li><li><p>检测死锁 </p><p>这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。</p></li><li><p>解除死锁 </p><p>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。</p></li></ol></li></ol><h3 id="3-4-2-避免死锁"><a href="#3-4-2-避免死锁" class="headerlink" title="3.4.2 避免死锁"></a>3.4.2 避免死锁</h3><p>系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可避免发生死锁。</p><ol><li><p>安全状态 </p><p>安全状态，是指系统能按某种进程顺序（P1，P2，…，Pn）（称〈P1，P2，…，Pn〉序列为安全序列），来为每个进程 Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进入死锁状态。</p></li><li><p>银行家算法</p><p>最有代表性的避免死锁的算法，是 Dijkstra 的银行家算法。（细节先不深入学习）</p></li></ol><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><ol><li><p>死锁的检测 </p><p>系统死锁可利用资源分配图来描述。该图是由一组结点 N 和一组边 E 所组成的一个对偶 G =（N，E），用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有多个，用方框中的一个点代表一类资源中的一个资源。</p><p>可以利用把资源分配图加以简化的方法，来检测当系统处于 S 状态时是否为死锁状态。</p><p><img src="/images/image-20210810153251748.png" alt="image-20210810153251748"></p><p>在进行一系列的简化后，若能消去资源分配图中所有的边，使所有的进程结点都成为孤立结点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p><p>对于较复杂的资源分配图，不同的简化顺序，都将得到相同的不可简化图。 </p><p>死锁定理：S 为死锁状态的充分条件是当且仅当 S 状态的资源分配图是不可完全简化的。</p></li><li><p>死锁的解除 </p><p>当发现有进程死锁时，便应立即把它们从死锁状态中解脱出来。死锁的常用解除方法有两种：<strong>剥夺资源</strong>和<strong>撤销进程</strong>。</p></li></ol><h1 id="4-存储器管理"><a href="#4-存储器管理" class="headerlink" title="4. 存储器管理"></a>4. 存储器管理</h1><h2 id="4-1-存储器概述"><a href="#4-1-存储器概述" class="headerlink" title="4.1 存储器概述"></a>4.1 存储器概述</h2><p>通用计算机的存储层次至少应具有三级：CPU 寄存器、内存和外存。还可根据具体的功能分工细划为寄存器、高速缓存、内存、磁盘缓存、固定磁盘、可移动存储介质等六层。其中，寄存器、高速缓存、内存和磁盘缓存均属于操作系统存储管理的管辖范畴，断电后信息不再存在。固定磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。</p><h3 id="4-1-1-寄存器"><a href="#4-1-1-寄存器" class="headerlink" title="4.1.1 寄存器"></a>4.1.1 寄存器</h3><p>寄存器访问速度最快，完全能与 CPU 协调工作，但价格昂贵，因此容量不可能很大。寄存器的长度一般以字为单位。由于内存的访问速度远低于 CPU 执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。</p><h3 id="4-1-2-高速缓存"><a href="#4-1-2-高速缓存" class="headerlink" title="4.1.2 高速缓存"></a>4.1.2 高速缓存</h3><p>高速缓存是现代计算机结构中的一个重要部件，其容量比寄存器大，而比内存小，访问速度快于内存。通常进程的程序和数据是存放在内存中，使用时被临时复制到高速缓存中。当 CPU 访问信息时，首先检查它是否在高速缓存中，如果已存在，可直接 从中取出使用，以避免访问内存，否则，再从内存中读出信息。由于高速缓存的速度 越高价格也越贵，故有的计算机系统中设置了两级或多级高速缓存。紧靠内存的一级高速缓存的速度最高，而容量最小，二级高速缓存的容量较大，速度较低。</p><h3 id="4-1-3-内存"><a href="#4-1-3-内存" class="headerlink" title="4.1.3 内存"></a>4.1.3 内存</h3><p>内存是计算机系统中一个主要部件，用于保存进程运行时的程序和数据。CPU 只能从内存中取得指令和数据。</p><h3 id="4-1-4-磁盘缓存"><a href="#4-1-4-磁盘缓存" class="headerlink" title="4.1.4 磁盘缓存"></a>4.1.4 磁盘缓存</h3><p>磁盘的 I/O 速度远低于对内存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。磁盘缓存本身并不是一种实际存在的存储介质，它是利用内存的存储空间来暂存从磁盘中读出（或写入）的信息。</p><h3 id="4-1-5-程序的装入与重定位"><a href="#4-1-5-程序的装入与重定位" class="headerlink" title="4.1.5 程序的装入与重定位"></a>4.1.5 程序的装入与重定位</h3><p>将一个用户源程序变为一个可在内存中执行的程序，通常要经过以下三个步骤：首先是编译，由编译程序将用户源代码编译成若干个目标模块；其次是链接，将这些目标模块及所需的库函数，用链接程序链接在一起，形成一个完整的装入模块；最后是装入，由装入程序将这个装入模块装入内存。将一个装入模块装入内存有三种方式：绝对装入方式、可重定位装入方式和动态运行时装入方式。</p><ol><li><p>绝对装入方式 </p><p>若编译时知道程序将驻留在内存的什么位置，则编译程序将产生绝对地址的目标代码。装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不须对程序和数据的地址进行修改。</p></li><li><p>可重定位装入方式 </p><p>绝对装入方式只能将目标模块装入到内存中事先指定的位置，因此只适用于单道程序环境。</p><p>在多道程序环境下，所得到的目标模块的起始地址通常从 0 开始，程序中的其它地址也都是相对于起始地址计算的，此时应采用可重定位装入方式，将装入模块装入内存的适当位置，这会使得装入模块中的所有逻辑地址与实际装入内存的物理地址不同，这个地址变换的过程称为<strong>地址重定位</strong>。因为把装入模块装入内存时，地址变换在装入时一次性完成，之后不再改变，故又称为静态重定位。</p></li><li><p>动态运行时装入方式 </p><p>可重定位装入方式并不允许程序运行时在内存中移动位置。而实际情况是，在运行过程中，程序在内存中的位置可能经常要改变，此时应采用动态运行时装入的方式：不在程序运行之前进行重定位，而是把这种地址转换推迟到程序执行期间进行，又称动态重定位。</p></li></ol><h2 id="4-2-连续内存分配"><a href="#4-2-连续内存分配" class="headerlink" title="4.2 连续内存分配"></a>4.2 连续内存分配</h2><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：<strong>单一连续分配</strong>、<strong>固定分区分配</strong>、<strong>动态分区分配</strong>以及<strong>动态重定位分区分配</strong>四种。</p><h3 id="4-2-1-单一连续分配"><a href="#4-2-1-单一连续分配" class="headerlink" title="4.2.1 单一连续分配"></a>4.2.1 单一连续分配</h3><p>单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给 OS 使用，通常是放在内存的低址部分；用户区是指除系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。</p><h3 id="4-2-2-固定分区分配"><a href="#4-2-2-固定分区分配" class="headerlink" title="4.2.2 固定分区分配"></a>4.2.2 固定分区分配</h3><p>固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。</p><p>采用固定分区分配方法存在以下缺点：</p><ol><li>由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；</li><li>内存利用率不高，作业很少能恰好填满分区；</li><li>固定分区无法实现动态扩充内存空间的要求；</li><li>由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。</li></ol><h3 id="4-2-3-动态分区分配"><a href="#4-2-3-动态分区分配" class="headerlink" title="4.2.3 动态分区分配"></a>4.2.3 动态分区分配</h3><p>动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。</p><ol><li><p>分区分配中的数据结构 </p><p>为实现分区分配，系统中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况。常用的数据结构有以下两种形式：<strong>空闲分区表</strong>和<strong>空闲分区链</strong>。</p></li><li><p>分区分配算法 </p><p>常用的分配算法主要有以下五种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法、快速适应算法。</p><p>1）首次适应算法 </p><p>该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表或链 中。该算法优先使用内存低址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。</p><p>2）循环首次适应算法 </p><p>该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。</p><p>3）最佳适应算法 </p><p>该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总是最小的，它会在内存中留下大量难以利用的小空闲分区。</p><p>4）最坏适应算法 </p><p>该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。</p><p>最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，称为顺序搜索法。</p><p>5）快速适应算法 </p><p>将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分，如 2KB、4KB、8KB 等，对于其它大小的分区，如 7KB 这样的空闲区，既可以放在 8KB 的链表中，也可以放在一个特殊的空闲区链表中。</p><p><img src="/images/image-20210810160120192.png" alt="image-20210810160120192"></p></li><li><p>内存回收</p><p>当进程运行完毕释放内存时，需要进行内存的回收。系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时可能出现以下几种情况：</p><ol><li>回收区与插入点的前一个空闲分区 F1 相邻接。此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区 F1 的大小。</li><li>回收分区与插入点的后一空闲分区 F2 相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。</li><li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用 F1 的表项和 F1 的首址，取消 F2 的表项，大小为三者之和。</li><li>回收区既不与 F1 邻接，又不与 F2 邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</li></ol></li></ol><h3 id="4-2-4-可重定位分区分配（动态重定位分区分配）"><a href="#4-2-4-可重定位分区分配（动态重定位分区分配）" class="headerlink" title="4.2.4 可重定位分区分配（动态重定位分区分配）"></a>4.2.4 可重定位分区分配（动态重定位分区分配）</h3><p>在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。</p><p>上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。</p><p>可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。</p><h2 id="4-3-分页和分段存储管理"><a href="#4-3-分页和分段存储管理" class="headerlink" title="4.3 分页和分段存储管理"></a>4.3 分页和分段存储管理</h2><p>连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法加以解决，但须为之付出很大开销。因此，OS 中又引入了离散分配方式，它将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题。</p><p>如果离散分配的基本单位是页，则称为分页存储管理方式；如果离散分配的基本单位是段，则称为分段存储管理方式。</p><h3 id="4-3-1-基本的分页存储管理"><a href="#4-3-1-基本的分页存储管理" class="headerlink" title="4.3.1 基本的分页存储管理"></a>4.3.1 基本的分页存储管理</h3><p>在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。</p><ol><li><p>页面与页表 </p><p><strong>基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</strong>相应地，<strong>将内存空间分成若干个与页面同样大小的块，称为物理块或页框</strong>。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。</p><p>为了地址映射的方便，页面的大小通常设置成 2 的幂。如果页面的大小为 2<sup>k</sup>字节，逻辑地址的长度为 n 位，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的 n-k 位为页号 P。</p><p><img src="/images/image-20210810161338838.png" alt="image-20210810161338838"></p><p>在进程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称<strong>页表</strong>，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。</p><p>下图给出了分页系统的一个内存分配实例，其中页面大小为 4K，用户作业的大小为 11K。由于进程的最后一页不足一块，因此造成了存放该页的物理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。</p><p><img src="/images/image-20210810161535970.png" alt="image-20210810161535970"></p></li><li><p>地址变换机构 </p><p>页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。</p><p>【例题】在一个页式存储管理系统中，页表内容如下所示：</p><p><img src="/images/image-20210810161651645.png" alt="image-20210810161651645"></p><p>若页的大小为 4K，则地址转换机构将逻辑地址 100 转换成的物理地址是多少?</p><p>【解析】 </p><p>页的大小为 4K，逻辑地址为 100，易知所在页号为 0，页内偏移量为 100，由页表可知页号 0 所对应的块号为 2，则其对应的物理地址为 4K×2+100=8292。</p><ol><li>基本的地址变换机构 </li></ol><p>通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器 PTR（Page-Table Register），当一进程因 CPU 调度而转入执行状态时，其页表的内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存器与页内地址拼接，形成对应的物理地址。</p><ol start="2"><li>具有快表的地址变换机构 </li></ol><p>由于页表存放在内存中，故 CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近 1/2。</p><p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或<strong>“快表”</strong>，用以存放当前访问的那些页表项。</p><p>在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。</p></li><li><p>多级页表</p><p>现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。</p><p>对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层页表，用来记录存放各页表页的内存块号，从而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。</p><p>如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。</p></li></ol><h3 id="4-3-2-基本的分段存储管理"><a href="#4-3-2-基本的分段存储管理" class="headerlink" title="4.3.2 基本的分段存储管理"></a>4.3.2 基本的分段存储管理</h3><p>用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足用户的上述要求，因此又引入了分段式存储管理方式。</p><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其<strong>逻辑地址由段号和段内地址所组成</strong>。</p><p>分段地址中的地址具有下图结构：</p><p><img src="/images/image-20210810162558702.png" alt="image-20210810162558702"></p><p>在该地址结构中，允许一个作业最长有64 K个段，每个段的最大长度为64 KB。</p><ol><li><p>段表</p><p>在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。 每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。</p><p>在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。</p></li><li><p>地址变换机构 </p><p>为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存器中的段表长度进行比较，若段号不小于段表长度， 便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。</p><p>【例题】对于下表所示的段表，请将逻辑地址（0，137），（1，4000），（2， 3600），（5，230）转换为物理地址。</p><p><img src="/images/image-20210810162925631.png" alt="image-20210810162925631"></p><p>【解析】 </p><ul><li>段号 0 小于段表长 5，故段号合法；由段表的第 0 项可获得段的内存始址为50K，段长为 10K；由于段内地址 137 小于段长 10K，故段内地址也是合法的，因此可得出对应的物理地址为 50K+137=51337。</li><li>段号 1 小于段表长，故段号合法；由段表的第 1 项可获得段的内存始址为60K，段长为 3K；由于段内地址 4000 超过段长 3K，因此产生越界中断。</li><li>段号 2 小于段表长，故段号合法；由段表的第 2 项可获得段的内存始址为70K，段长为 5K；段内地址 3600 小于段长 5K，也是合法的，因此可得出对应的物理地址为70K+3600=75280。</li><li>段号 5 等于段表长，故段号不合法，产生越界中断。</li></ul></li><li><p>分页和分段的主要区别</p><p>分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：</p><ol><li><p>页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。</p></li><li><p>页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。</p></li><li><p>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个 地址时，既需给出段名，又需给出段内地址。</p></li></ol></li><li><p>段页式存储管理方式 </p><p>为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。</p><p>段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。<strong>在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成</strong>。</p><p>在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。</p></li></ol><h2 id="4-4-虚拟存储管理"><a href="#4-4-虚拟存储管理" class="headerlink" title="4.4 虚拟存储管理"></a>4.4 虚拟存储管理</h2><h3 id="4-4-1-局部性原理"><a href="#4-4-1-局部性原理" class="headerlink" title="4.4.1 局部性原理"></a>4.4.1 局部性原理</h3><p>程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程 序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：</p><ol><li><p>时间局限性 </p><p>如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。</p></li><li><p>空间局限性 </p><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p></li></ol><p>基于局部性原理产生了虚拟存储器。</p><h3 id="4-4-2-虚拟存储器的实现"><a href="#4-4-2-虚拟存储器的实现" class="headerlink" title="4.4.2 虚拟存储器的实现"></a>4.4.2 虚拟存储器的实现</h3><p><strong>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</strong>。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。</p><p>虚拟存储器的实现，建立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的:</p><ol><li><p>请求分页系统 </p><p>在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。</p></li><li><p>请求分段系统 </p><p>在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。</p></li></ol><h3 id="4-4-3-虚拟存储器的特征"><a href="#4-4-3-虚拟存储器的特征" class="headerlink" title="4.4.3 虚拟存储器的特征"></a>4.4.3 虚拟存储器的特征</h3><p>虚拟存储器具有<strong>多次性</strong>、<strong>对换性</strong>和<strong>虚拟性</strong>三大主要特征。</p><ol><li><p>多次性 </p><p>多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。</p></li><li><p>对换性 </p><p>在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运行条件的进程或进程所需要的程序和数据调入内存。</p><p>如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。</p></li><li><p>虚拟性</p><p>虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。</p><p>虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。</p></li></ol><h3 id="4-4-4-请求分页存储管理方式"><a href="#4-4-4-请求分页存储管理方式" class="headerlink" title="4.4.4 请求分页存储管理方式"></a>4.4.4 请求分页存储管理方式</h3><p>请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。</p><p>为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：</p><ol><li><p>预调页策略 </p><p>如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。</p></li><li><p>请求调页策略 </p><p>当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由 OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。</p></li></ol><h2 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="4.5 页面置换算法"></a>4.5 页面置换算法</h2><p>置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为<strong>“抖动”</strong>。</p><p>好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。</p><h3 id="4-5-1-最佳（OPT）置换算法"><a href="#4-5-1-最佳（OPT）置换算法" class="headerlink" title="4.5.1 最佳（OPT）置换算法"></a>4.5.1 最佳（OPT）置换算法</h3><p>最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。</p><p>为了讨论页面置换算法，将采用如下页面号引用串：1、2、3、4、1、2、5、1、2、3、4、5，系统为某进程分配了三个物理块，初始状态三个物理块均为空闲。</p><p><img src="/images/image-20210810170144177.png" alt="image-20210810170144177"></p><p>上表列出了物理块数为 3 时的页面置换情况，√表示产生缺页中断，缺页次数为 7，缺页率为 7/12 ≈ 58%。由于初始状态内存的 3 个物理块均为空，因此访问前三个页面 1、2、3 时都会产生缺页中断。当进程第一次对页面 4 进行访问时，首先发出缺页中断，选择 1、2、3 三个页面中未来—段时间内不会访问的页面 3 进行置换，页面 4 换入内存然后进行访问。根据页面走向依次处理，得到最终的置换结果。</p><h3 id="4-5-2-先进先出（FIFO）页面置换算法"><a href="#4-5-2-先进先出（FIFO）页面置换算法" class="headerlink" title="4.5.2 先进先出（FIFO）页面置换算法"></a>4.5.2 先进先出（FIFO）页面置换算法</h3><p>FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。</p><p><img src="/images/image-20210810170547668.png" alt="image-20210810170547668"></p><p>上表列出了物理块数为 3 时的页面置换情况，缺页次数为 9， 缺页率为 9/12=75%。</p><p><img src="/images/image-20210810170719724.png" alt="image-20210810170719724"></p><p>一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求 的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页面，则不会发生缺页现象。但是，使用 FIFO 算法时， 在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为 Belady 现象。</p><p>上表给出了物理块数为 4 时的页面置换情况，缺页中断次数为 10。可见系统分配给该进程的物理块数从 3 块变成 4 块，缺页中断次数从 9 次变成 l0 次，缺页次数反而增加。不过，这种现象并不常见。</p><h3 id="4-5-3-最近最久未使用（LRU）置换算法"><a href="#4-5-3-最近最久未使用（LRU）置换算法" class="headerlink" title="4.5.3 最近最久未使用（LRU）置换算法"></a>4.5.3 最近最久未使用（LRU）置换算法</h3><p>LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。</p><p>对于前面的样例，下表列出了物理块数为 3 时的页面置换情况，缺页次数为10，缺页率为10/12≈83%。</p><p><img src="/images/image-20210810170952806.png" alt="image-20210810170952806"></p><p>LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。 </p><p>关于确定最后使用时间的问题，对于移位寄存器而言，当进程访问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。</p><p>对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。</p><h3 id="4-5-4-Clock-置换算法"><a href="#4-5-4-Clock-置换算法" class="headerlink" title="4.5.4 Clock 置换算法"></a>4.5.4 Clock 置换算法</h3><p>LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用 LRU 的近似算法。Clock 算法就是用得较多的一种 LRU 近似算法。</p><ol><li><p>简单的 Clock 置换算法 </p><p>Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置 0 后还未使用过，可把该位是 0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为 Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。</p></li><li><p>改进型 Clock 置换算法</p><p>考虑到如果某一调入内存的页没有被修改过，则不必将它拷回到磁盘。于是在改进的 Clock 算法中增加了一个因素，即置换代价，这样，选择页面换出时，既要考虑未访问过的页面，又要考虑未被修改过的页面，把同时满足这两个条件的页面作为首选淘汰的页面。由访问位 A 和修改位 M 可以组合成下面四种类型的页面：</p><ol><li>（A=0，M=0）：该页最近既未被访问也未被修改，是最佳淘汰页；</li><li>（A=0，M=1）：该页最近未被访问但已被修改，并不是很好的淘汰页；</li><li>（A=1，M=0）：该页最近已被访问但未被修改，该页有可能再被访问；</li><li>（A=1，M=1）：表示该页最近已被访问且被修改，该页可能再被访问。</li></ol><p>其执行过程可分成以下三步：</p><ol><li><p>从开始位置扫描循环队列，寻找 A=0 且 M=0 的第一类页面，找到立即置换。在第一次扫描期间不改变访问位 A。</p></li><li><p>如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找 A=0 且 M=1 的第二类页面，找到后立即置换。在第二轮扫描期间，将所有扫描过的页面的访问位都置 0。</p></li><li><p>如果第二步也失败，则返回指针开始位置，然后重复第一步，必要时再重复第二步，此时必能找到被淘汰的页。</p></li></ol></li></ol><h3 id="4-5-5-其它置换算法"><a href="#4-5-5-其它置换算法" class="headerlink" title="4.5.5 其它置换算法"></a>4.5.5 其它置换算法</h3><ol><li><p>最少使用（LFU，Least Frequently Used）置换算法</p><p>在采用最少使用置换算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。 由于存储器具有较高的访问速度，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器方式。</p></li><li><p>页面缓冲算法（PBA，Page Buffering Algorithm）</p><p>页面缓冲算法可改善分页系统的性能，采用一种较简单的置换策略。它采用可变分配和局部置换方式，置换算法采用的是 FIFO。该算法规定将一个被淘汰的页放入两个链表中的一个，即如果页面未被修改，就将它直接放入空闲链表中；否则，便放入已修改页面的链表中。须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。当被修改的页面数目达到一定值时，再将它们一起写回到磁盘上，从而显著减少了磁盘 I/O 的操作次数。</p></li></ol><h1 id="5-设备管理"><a href="#5-设备管理" class="headerlink" title="5. 设备管理"></a>5. 设备管理</h1><h2 id="5-1-I-O-硬件"><a href="#5-1-I-O-硬件" class="headerlink" title="5.1 I/O 硬件"></a>5.1 I/O 硬件</h2><p>设备管理是操作系统的主要功能之一，其基本任务是完成用户提出的 I/O 请求，提高 I/O 速率以及提高 I/O 设备的利用率。I/O 设备不仅种类繁多，而且特性和操作方式往往相差甚大，这就使得设备管理成为操作系统中最庞杂和琐碎的部分。操作系 统中普遍使用 I/O 中断、通道、缓冲器管理等多种技术，较好地克服了由于外部设备和主机速度不匹配所引起的问题，使主机和外设并行工作，提高了使用效率。</p><h3 id="5-1-1-I-O-设备的类型"><a href="#5-1-1-I-O-设备的类型" class="headerlink" title="5.1.1 I/O 设备的类型"></a>5.1.1 I/O 设备的类型</h3><p>I/O 设备的类型繁多，可从不同角度对它们进行分类：</p><ol><li><p>按设备的使用特性分类 </p><p>按设备的使用特性，可将设备分为两类：一类是存储设备，也称外存、辅存，是计算机系统用以存储信息的主要设备；另一类是输入/输出设备，又具体可分为输入设备、输出设备和交互式设备。</p></li><li><p>按传输速率分类 </p><p>按传输速度的高低，可将 I/O 设备分为三类：一是低速设备，如键盘、鼠标等；二是中速设备，如打印机等；三是高速设备，如磁带、磁盘、光盘等。</p></li><li><p>按信息交换的单位分类 </p><p>按信息交换的单位，可将 I/O 设备分成两类：第一类是块设备，这类设备用于存储信息，由于信息的存取是以数据块为单位的，故称其为块设备，属于有结构设备，如磁盘等；第二类是字符设备，用于数据的输入和输出，其基本单位是字符，故称字符设备，属于无结构类型，如交互式终端、打印机等。</p></li><li><p>按设备的共享属性分类 </p><p>这种分类方式可将 I/O 设备分为如下三类：</p><ol><li>独占设备 </li></ol><p>独占设备是指在一段时间内只允许一个进程访问的设备，即临界资源。对多个并发进程而言，应互斥地访问这类设备。</p><ol start="2"><li>共享设备 </li></ol><p>共享设备是指在一段时间内允许多个进程同时访问的设备，如磁盘等。该类设备每一时刻仍然只允许一个进程访问。共享设备不仅可获得良好的设备利用率，而且是实现文件系统和数据库系统的物质基础。</p><ol start="3"><li>虚拟设备 </li></ol><p>虚拟设备是指通过虚拟技术将一台独占设备变换为若干台逻辑设备，供若干个进程同时使用。</p></li></ol><h3 id="5-1-2-设备控制器"><a href="#5-1-2-设备控制器" class="headerlink" title="5.1.2 设备控制器"></a>5.1.2 设备控制器</h3><ol><li><p>概述 </p><p>设备控制器是 CPU 与 I/O 设备之间的接口，它接收从 CPU 发来的 I/O 命令，并控制 I/O 设备工作，以使处理机从繁杂的设备控制事务中解脱出来。</p><p>设备控制器是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；若控制器可连接多个设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。</p><p>设备控制器分成两类：一类是用于控制字符设备，另一类用于控制块设备。在微型机和小型机中的控制器，常做成印刷电路卡形式，因而也常称为接口卡，可将它插入计算机。</p><p>设备控制器的基本功能包括：接收和识别命令、数据交换、标识和报告设备的状态、地址识别、数据缓冲和差错控制。</p></li><li><p>组成 </p><p>由于设备控制器位于 CPU 与设备之间，既要与 CPU 通信，又要与设备通信，还应具有按照 CPU 所发来的命令去控制设备工作的功能，因此，大多数控制器都是由以下三部分组成：</p><ol><li>设备控制器与处理机的接口 </li></ol><p>该接口用于实现 CPU 与设备控制器之间的通信，共有三类信号线: 数据线、地址线和控制线。数据线通常与两类寄存器相连接，第一类是数据寄存器，用于存放从设备送来的数据或从 CPU 送来的数据；第二类是控制/状态寄存器，用于存放从 CPU 送来的控制信息或设备的状态信息。</p><ol start="2"><li>设备控制器与设备的接口 </li></ol><p>在一个设备控制器上，可以连接一个或多个设备。相应地，在控制器中便有一个或多个设备接口，一个接口连接一台设备。在每个接口中都存在数据、控制和状态三种类型的信号。控制器中的 I/O 逻辑根据处理机发来的地址信号去选择一个设备接口。</p><ol start="3"><li>I/O 逻辑 </li></ol><p>在设备控制器中的 I/O 逻辑用于实现对设备的控制，它通过一组控制线与处理机交互，处理机利用该逻辑向控制器发送 I/O 命令，I/O 逻辑对收到的命令进行译码。每当 CPU 要启动一个设备时，一方面将启动命令发送给控制器；另一方面又同时通过地址线把地址发送给控制器，由控制器的 I/O 逻辑对收到的地址进行译码，再根据所译出的命令对所选设备进行控制。</p></li></ol><h2 id="5-2-I-O-软件"><a href="#5-2-I-O-软件" class="headerlink" title="5.2 I/O 软件"></a>5.2 I/O 软件</h2><p>I/O 软件的总体设计目标是高效率和通用性，为使 I/O 软件能具有清晰的结构，更好的可移植性和易适应性，目前在 I/O 软件中已普遍采用了层次式结构，低层软件用于实现与硬件相关的操作，并可屏蔽硬件的具体细节，高层软件则主要向用户提供一个简洁、友好和规范的接口。各层次及其功能如下：</p><ol><li><p>用户层软件 </p><p>用户层软件实现与用户交互的接口，用户层软件必须通过一组系统调用来取得操作系统服务。在现代的高级语言中，用户程序通过调用对应的库函数使用系统调用。</p></li><li><p>设备独立性软件 </p><p>设备独立性软件负责实现与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p><p>这里的设备独立性是指应用程序独立于具体使用的物理设备。为了实现设备独立性，引入了逻辑设备和物理设备两个概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，必须使用物理设备名称。因此，系统须具有将逻辑设备名称转换为物理设备名称的功能。这可通过设置一张逻辑设备表(LUT，Logical Unit Table)实现。</p></li><li><p>设备驱动程序 </p><p>设备驱动程序是 I/O 进程与设备控制器之间的通信程序，与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。</p></li><li><p>中断处理程序 </p><p>中断处理程序用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完后恢复被中断进程的现场，再返回到被中断进程。中断处理层的主要工作有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。</p></li></ol><h2 id="5-3-I-O-控制方式"><a href="#5-3-I-O-控制方式" class="headerlink" title="5.3 I/O 控制方式"></a>5.3 I/O 控制方式</h2><p>I/O 控制方式随着计算机技术的进步也在不断地发展。早期的计算机系统中采用程序 I/O 方式；当引入中断机制后，I/O 方式发展为中断驱动方式；此后，随着 DMA控制器的出现，I/O 方式从以字节为单位的传输扩大到以数据块为单位进行传输，从而大大地改善了块设备的 I/O 性能；而通道的引入，又使对 I/O 操作的组织和数据的传送都能独立地进行而无需 CPU 干预。</p><h3 id="5-3-1-程序-I-O-方式"><a href="#5-3-1-程序-I-O-方式" class="headerlink" title="5.3.1 程序 I/O 方式"></a>5.3.1 程序 I/O 方式</h3><p>早期的计算机系统中，处理机对 I/O 设备的控制采取程序 I/O 方式，或称为忙–等待方式，在该方式中，由于 CPU 的高速性和 I/O 设备的低速性，致使 CPU 的绝大部分时间都处于等待 I/O 设备完成数据 I/O 的循环测试中，造成对 CPU 的极大浪费。CPU 之所以要不断地测试 I/O 设备的状态，是因为在 CPU 中无中断机构，使 I/O 设备无法向 CPU 报告它已完成了一个字符的输入操作。</p><h3 id="5-3-2-中断驱动-I-O-控制方式"><a href="#5-3-2-中断驱动-I-O-控制方式" class="headerlink" title="5.3.2 中断驱动 I/O 控制方式"></a>5.3.2 中断驱动 I/O 控制方式</h3><p>现代计算机系统都广泛采用中断驱动方式，即当某进程要启动某个 I/O 设备工作时，便由 CPU 向相应的设备控制器发出一条 I/O 命令，然后立即返回继续执行原来的任务。设备控制器于是按照该命令的要求去控制指定 I/O 设备。此时，CPU 与 I/O设备并行操作。</p><p>在 I/O 设备输入每个数据的过程中，无需 CPU 干预，可使 CPU 与 I/O 设备并行工作。仅当输完一个数据时，才需 CPU 花费极短的时间去做些中断处理。可见，这样可使 CPU 和 I/O 设备都处于忙碌状态，从而提高了整个系统的资源利用率及吞吐量。</p><h3 id="5-3-3-直接存储器访问（DMA）I-O-控制方式"><a href="#5-3-3-直接存储器访问（DMA）I-O-控制方式" class="headerlink" title="5.3.3 直接存储器访问（DMA）I/O 控制方式"></a>5.3.3 直接存储器访问（DMA）I/O 控制方式</h3><p>中断驱动 I/O 方式以字或字节为单位进行 I/O，当完成后，控制器便向 CPU 请求一次中断。为了进一步减少 CPU 对 I/O 的干预，引入了直接存储器访问（DMA，Direct  Memory Access）方式：数据块在 I/O 设备和内存间直接进行传送，每次传送至少一个数据块，在控制器的控制下完成，仅在传送一个或多个数据块的开始和结束时，才需CPU 干预。</p><p>可见，DMA 方式进一步提高了 CPU 与 I/O 设备的并行操作程度。</p><h3 id="5-3-4-I-O-通道控制方式"><a href="#5-3-4-I-O-通道控制方式" class="headerlink" title="5.3.4 I/O 通道控制方式"></a>5.3.4 I/O 通道控制方式</h3><p>I/O 通道方式是DMA方式的发展，增设通道的主要目的是为了使一些原来由CPU处理的 I/O 任务转由通道来承担，从而把 CPU 从繁杂的 I/O 任务中解脱出来，有更多的时间去进行数据处理。它可进一步减少 CPU 的干预，即把对一个数据块的读/写为单位的干预减少为对一组数据块的读/写及有关的控制和管理为单位的干预。同时，又可实现 CPU、通道和 I/O 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p><p>I/O 通道是一种特殊的处理机，它具有执行 I/O 指令的能力，并通过执行通道程序来控制 I/O 操作。但它又与一般的处理机不同：一是其指令类型单一，其所能执行的命令主要局限于与 I/O 操作有关的指令；二是通道没有自己的内存，通道所执行的通道程序是放在主机的内存中的，即通道与 CPU 共享内存。</p><p>通道可分成以下三种类型：字节多路通道、数组选择通道、数组多路通道。</p><ol><li><p>字节多路通道</p><p>这是一种按字节交叉方式工作的通道。它通常都含有许多非分配型子通道，每一个子通道连接一台 I/O 设备，并控制该设备的 I/O 操作。这些子通道按时间片轮转方 式共享主通道。当所有子通道轮转一周后，又返回来由第一个子通道去使用字节多路主通道。这样，只要字节多路通道扫描每个子通道的速率足够快，而连接到子通道上的设备的速率不是太高时，便不致丢失信息，但不适于连接高速设备。</p></li><li><p>数组选择通道 </p><p>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序，控制一台设备进行数据传送。当某台设备占用了该通道后，便一直由它独占，即使是它无数据传送，通道被闲置，也不允许其它设备使用该通道，直至该设备传送完毕释放该通道。可见这种通道虽有很高的传输速率，但利用率很低，每次只允许一个设备传输数据。</p></li><li><p>数组多路通道 </p><p>数组多路通道是将数组选择通道传输速率高和字节多路通道能使各子通道分时并行操作的优点相结合而形成的一种新通道。它含有多个非分配型子通道，因而既具有 很高的数据传输速率，又能获得令人满意的通道利用率。该通道能被广泛地用于连接多台高、中速的外围设备，其数据传送是按数组方式进行的。</p></li></ol><h2 id="5-4-中断技术"><a href="#5-4-中断技术" class="headerlink" title="5.4 中断技术"></a>5.4 中断技术</h2><p>在计算机系统中，除了输入/输出中断之外，还存在许多其他的突发事件，例如电源掉电、程序出错等，这些也会发出中断信号通知 CPU 做相应的处理。引入中断技术的初衷是提高多道程序运行环境中 CPU 的利用率，而且主要是针对外部设备，后来逐 步发展成为操作系统各项操作的基础，如键盘或鼠标信息的输入、进程的管理和调度、 系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p><h3 id="5-4-1-中断的基本概念"><a href="#5-4-1-中断的基本概念" class="headerlink" title="5.4.1 中断的基本概念"></a>5.4.1 中断的基本概念</h3><p>中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处，继续执行或调度新的进程执行的过程。</p><p>引起中断发生的事件称为中断源。中断源向 CPU 发出的请求中断处理信号称为中断请求，而 CPU 收到中断请求后转到相应的事件处理程序称为中断响应。</p><p>还有一个常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统用软件方式有选择地封锁部分中断而允许其余部分的中断仍能得到响应。中断屏蔽是通过每一类中断源设置一个中断屏蔽触发器来屏蔽它们的中断请求而实现的。</p><p>不过，有些中断请求是不能屏蔽甚至不能禁止的，即这些中断具有最高优先级。不管 CPU 是否处于关中断，只要这些中断请求一旦提出，CPU 必须立即响应。如电源掉电事件所引起的中断就是不可禁止和屏蔽的中断。</p><h3 id="5-4-2-中断的分类与优先级"><a href="#5-4-2-中断的分类与优先级" class="headerlink" title="5.4.2 中断的分类与优先级"></a>5.4.2 中断的分类与优先级</h3><p>根据中断源产生的条件，可把中断分为外中断和内中断。</p><p>外中断是指来自处理机和内存外部的中断，包括 I/O 设备发出的 I/O 中断、外部信号中断、各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般称为中断。</p><p>内中断主要指在处理机和内存内部产生的中断。内中断一般称为陷阱（trap）。它包括程序运算引起的各种错误，如地址非法、校验错误、页面失效、存取访问控制错误、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。</p><p>为了按中断源的轻重缓急处理响应中断，操作系统对不同的中断赋予不同的优先级。为了禁止中断或屏蔽中断，CPU 的处理机状态字 PSW 中也设置有相应的优先级。如果中断源的优先级高于 PSW 的优先级，则 CPU 响应该中断源的中断请求，反之，CPU 屏蔽该中断源的中断请求。各中断源的优先级在系统设计时给定，在系统运行时是固定的。</p><p>中断和陷阱的主要区别如下：</p><ol><li>陷阱通常由处理机正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的；</li><li>陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。</li><li>CPU 在执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。例如执行指令非法时，尽管被执行的非法指令不能执行结束，但 CPU 仍可对其进行处理。</li></ol><h3 id="5-4-3-软中断"><a href="#5-4-3-软中断" class="headerlink" title="5.4.3 软中断"></a>5.4.3 软中断</h3><p>软中断的概念主要来源于 Unix 系统，软中断是对应于硬中断而言的。上述中断和陷阱都可以看作是硬中断，通过硬件产生相应的中断请求，称为硬中断。而软中断则是通信进程之间用来模拟硬中断而实现的一种信号通信方式。中断源发出软中断信号后，CPU 或接收进程在适当的时机自动进行中断处理，或者完成软中断信号所对应的 功能。这里“适当的时机”指的是接收进程必须得到处理机之后，才能接收软中断信号进程。如果该接收进程是占据处理机的，那么，该接收进程在接收到软中断信号后将立即转去执行该软中断信号所对应的功能。</p><h2 id="5-5-缓冲技术"><a href="#5-5-缓冲技术" class="headerlink" title="5.5 缓冲技术"></a>5.5 缓冲技术</h2><p>在设备管理中，引入缓冲区的主要原因可归结为以下几点：</p><ol><li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾；</li><li>减少中断 CPU 的次数，放宽对中断响应时间的限制；</li><li>提高 CPU 和 I/O 设备之间的并行性</li></ol><h3 id="5-5-1-单缓冲"><a href="#5-5-1-单缓冲" class="headerlink" title="5.5.1 单缓冲"></a>5.5.1 单缓冲</h3><p>单缓冲是操作系统提供的一种简单的缓冲技术。每当一个用户进程发出一个 I/O请求时，操作系统在内存的系统区中开设一个缓冲区。</p><p>对于块设备输入，单缓冲机制首先从磁盘把一块数据传送到缓冲区，接着操作系统把缓冲区数据送到用户区。由于这时缓冲区已空，操作系统可预读紧接的下一块数据。对于块设备输出，单缓冲机制的工作方式类似，先把数据从用户区拷贝到系统缓冲区，用户进程可以继续请求输出，直到缓冲区填满后，才启动 I/O 将数据写到磁盘上。</p><p>假定从磁盘把一块数据输入到缓冲区的时间为 T1，操作系统将该缓冲区中的数据传送到用户区的时间为 T2，而 CPU 对这一块数据处理的时间为 T3。由于 T1 和 T3是可以并行的，当 T1&gt;T3时，系统对每一块数据的处理时间为 T1+T2，反之则为 T3+T2，故可把系统对每一块数据的处理时间表示为 Max(T1，T3)+T2。</p><h3 id="5-5-2-双缓冲"><a href="#5-5-2-双缓冲" class="headerlink" title="5.5.2 双缓冲"></a>5.5.2 双缓冲</h3><p>为了加快 I/O 速度，实现 I/O 的并行工作和提高设备利用率，需要引入双缓冲机制。在输入数据时，先将数据送入第一缓冲区，填满后操作系统从第一缓冲区把数据送到用户进程区，用户进程便可对数据进行加工计算；与此同时填充第二缓冲区。当第一缓冲区空出后，输入设备再次向第一缓冲区输入数据。此时，操作系统又可以把 第二缓冲区的数据传送到用户进程区，用户进程开始加工第二缓冲区的数据。两个缓冲区交替使用，使 CPU 和 I/O 设备、I/O 设备和用户进程的并行性进一步提高，仅当两个缓冲区都为空，进程还要提取数据时，它才被迫等待。<strong>双缓冲机制可以同时实现 双向的数据传输，一个缓冲区用作发送缓冲区，另一个缓冲区作为接收缓冲区。</strong></p><h3 id="5-5-3-循环缓冲"><a href="#5-5-3-循环缓冲" class="headerlink" title="5.5.3 循环缓冲"></a>5.5.3 循环缓冲</h3><p>当输入与输出的速度相差很大时，双缓冲的效果不够理想，为此又引入了多缓冲机制，可将多个缓冲组织成循环缓冲的形式。在循环缓冲中包括多个缓冲区，其每个缓冲区的大小相同。</p><p>对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用。其中输入进程不断向空缓冲区输入数据，计算进程则从中提取数据进行计算。作为输入的多缓冲区可分为三类：用于装输入数据的空缓冲区 R、已装满数据的缓冲区 G 以及计算进程正在使用的现行工作缓冲区</p><p><img src="/images/image-20210810191523647.png" alt="image-20210810191523647"></p><p>作为输入的缓冲区可设置三个指针：用于指示计算进程下一个可用缓冲区 G 的指针 Nextg、指示输入进程下次可用的空缓冲区 R 的指针 Nexti，以及用于指示计算进程正在使用的缓冲区 C 的指针 Current。</p><p>当计算进程要使用缓冲区中的数据时，将指针 Nextg 所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区，并令 Current 指针指向该缓冲区的第一 个单元，同时将 Nextg 移向下一个 G 缓冲区。类似地，当输入进程要使用空缓冲区来装入数据时，将指针 Nexti 所指示的缓冲区提供给输入进程使用，同时将 Nexti 指针移向下一个 R 缓冲区。</p><p>当计算进程把 C 缓冲区中的数据提取完毕时，将缓冲区 C 释放。此时，把该缓冲区由现行工作缓冲区 C 改为空缓冲区 R。类似地，当输入进程把缓冲区装满时，将该缓冲区释放，并改为 G 缓冲区。</p><h3 id="5-5-4-缓冲池"><a href="#5-5-4-缓冲池" class="headerlink" title="5.5.4 缓冲池"></a>5.5.4 缓冲池</h3><p>为了提高缓冲区的利用率，目前广泛使用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区，且既能用于输入，也能用于输出。</p><p>缓冲池至少应含有以下三种类型的缓冲区：</p><ol><li>空缓冲区；</li><li>装满输入数据的缓冲区；</li><li>装满输出数据的缓冲区。</li></ol><p>为了管理上的方便，可将相同类型的缓冲区链成一个队列，于是可形成以下三个队列：</p><ol><li>空缓冲队列。这是由空缓冲区所链成的队列。</li><li>输入队列。这是由装满输入数据的缓冲区所链成的队列。</li><li>输出队列。这是由装满输出数据的缓冲区所链成的队列。</li></ol><p>缓冲区可以工作在收容输入、提取输入、收容输出和提取输出四种工作方式下，按使用情况设置有四种工作缓冲区：收容输入工作缓冲区、提取输入工作缓冲区、收容输出工作缓冲区和提取输出工作缓冲区。</p><p><img src="/images/image-20210810191838574.png" alt="image-20210810191838574"></p><h2 id="5-6-设备分配"><a href="#5-6-设备分配" class="headerlink" title="5.6 设备分配"></a>5.6 设备分配</h2><p>在多道程序环境下，系统中的设备供所有进程共享。为防止各进程对系统资源的无序竞争，系统设备必须由系统统一分配。为了实现设备分配，必须在系统中设置相应的数据结构。</p><h3 id="5-6-1-设备分配中的数据结构"><a href="#5-6-1-设备分配中的数据结构" class="headerlink" title="5.6.1 设备分配中的数据结构"></a>5.6.1 设备分配中的数据结构</h3><p>在进行设备分配时，通常都需要借助于一些表格的帮助。在表格中记录了相应设备或控制器的状态及对设备或控制器进行控制所需的信息。在进行设备分配时所需的数据结构（表格）有：</p><ol><li><p>设备控制表（DCT） </p><p>系统为每一个设备都配置了一张用于记录本设备情况的设备控制表。</p></li><li><p>控制器控制表（COCT） </p><p>系统为每一个控制器都设置了一张用于记录本控制器情况的控制器控制表。</p></li><li><p>通道控制表（CHCT） </p><p>每个通道都配有一张通道控制表。</p></li><li><p>系统设备表（SDT） </p><p>这是系统范围的数据结构，其中记录了系统中全部设备的情况。每个设备占一个表目，包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项。</p></li></ol><h3 id="5-6-2-设备分配算法"><a href="#5-6-2-设备分配算法" class="headerlink" title="5.6.2 设备分配算法"></a>5.6.2 设备分配算法</h3><p>与进程调度的算法相比，对设备进行分配的算法相对简单，通常只采用以下两种分配算法：</p><ol><li><p>先来先服务 </p><p>当有多个进程对同一设备提出 I/O 请求时，该算法根据各进程对某设备提出请求的先后次序，将这些进程排成一个设备请求队列，设备分配程序总是把设备首先分配给队首进程。</p></li><li><p>优先级高者优先 </p><p>在进程调度中，这种算法使得优先权高的进程优先获得处理机。如果对这种高优先权进程所提出的 I/O 请求也赋予高优先权，显然有助于这种进程尽快完成。在利用 该算法形成设备队列时，将优先权高的排在设备队列前面，而对于优先级相同的 I/O 请求，则按先来先服务原则排队。</p></li></ol><h3 id="5-6-3-SPOOLing-技术"><a href="#5-6-3-SPOOLing-技术" class="headerlink" title="5.6.3 SPOOLing 技术"></a>5.6.3 SPOOLing 技术</h3><p>通过 SPOOLing 技术可将一台物理 I/O 设备虚拟为多台逻辑 I/O 设备，同样允许多个用户共享一台物理 I/O 设备。SPOOLing 技术是对脱机输入/输出系统的模拟。</p><p>下图显示了脱机输入/输出过程。由于程序和数据的输入和输出都是在外围机的控制下完成的，即它们是在脱离主机的情况下进行的，故称为脱机输入/输出方式。</p><p><img src="/images/image-20210810192529491.png" alt="image-20210810192529491"></p><p>当系统中引入了多道程序技术后，可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速 I/O 设备上的数据传送到高速磁盘上；再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样便可 在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与 CPU 对数据的处 理同时进行，这种在联机情况下实现的同时外围操作被称为 SPOOLing（Simultaneaus Periphernal Operating On Line），或称为假脱机操作。</p><p>SPOOLing 系统主要有以下三部分：</p><ol><li><p>输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存 I/O 设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</p></li><li><p>输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送给输出设备。</p></li><li><p>输入进程和输出进程。输入进程模拟脱机输入时的外围控制机，输出进程模拟脱机输出时的外围控制机。</p><p><img src="/images/image-20210810192918093.png" alt="image-20210810192918093"></p><p>SPOOLing 系统具有如下主要特点：</p><ol><li>提高了 I/O 的速度</li><li>将独占设备改造为共享设备。在 SPOOLing 系统中，实际上并没为任何进程分配设备，而只是在输入井或输出井中为进程分配一个存储区和建立一张 I/O 请求表。这样，便把独占设备改造为共享设备。</li><li>实现了虚拟设备功能。</li></ol></li></ol><h2 id="5-7-磁盘管理"><a href="#5-7-磁盘管理" class="headerlink" title="5.7 磁盘管理"></a>5.7 磁盘管理</h2><h3 id="5-7-1-磁盘简述"><a href="#5-7-1-磁盘简述" class="headerlink" title="5.7.1 磁盘简述"></a>5.7.1 磁盘简述</h3><ol><li><p>数据的组织和格式 </p><p>磁盘设备可包括一或多个物理盘片，每个磁盘片分一个或两个存储面，每个磁盘面被组织成若干个同心环，称为磁道，各磁道之间留有必要的间隙，磁道从外向内进行编号。每条磁道又被逻辑上划分成若干个扇区，<strong>一个扇区称为一个盘块（或数据块）</strong>，常常叫做磁盘扇区。各扇区之间保留一定的间隙，一个物理记录存储在一个扇区上。<strong>在微机中，主机对磁盘数据的读写是以扇区为单位的</strong>。磁盘上存储的物理记录块数目由<strong>扇区数</strong>、<strong>磁道数</strong>以及<strong>磁盘面数</strong>所决定。</p></li><li><p>磁盘的类型 </p><p>对磁盘，可以从不同的角度进行分类。最常见的有：将磁盘分成硬盘和软盘、单片盘和多片盘、固定头磁盘和移动头磁盘等。固定头磁盘主要用于大容量磁盘上，而微型机上配置的温盘和软盘都采用移动磁头结构。</p></li><li><p>磁盘访问时间 </p><p>磁盘的访问时间分成以下三部分：首先，把磁头移动到指定磁道上所经历的时间称为<strong>寻道时间</strong>；磁头到达指定磁道后，必须等待指定扇区移动到磁头下面的时间称为<strong>旋转延迟时间</strong>；最后，把数据从磁盘读出或向磁盘写入数据所经历的时间称为<strong>传输时间</strong>。一次磁盘服务的总时间为这三者之和。</p></li></ol><h3 id="5-7-2-磁盘调度"><a href="#5-7-2-磁盘调度" class="headerlink" title="5.7.2 磁盘调度"></a>5.7.2 磁盘调度</h3><p>目前常用的磁盘调度算法有先来先服务、最短寻道时间优先及扫描等算法。</p><ol><li><p>先来先服务（FCFS，First Come First Served） </p><p>先来先服务是一种最简单、也最容易实现的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，不会出现某一进程的请求长期得不到满足的情况。但此算法平均寻道时间可能较长。</p><p>例如，现在有一个请求磁盘服务的队列，要访问的磁道顺序为：98、183、37、122、14、124、65、67，假设磁头最初在 53 道上。</p><p>那么，磁头从 53 道移动到 98 道，然后依次移到 183、37、122、14、124、65， 最后到达 67 道，总共移动了 640 个磁道的距离。</p></li><li><p>最短寻道时间优先（SSTF，Shortest Seek Time First）</p><p>该算法要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短。这种算法不能保证平均寻道时间最短，并且可能导致某个进程发生“饥饿”现象。</p><p>例如，用 SSTF 算法处理上面的请求队列。磁头当前在 53 道上，最接近的磁道是 </p><p>65。然后下一个移到最接近的 67 道。此时，到 37 道的距离是 30，而到 98 道的距离是 31，故 37 道离 67 道最近，被选为下一个服务对象。接下去的顺序是 l4、98、122、124，最后是 183 道。采用这种方法，磁头共移动了 236 个磁道，是 FCFS 算法的 1/3多一点。很明显，它改善了磁盘服务。</p></li><li><p>扫描（SCAN）算法</p><p>该算法不仅考虑到将要访问的磁道与当前磁道间的距离，更优先考虑的是磁头当前的移动方向。磁头从磁盘的一端出发，向另一端移动，遇到所需的磁道时就进行服 务，一旦在当前方向上没有请求了，磁头的移动方向就反过来，继续下面的服务。这种算法避免了出现“饥饿”现象。由于其磁头移动的规律类似电梯的运行，因而常为电梯调度算法。</p><p>继续采用前面的例子，用 SCAN 算法处理上面的请求队列，但要知道磁头的移动方向。如果磁头正向 0 道方向移动，那么，它先为 37 道服务，接着是 14 道；到达 14道后，由于在该方向上没有请求了，故磁头移动方向反过来，移向盘的另一端，服务顺序分别是 65，67，98，122，124 和 183 道。</p></li><li><p>循环扫描（CSCAN）算法 </p><p>CSCAN 算法规定磁头单向移动，如只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问的磁道，即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。</p><p>用 CSCAN 算法处理上面的请求队列，假设磁头向 0 道方向移动，则顺序为 37、14、183、124、122、98、67、65。</p></li></ol><h3 id="5-7-3-磁盘高速缓存"><a href="#5-7-3-磁盘高速缓存" class="headerlink" title="5.7.3 磁盘高速缓存"></a>5.7.3 磁盘高速缓存</h3><p>磁盘高速缓存是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。它是一组在逻辑上属于磁盘，而物理上是驻留在内存中的盘块。</p><p>当有一进程请求访问某个盘块中的数据时，先去查看磁盘高速缓冲器，若有，直接从中提取数据交付给请求者进程；否则，应先从磁盘中将所要访问的数据读入并交付给请求者进程，同时也将数据送高速缓存。当以后又需要访问该盘块的数据时，便可直接从高速缓存中提取。</p><p>将磁盘中的盘块数据读入高速缓存时，会出现因高速缓存中已装满数据而需要将该数据先换出的问题。较常用的置换算法仍然是最近最久未使用算法 LRU、最近未使用算法 NRU 及最少使用算法 LFU 等。</p><h3 id="5-7-4-提高磁盘-I-O-速度的其它方法"><a href="#5-7-4-提高磁盘-I-O-速度的其它方法" class="headerlink" title="5.7.4 提高磁盘 I/O 速度的其它方法"></a>5.7.4 提高磁盘 I/O 速度的其它方法</h3><p>除了磁盘高速缓存后，还有几种能有效地提高磁盘 I/O 速度的方法：</p><ol><li><p>提前读 </p><p>进程对文件进行访问时，经常采用顺序访问方式，在读当前块时可以预知下一次要读的盘块。故可以采取预先读方式，即在读当前块的同时，还要求将下一个盘块中的数据也读入缓冲区。</p></li><li><p>延迟写 </p><p>延迟写是指在缓冲区中的数据，本应立即写回磁盘，但考虑到该缓冲区中的数据在不久之后可能还会再被访问，因而并不立即将其数据写入磁盘，而是将它挂在空闲缓冲区队列的末尾。随着空闲缓冲区的使用，缓冲区逐渐移到空闲缓冲队列之首。当再有进程申请到该缓冲区时，才将该缓冲区中的数据写入磁盘，而把该缓冲区作为空闲缓冲区分配出去。</p></li><li><p>优化物理块的分布 </p><p>优化文件物理块的分布是为了使磁头的移动距离最小。该优化应在为文件分配盘块时进行。可将在同一条磁道上的若干个盘块组成<strong>一簇</strong>，在分配存储空间时，以簇为单位进行分配。这样就可以保证在访问这几个盘块时，不必移动磁头或者仅移动一条磁道的距离，从而减少了磁头的平均移动距离。</p></li><li><p>虚拟盘 </p><p>所谓虚拟盘，是指利用内存空间去仿真磁盘，该盘的设备驱动程序也可以接受所有标准的磁盘操作，但这些操作的执行，不是在磁盘上而是在内存中。这些对用户都是透明的。虚拟盘是易失性存储器，一旦系统或电源发生故障，或系统再启动时，原来保存在虚拟盘中的数据将会丢失。因此，虚拟盘通常用于存放临时文件。</p><p>虚拟盘与磁盘高速缓存的主要区别在于：虚拟盘中的内容完全由用户控制，而高速磁盘缓存中的内容则是由 OS 控制。</p></li></ol><h3 id="5-7-5-磁盘阵列"><a href="#5-7-5-磁盘阵列" class="headerlink" title="5.7.5 磁盘阵列"></a>5.7.5 磁盘阵列</h3><p>磁盘阵列（RAID，Redundant Array of Independent Disks）是利用一台磁盘阵列控制器，来统一管理和控制一组磁盘驱动器，组成一个高度可靠的、快速的大容量磁盘系统。</p><ol><li><p>并行交叉存取 </p><p>在磁盘存储系统中，有多台磁盘驱动器，系统将每一盘块中的数据分为若干个子盘块数据，再把每一个子盘块的数据分别存储到各个不同磁盘中的相同位置上。当要将一个盘块的数据传送到内存时，采取并行传输方式，将各个盘块中的子盘块数据同时向内存中传输，从而使传输时间大大减少。下图出了磁盘并行交叉存取方式。</p><p><img src="/images/image-20210810202206339.png" alt="image-20210810202206339"></p></li><li><p>RAID 的分级 </p><p>RAID 原来只有 RAID0 至 RAID5，后来又增加了 RAID6 和 RAID7。</p><ol><li><p>RAID0 </p><p>仅提供了并行交叉存取。RAID 0 没有冗余或错误修复能力，成本低，一般只是在那些对数据安全性要求不高的情况下才被使用。</p></li><li><p>RAID1 </p><p>具有磁盘镜像功能，其比传统的镜盘速度快，但其磁盘容量的利用率只有 50%，它是以牺牲磁盘容量为代价的。</p></li><li><p>RAID3 </p><p>具有并行传输功能的磁盘阵列。它利用一台奇偶校验盘来完成数据的校验功能，比起磁盘镜像，它减少了所需要的冗余磁盘数。如当阵列中只有 7 个盘时，可利用 6 个盘作数据盘，一个盘作校验盘。磁盘的利用率为 6/7。</p></li><li><p>RAID5 </p><p>把校验块分散到所有的数据盘块中，具有独立传送的功能，各磁盘驱动器可独立读/写，常用于 I/O 较频繁的事务处理中。</p></li><li><p>RAID6 </p><p>设置了一个专用的、可快速访问的异步校验盘。该盘具有独立的数据访问通路，具有更好的性能，但改进很有限，且价格昂贵。</p></li><li><p>RAID7 </p><p>即优化的高速数据传送磁盘结构，它所有的 I/O 传送均是同步进行的，可以分别控制，这提高了系统的并行性和系统访问数据的速度，每个磁盘都带有高速缓冲存储器，实时操作系统可以使用任何实时操作芯片，达到不同实时系统的需要。RAID7 是目前最高档次的磁盘阵列。</p></li></ol></li></ol><h3 id="5-7-6-磁盘容错技术"><a href="#5-7-6-磁盘容错技术" class="headerlink" title="5.7.6 磁盘容错技术"></a>5.7.6 磁盘容错技术</h3><p>磁盘容错技术是通过增加冗余的磁盘驱动器、磁盘控制器等方法，来提高磁盘系统可靠性的一种技术，即当磁盘系统的某部分出现缺陷或故障时，磁盘仍能正常工作，且不致造成数据的丢失或错误。目前广泛采用磁盘容错技术来改善磁盘系统的可靠性。磁盘容错技术往往也被人们称为系统容错技术 SFT，它分成三个级别：第一级是低级磁盘容错技术；第二级是中级磁盘容错技术；第三级是系统容错技术，它基于集群技术实现容错。</p><ol><li><p>第一级容错技术 SFT-I </p><p>第一级容错技术是最基本的一种磁盘容错技术，主要用于防止因磁盘表面缺陷所造成的数据丢失。它包含双份目录、双份文件分配表及写后读校验等措施。</p><p>1）双份目录和双份文件分配表 </p><p>在磁盘上存放的文件目录和文件分配表 FAT，是文件管理所用的重要数据结构。 为了防止这些表格被破坏，可在不同的磁盘上或在磁盘的不同区域中，分别建立双份目录表和 FAT。</p><p>2）写后读校验 </p><p>为了保证所有写入磁盘的数据都能写入到完好的盘块中，应该在每次从内存缓冲区向磁盘中写入一个数据块后，又立即从磁盘上读出该数据块，并送至另一缓冲区中，再将该缓冲区内容与内存缓冲区中在写后仍保留的数据进行比较。若两者一致，便认为此次写入成功，可继续写下一个盘块；否则，再重写。</p></li><li><p>第二级容错技术 SFT-II </p><p>第二级容错技术主要用于防止由磁盘驱动器和磁盘控制器故障所导致的系统不能正常工作，它具体又可分为磁盘镜像和磁盘双工。</p><ul><li>磁盘镜像功能，是在同一磁盘控制器下再增设一个完全相同的磁盘驱动器，在每次向主磁盘写入数据后，都需要将数据再写到备份磁盘上，使两个磁盘上具有完全相同的位像图。</li><li>磁盘双工功能，即将两台磁盘驱动器分别接到两个磁盘控制器上，同样使这两台磁盘机镜像成对。在磁盘双工时，文件服务器同时将数据写到两个处于不同控制器下的磁盘上，使两者有完全相同的位像图。如果某个通道或控制器发生故障时，另一通道上的磁盘仍能正常工作，不会造成数据的丢失。</li></ul></li><li><p>基于集群技术的容错功能 SFT-III </p><p>所谓集群，是指由一组互连的自主计算机组成统一的计算机系统。利用集群系统不仅可提高系统的并行处理能力，还可用于提高系统的可用性，它们是当前使用最广泛的一类具有容错功能的集群系统。其主要工作模式有三种：热备份模式；互为备份模式；公用磁盘模式。</p><p>1）双机热备份模式</p><p>系统中备有两台服务器，两者的处理能力通常是完全相同的，一台作为主服务器， 另一台作为备份服务器。平时主服务器运行，备份服务器则时刻监视着主服务器的运行，一旦主服务器出现故障，备份服务器便立即接替主服务器的工作而成为系统中的主服务器，修复后的服务器再作为备份服务器。</p><p>2）双机互为备份的模式 </p><p>这种模式中，两台服务器均为在线服务器，它们各自完成自己的任务；同时它们还接收另一台服务器发来的备份数据，作为对方的备份服务器。如果其中一台服务器 发生了故障，则由另一台服务器为客户机提供服务；当故障服务器修复并重新连到网上后，已被迁移到无故障服务器上的服务功能将被返回，恢复正常工作。</p><p>3）公用磁盘模式 </p><p>为了减少信息复制的开销，可以将多台计算机连接到一台公共的磁盘系统上去。该公共磁盘被划分为若干个卷，每台计算机使用一个卷。如果某台计算机发生故障， 此时系统将重新进行配置，根据某种调度策略来选择另一台替代机器，后者对发生故障的机器的卷拥有所有权，从而来接替故障计算机所承担的任务。公用磁盘模式的优点是：消除了信息的复制时间，因而减少了网络和服务器的开销。</p></li></ol><h1 id="6-文件管理"><a href="#6-文件管理" class="headerlink" title="6. 文件管理"></a>6. 文件管理</h1><h2 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h2><p>计算机系统中有大量的程序，所有程序在运行过程中都需要保存和读取信息。为了实现大量信息的长期方便共享，通常系统中的绝大部分信息都存放在外存，对这些信息的存放和管理必须利用文件和文件系统。</p><p>文件是指具有文件名的若干相关元素的集合。元素通常是记录，而记录又是一组有意义的数据项的集合。</p><p>文件系统是操作系统中负责操纵和管理文件的一整套机制，它实现文件的共享和保护，方便用户“按名存取”。有了文件系统，用户可以用文件名对文件实施存取和相应管理，而不必去考虑其信息的存放、如何去启动设备进行 I/O 等实现的细节。文件系统提供了用户与外存的界面，一般由文件管理有关的软件、被管理的文件及实施文件管理所需的数据结构组成。</p><h3 id="6-1-1-文件、记录和数据项"><a href="#6-1-1-文件、记录和数据项" class="headerlink" title="6.1.1 文件、记录和数据项"></a>6.1.1 文件、记录和数据项</h3><p>文件系统中把数据分为<strong>数据项</strong>、<strong>记录</strong>和<strong>文件</strong>三级。</p><ol><li><p>数据项 </p><p>数据项是数据记录中最基本的、不可分的数据单位。数据项可以是字母、数字或两者的组合。通过数据类型（逻辑、数值、字符等）及数据长度来描述。在文件系统中，数据项是最低级的数据组织形式，用来描述实体的某种属性，例如，学号/201709001、姓名/张三、性别/男等。</p></li><li><p>记录 </p><p>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。为了能唯一地标识一个记录，必须在一个记录的各个数据项中，确定出一个或几个数据项，把它们的集合称为关键字。关键字是唯一能标识一个记录的数据项。</p></li><li><p>文件 </p><p>文件是具有文件名的、在逻辑上具有完整意义的一组相关信息项的有序序列。文件信息由文件创建者和使用者定义，文件信息的类型可以是源程序、目标程序、可执行文件、图像和声音等。系统通过文件名可以访问文件，名字的长度因系统不同而异。 文件可分为有结构文件和无结构文件两种。在有结构的文件中，文件由若干个相关记录组成；而无结构文件则被看成是一个字符流。</p><p>文件都有文件名和数据，操作系统为了方便管理还会保存与文件相关的信息，这些附加信息就是文件属性。文件的属性可以包括：文件类型、文件长度、文件的物理位置、文件的建立时间、最后一次修改时间等。</p></li></ol><h3 id="6-1-2-文件类型"><a href="#6-1-2-文件类型" class="headerlink" title="6.1.2 文件类型"></a>6.1.2 文件类型</h3><p>为了便于管理和控制文件，通常将文件分成若干种类型。在许多操作系统中都把文件类型作为扩展名而放在文件名的后面，在文件名和扩展名之间用“．”号隔开。下面是常用的几种文件分类方法。</p><ol><li><p>按用途分类 </p><p>根据文件的性质和用途的不同，可将文件分为三类：</p><p>1）系统文件 </p><p>通常是操作系统核心、各种系统应用程序及数据组成。只允许用户通过系统调用来执行该类文件，不允许对这类文件进行读写和修改操作。</p><p>2）用户文件 </p><p>指由用户的源代码、目标文件、可执行文件或数据等所构成的文件。</p><p>3）库文件 </p><p>是由标准子例程及常用的例程等所构成的文件。这类文件允许用户调用，但不允许修改。</p></li><li><p>按文件中数据的形式分类</p><p>按文件中数据的形式分类，也可把文件分为三类：</p><p>1）源文件 </p><p>通常是指由高级语言或汇编语言所编写的程序，由源程序和数据构成的文件。</p><p>2）目标文件 </p><p>是指把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件，通常后缀名是“.obj”。</p><p>3）可执行文件 </p><p>是指把编译后所产生的目标代码再经过链接程序链接后所形成的文件。</p></li><li><p>按存取控制属性分类 </p><p>根据系统管理员或用户所规定的存取控制属性，可将文件分为三类：</p><p>1）只执行文件 </p><p>只允许被核准的用户调用执行，既不允许读，更不允许写。</p><p>2）只读文件 </p><p>只允许文件主及被核准的用户去读，但不允许写。</p><p>3）读写文件 </p><p>是指允许文件主和被核准的用户去读或写的文件。</p></li><li><p>按组织形式和处理方式分类 </p><p>根据文件的组织形式和系统对其的处理方式，可将文件分为三类：</p><p>1）普通文件 </p><p>由 ASCII 码或二进制码组成的字符文件。一般用户建立的源程序文件、数据文件、目标代码文件及操作系统自身代码文件、库文件、实用程序文件等都是普通文件，通常存储在外存上。</p><p>2）目录文件 </p><p>由文件目录组成的，用来管理和实现文件系统功能的系统文件，通过目录文件可以对其它文件的信息进行检索。</p><p>3）特殊文件 </p><p>特指系统中的各类 I/O 设备。为了便于统一管理，系统将所有的输入/输出设备都视为文件，按文件方式提供给用户使用。根据设备数据交换单位的不同，又可将特殊文件分为块设备文件和字符设备文件。前者用于磁盘、光盘或磁带等块设备的 I/O 操作，而后者用于终端、打印机等字符设备的 I/O 操作。</p></li></ol><h3 id="6-1-3-文件操作"><a href="#6-1-3-文件操作" class="headerlink" title="6.1.3 文件操作"></a>6.1.3 文件操作</h3><p>用户通过文件系统所提供的系统调用实施对文件的操作。最基本的文件操作有：创建文件、删除文件、读文件、写文件、截断文件和设置文件的读/写位置。但对于一 个实际的 OS，提供了更多的对文件的操作，如打开和关闭一个文件、改变文件名等操作。</p><p>有许多文件操作都可以利用上述基本操作加以组合来实现。如创建一个文件拷贝的操作，可利用两条基本操作来实现：第一步利用创建文件的系统调用来创建一个新文件；第二步将原有文件中的内容写入新文件中。</p><h3 id="6-1-4-文件结构"><a href="#6-1-4-文件结构" class="headerlink" title="6.1.4 文件结构"></a>6.1.4 文件结构</h3><p>对于任何一个文件，都存在着两种形式的结构：逻辑结构和物理结构。</p><ol><li><p>文件的逻辑结构 </p><p>文件的逻辑结构是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，它独立于文件的物理特性。</p></li><li><p>文件的物理结构 </p><p>文件的物理结构又称为文件的存储结构，是指文件在外存上的存储组织形式。它不仅与存储介质的存储性能有关，而且与所采用的外存分配方式有关。</p></li></ol><h2 id="6-2-文件的逻辑结构"><a href="#6-2-文件的逻辑结构" class="headerlink" title="6.2 文件的逻辑结构"></a>6.2 文件的逻辑结构</h2><p>文件的逻辑结构可分为两大类，一类是有结构文件，指由一个以上的记录构成的文件，又称为记录式文件；其二是无结构文件，指由字符流构成的文件，又称为流式文件。</p><ol><li><p>有结构文件 </p><p>在有结构文件中，依据记录的长度可分为定长和不定长两类：</p><p>1）定长记录 </p><p>是指文件中所有记录具有相同的长度，同时所有数据项都处在记录中相同的位置，具有相同的顺序和长度。定长记录由于处理方便、控制容易，在传统的数据处理中普遍采用。</p><p>2）变长记录 </p><p>是指文件中各记录的长度不相同。但在处理前，每个记录的长度是可知的。</p><p>根据用户和系统管理上的需要，可采用多种方式来组织这些记录，形成以下几种文件：</p><ol><li><p>顺序文件 </p><p>顺序文件把一组记录作为一个列表来存储和管理，记录中包含一定信息的基本单位，这些信息可有若干个字段，字段个数相同，每个字段的长度也相同。</p></li><li><p>索引文件 </p><p>为文件中所有记录建立一张索引表，索引表记录文件中的每个记录所在的位置。查找时检索索引表找到相应的表项，就能访问所需文件中的变长记录。通常将存放记录的文件称为主文件，而存放索引信息的文件称为索引文件。</p></li><li><p>索引顺序文件 </p><p>它将顺序文件中的所有记录分为若干个组，并建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的键值和指向该记录的指针。</p></li></ol></li><li><p>无结构文件 </p><p>无结构文件是指对文件内的信息不再划分单位，而是依次的一串字符流构成的文件，也被称为流式文件。在流式文件中，查找文件的基本信息单位比较困难，但管理简单，用户可以方便地对其进行操作。因此，那些对基本信息单位操作不多的文件较适于采用无结构方式存储，如源程序文件、目标代码文件等。在 Unix 系统中，所有的文件都被看作是流式文件。</p></li></ol><h2 id="6-3-文件的物理结构"><a href="#6-3-文件的物理结构" class="headerlink" title="6.3 文件的物理结构"></a>6.3 文件的物理结构</h2><h3 id="6-3-1-外存分配方式"><a href="#6-3-1-外存分配方式" class="headerlink" title="6.3.1 外存分配方式"></a>6.3.1 外存分配方式</h3><p>外存分配方式决定了文件的物理结构。采用不同的分配方式时，将形成不同的文件物理结构，如采用连续分配方式时的文件物理结构，将是顺序式的文件结构；链接分配方式将形成链接式文件结构；而索引分配方式则将形成索引式的文件结构。</p><p>目前常用的外存分配方法有<strong>连续分配</strong>、<strong>链接分配</strong>和<strong>索引分配</strong>三种。</p><ol><li><p>连续分配 </p><p>连续分配要求为每一个文件分配一组相邻接的盘块。这种分配方式保证逻辑文件中的记录顺序与存储器中文件占用盘块的一致性。连续分配的优点是：顺序访问容易，速度快。其缺点是要求有连续的存储空间，且必须事先知道文件的长度。</p></li><li><p>链接分配 </p><p>采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，把这样形成的物理文件称为链接文件。链接分配无需事先知道文件的大小，对文件的增、删、改也十分方便，并且由于采取离散分配方式，消除了外部碎片，故显著地提高了外存空间的利用率。</p><p>链接方式可分为隐式链接和显式链接两种形式。</p><p>1）隐式链接 </p><p>在采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针，而在每个盘块中都含有一个指向下一个盘块的指针。</p><p>隐式链接分配方式只适合于顺序访问，随机访问的效率低下。此外，只通过链接指针链接盘块，可靠性较差，只要其中任何一个指针出现问题，都会导致整个链断开。</p><p>2）显式链接 </p><p>显式链接是指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。该表在整个磁盘仅设置一张，表的序号是物理盘块号，在每个表项中存放链接指针，即下一个盘块号。由于分配给文件的所有盘块号都放在该表中，故把该表称为文件分配表 FAT（File Allocation Table）。</p><p>为了适应磁盘容量不断增大的需要，在进行盘块分配时，不再以盘块而是以簇(cluster)为基本单位。簇是一组连续的扇区，在 FAT 中它作为一个虚拟扇区，一个簇应包含扇区的数量与磁盘容量的大小直接有关。</p></li><li><p>索引分配</p><p>1）单级索引分配 </p><p>链接分配方式不能支持高效的直接存取，且 FAT 需占用较大的内存空间。索引分配方法为每个文件分配一个索引块，再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多盘块号的数组。在建立一个文件时，只需在为之建立的目录项中填上指向该索引块的指针。</p><p>索引分配方式支持直接访问。通常采用一个专门的盘块作为索引块，其中可存放成百个、甚至上千个盘块号。可见，对于小文件采用索引分配方式时，其索引块的利用率极低。</p><p>2）多级索引分配 </p><p>当 OS 为一个大文件分配磁盘空间时，如果所分配出去的盘块的盘块号已经装满一个索引块时，OS 便为该文件分配另一个索引块，用于将以后继续为之分配的盘块号记录于其中，依此类推。此时，应为这些索引块再建立一级索引，称为第一级索引， 即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中，这样便形成了两级索引分配方式。如果文件非常大时，还可用三级、四级索引分配方式。</p><p>两级索引分配方式下，若每个盘块的大小为 1 KB，每个盘块号占 4 个字节，则在一个索引块中可存放 256 个盘块号。则两级索引时，最多可包含存放文件的盘块的盘块号总数<em>N</em> = 256×256 = 64 K个。故采用两级索引时，所允许的文件最大长度为64 MB。</p><p>3）混合索引分配方式 </p><p>所谓混合索引分配方式，是指将多种索引分配方式相结合而形成的一种分配方式。如系统既采用了直接地址，又采用了一级索引分配方式，或两级索引分配方式，甚至还采用了三级索引分配方式。这种混合索引分配方式已在 Unix 系统中采用。</p></li></ol><h3 id="6-3-2-文件的物理结构"><a href="#6-3-2-文件的物理结构" class="headerlink" title="6.3.2 文件的物理结构"></a>6.3.2 文件的物理结构</h3><p>文件物理结构是指文件在存储介质上的组织方式，它依赖于物理的存储设备、物理存储空间，可以看做是相关物理块的集合，又称物理文件。</p><ol><li><p>顺序结构 </p><p>顺序结构是把一个逻辑上顺序的记录构成的文件分配到顺序的物理块中。</p><ul><li>优点：管理简单，存储速度快。</li><li>缺点：空间利用率低，文件记录插入或删除操作不方便，只能在文件末尾进行。</li></ul></li><li><p>链接结构 </p><p>链接结构是把文件信息存放在非连续的物理块中，每个物理块均设有一个指针指向其后续的另一个物理块，从而使得存放同一文件的物理块链接成一个串联队列。链接方式又分显式链接和隐式链接。显式链接的指针在专门的链接表中，隐式链接的指针在存放文件信息的物理块中。</p><ul><li>优点：链接结构空间利用率高，且易于文件扩充</li><li>缺点：对文件的搜索率较低</li></ul></li><li><p>索引结构 </p><p>索引结构是为每个文件建立一个索引表，其中每一个表项指出文件记录所在的物理块号，表项按逻辑记录编号，按顺序或按记录内某一关键字顺序排列。对于大文件，为检索方便，可以建立多级索引，还可以把文件索引表也作为一个文件，称为索引表文件。</p><ul><li>优点：满足文件动态增长的要求且存取方便</li><li>缺点：建立索引表增加了文件存储空间的开销，对于多级索引，访问时间开销较大</li></ul></li></ol><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4 文件存储空间管理"></a>6.4 文件存储空间管理</h2><p>文件管理要解决的重要问题之一是如何为新创建的文件分配存储空间。存储空间的基本分配单位都是磁盘块而非字节。下面介绍几种常用的文件存储空间的管理方法。</p><ol><li><p>空闲表法 </p><p>空闲表法属于连续分配方式，它与内存的动态分配方式相似，它为每个文件分配一块连续的存储空间，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息，再将所有空闲区按其起始盘块号递增的次序排列。</p></li><li><p>空闲链表法 </p><p>空闲链表法是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，可把链表分成两种形式：空闲盘块链和空闲盘区链。空闲盘块链将磁盘上的所有空闲空间，以盘块为单位拉成一条链。而空闲盘区链将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。</p></li><li><p>位示图</p><p>位示图的基本思想是：用若干个字节组成一张图，每个字节中的每一位对应存储空间中的一个物理块。当其值为“0”时，表示对应的盘块空闲；为“1”时，则表示已分配。有的系统标志方式则正好相反。这样，由所有盘块所对应的位构成一个集合，称为位示图。位示图的大小由盘块总数确定，通常可用 m×n 个位数来构成位示图，m×n 大于等于磁盘的总块数</p><p><img src="/images/image-20210810213007341.png" alt="image-20210810213007341"></p><p>若某盘块对应的位处于位示图的第 i 行第 j 列，则其相应的盘块号 b 为：b = n (i -1) + j</p><p>其中，n 代表每行的位数。</p></li><li><p>成组链接法 </p><p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太长。在 Unix 系统中采用的是成组链接法，这是将上述两种方法相结合而形成的一种空闲盘块管理方法。</p><p><img src="/images/image-20210810213250360.png" alt="image-20210810213250360"></p><p>文件区中的所有空闲盘块被分成若干个组，将每一组含有的盘块总数 N 和该组所有的盘块号记入其前一组的第一个盘块中。这样，由各组的第一个盘块可链成一条链。将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</p><p>使用成组链接法进行了上述分组之后，系统可根据申请的要求进行空闲盘块的分配，并在释放文件时回收空闲盘块。</p></li></ol><h2 id="6-5-目录管理"><a href="#6-5-目录管理" class="headerlink" title="6.5 目录管理"></a>6.5 目录管理</h2><p>文件目录是一组逻辑上的文件和子目录的集合，是一种管理文件系统中所有文件的机制。在目录管理中要求能实现文件的“按名存取”，即系统根据用户所提供的文件名，能快速准确地找到指定文件在外存上的存储位置。</p><h3 id="6-5-1-文件控制块和索引结点"><a href="#6-5-1-文件控制块和索引结点" class="headerlink" title="6.5.1 文件控制块和索引结点"></a>6.5.1 文件控制块和索引结点</h3><p>为了能对一个文件进行正确的存取，必须为文件设置用于描述和控制文件的数据结构，称之为“文件控制块（FCB）”。文件管理程序可借助于文件控制块中的信息，对文件施以各种操作。</p><ol><li><p>文件控制块</p><p>文件控制块通常含有三类信息，即基本信息、存取控制信息及使用信息。基本信息类包括文件名、文件物理位置、文件逻辑结构、文件的物理结构；存取控制信息类 包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限；使用信息类包括文件的建立日期和时间、文件上一次修改的日期和时间、当前使用信息等。</p></li><li><p>索引结点</p><p>随着文件的说明信息不断的增加，会使得目录项变得很大，从而占用大量的空间。由于目录通常存放在磁盘中，因此文件目录可能占用大量的盘块。在检索目录文件的过程中，只用到了文件名，而其它一些对该文件进行描述的信息，检索时一概不用。</p><p>为了加快对文件目录的查找，Unix 系统采用了把文件名和文件的说明信息分开的办法，由文件说明信息形成一个称为索引结点的数据结构，简称为 i 结点。文件目录只是将文件名和它的索引结点号结合在一起的一张表，目录中的每个目录项仅由文件 名和对应的 i 结点的指针所构成。这样，每个盘块能存放的目录项数量增加，从而查找一个文件平均需启动磁盘的次数减少，节省了系统开销。</p></li></ol><h3 id="6-5-2-目录结构"><a href="#6-5-2-目录结构" class="headerlink" title="6.5.2 目录结构"></a>6.5.2 目录结构</h3><p>文件目录是文件系统的关键数据结构，文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求文件实现按名存取。目前常用的目录结构形式有<strong>单级目录</strong>、<strong>两级目录</strong>和<strong>多级目录</strong>。</p><ol><li><p>单级目录结构 </p><p>这是最简单的目录结构。在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其它文件属性。</p><p>单级目录的优点是简单且能实现目录管理的基本功能——按名存取，但却存在一些缺点：查找速度慢；不允许重名；不便于实现文件共享；单级目录要求所有用户都用同一个名字来访问同一文件，因此单级目录只能适用于单用户环境。</p></li><li><p>两级目录</p><p>为了克服单级目录所存在的缺点，可以为每一个用户建立一个单独的用户文件目录 UFD（User File Directory）。这些文件目录具有相似的结构，它由用户所有文件的 文件控制块组成。此外，在系统中再建立一个主文件目录 MFD（Master File Directory）；在主文件目录中，每个用户目录文件都占有一个目录项，其目录项中包括用户名和指向该用户目录文件的指针。</p><p>两级目录结构基本上克服了单级目录的缺点，并具有以下优点：提高了检索目录的速度；在不同的用户目录中，可以使用相同的文件名；不同用户还可使用不同的文件名来访问系统中的同一个共享文件。</p></li><li><p>多级目录结构</p><ol><li>目录结构 </li></ol><p>对于大型文件系统，通常采用三级或三级以上的目录结构，以提高对目录的检索速度和文件系统的性能。多级目录结构又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。</p><ol start="2"><li>路径名 </li></ol><p>在树形目录结构中，从根目录到任何数据文件，都只有一条唯一的通路。在该路径上从树的根（即主目录）开始，把全部目录文件名与数据文件名依次地用“/”连接起来，即构成该数据文件的路径名。系统中的每一个文件都有唯一的路径名。</p><ol start="3"><li>当前目录 </li></ol><p>当前目录是指当前访问所处目录结构中的位置，有时也称为当前工作目录。当前目录常和相对路径名一起使用。用户指定一个目录为当前目录，这时所有不从根目录开始的路径名都是相对于当前的工作目录的。从当前目录开始直到数据文件为止所构成的路径名，称为<strong>相对路径</strong>名；而从根目录开始的路径名称为<strong>绝对路径</strong>名。</p><p>目前，大多数操作系统如 Unix、Linux 和 Windows 系列都采用了多级目录结构。</p></li></ol><h3 id="6-5-3-目录查询技术"><a href="#6-5-3-目录查询技术" class="headerlink" title="6.5.3 目录查询技术"></a>6.5.3 目录查询技术</h3><p>目前对目录进行查询的方式有两种: 线性检索法和 Hash 方法。</p><ol><li><p>线性检索法 </p><p>线性检索法又称为顺序检索法。在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。</p></li><li><p>Hash 方法 </p><p>如果建立了一张 Hash 索引文件目录，便可利用 Hash 方法进行查询，即系统利用用户提供的文件名并将它变换为文件目录的索引值，再利用该索引值到目录中去查找，这将显著地提高检索速度。</p></li></ol><h2 id="6-6-文件共享和保护"><a href="#6-6-文件共享和保护" class="headerlink" title="6.6 文件共享和保护"></a>6.6 文件共享和保护</h2><h3 id="6-6-1-文件共享"><a href="#6-6-1-文件共享" class="headerlink" title="6.6.1 文件共享"></a>6.6.1 文件共享</h3><p>文件共享是指系统允许多个用户使用同一个文件，其主要目的，一是提高文件存储空间的利用率，二是方便用户对文件的使用。目前常用的文件共享方式有基于索引结点的共享方式和利用符号链实现文件共享两种：</p><ol><li><p>基于索引结点的共享方式 </p><p>是指将多个目录项指向同一个磁盘索引结点的共享方式。该方式的缺点是文件主无法删除被他人共享的文件。</p><p>在索引结点中有一个链接计数 count，用于表示链接到本索引结点（即文件）上的用户目录项的数目。当 count=2 时，表示有两个用户目录项链接到本文件上，或者说是有两个用户共享此文件。</p><p>如当用户 A 创建一个新文件时，他便是该文件的所有者，此时将 count 置 1。当有用户 B 要共享此文件时，在用户 B 的目录中增加一目录项，并设置一个指针指向该文件的索引结点，此时，文件主仍然是 A，count=2。如果用户 A 不再需要此文件，并不能将此文件删除，若删除了该文件，也必然删除了该文件的索引结点，这样会使 B的指针悬空，而 B 可能正在此文件上执行写操作，此时将半途而废。</p></li><li><p>利用符号链实现文件共享 </p><p>这是指通过建立一个类型为 LINK、内容为被共享文件路径名的新文件来实现共享的方式。其一大优点是，只要简单提供一个机器的网络地址，以及文件在该机器中的文件路径名，就可链接全球任一处机器上的文件。</p><p>在利用符号链方式实现文件共享时，只有文件主才拥有指向其索引结点的指针，共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除共享文件后留下一悬空指针的情况。当文件的拥有者把一个共享文件删除后，其他用户试图通过符号链去访问一个已被删除的共享文件时， 会因系统找不到该文件而使访问失败，于是再将符号链删除，此时不会产生任何影响。</p></li></ol><h3 id="6-6-2-文件保护"><a href="#6-6-2-文件保护" class="headerlink" title="6.6.2 文件保护"></a>6.6.2 文件保护</h3><p>文件保护用来防止文件受到物理破坏和非法访问。</p><ol><li><p>访问类型 </p><p>对文件的保护可以从限制对文件的访问类型出发，可以加以控制的访问类型有：读、写、执行、添加、删除等。此外，还可以对文件的重命名、复制、编辑等加以控制。</p></li><li><p>访问控制 </p><p>访问控制就是对不同的用户访问同一个文件采取不同的访问类型。根据用户的权限不同，可以把用户划分为拥有者、工作组用户、其他用户等。然后对不同的用户组采取不同的访问类型，从而保护文件，防止文件被非法访问。</p></li><li><p>保护措施 </p><p>文件被破坏，有时是硬件故障、软件错误引起的，有时是用户共享文件时使用未授权的操作引起的，也可能是由于非法用户的使用造成的，因此，文件系统应根据不同情况，采用不同的保护措施。</p><ol><li>防止系统故障造成的破坏</li></ol><p>文件系统必须有防止硬、软件的各种意外可能破坏文件的能力，为此，文件系统经常采用建立副本和文件转储的方法来保护文件。</p><ul><li><p>建立副本：是指把同一文件保存到多个存储介质上作为备用副本，以便恢复被丢失的文件信息，增强系统存储文件的可靠性。</p></li><li><p>文件转储：是指每隔一定的时间把文件转储到其它的存储介质上，有全部存储和增量存储两种方式。其中全部存储是指把某一文件存储器的全部信息都定期复制到磁带。增量转储是指定期转储那些上次转储以来被修改过的文件和目录。</p><p>文件转储不仅可以保护用户文件，而且当系统出现故障时，可用该办法修复系统。</p></li></ul><ol start="2"><li>防止用户共享文件可能造成的破坏 </li></ol><p>对共享文件要防止用户非法使用造成的破坏，这就涉及到用户对文件的使用权限，通常可以用下列方法来规定使用权限：</p><ol><li>存取控制矩阵：用一个二维矩阵列出每个用户对每个文件或子目录的存取权限。</li><li>存取控制表：为每个文件建立一张存取控制表，表中指出各类用户对该文件的存储权限。</li><li>用户权限表：对于系统中每一个用户给出一张用户权限表，列出授权可访问的文件清单及所具有的访问权限。</li></ol><ol start="3"><li>防止非法用户窃取、破坏文件</li></ol><p>为防止未经文件拥有者授权的用户窃取或破坏文件，可采用如下三种保密措施：</p><ol><li>隐蔽文件目录：通过专用命令将保密文件的文件目录隐蔽起来，不在显示器上显示，使非授权用户不知道文件名，无法使用文件。</li><li>设置口令：设置口令的方法有两种，一种是建立文件时，把口令存放在文件目录中；另一种是为每个注册用户规定一个口令，当用户欲使用文件时，须提供口令，只有与所设置的口令相符才能访问文件。</li><li>使用密码：使用密码是指用户在保存文件时进行加密，生成密码文件，使用文件时再将其解密，只有持有密钥的用户才能正确读出被加密的文件，非授权用户无法窃取文件信息。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2021/08/09/6%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2021/08/09/6%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1. 计算机系统概述"></a>1. 计算机系统概述</h1><h2 id="1-1-计算机的发展和应用"><a href="#1-1-计算机的发展和应用" class="headerlink" title="1.1 计算机的发展和应用"></a>1.1 计算机的发展和应用</h2><ol><li><p>计算机的发展</p><p>1946 年，世界上第一台计算机（ENIAC）诞生于美国宾夕法尼亚大学；此后，计算机硬件技术获得了飞速地发展，主要可分为四个阶段</p><p><img src="/images/image-20210809152037830.png" alt="image-20210809152037830"></p></li><li><p>计算机的应用</p><ol><li><p>科学计算</p><p>这是计算机应用最早的领域，利用计算机来完成科学研究和工程技术中提出的数学问题的计算。</p></li><li><p>过程控制</p><p>将计算机应用于机械、冶金、纺织、水电、航天等各个领域生产过程的自动控制，减轻劳动强度，提高产品质量和生产效率。</p></li><li><p>人工智能</p><p>人工智能是计算机模拟人类的智能活动，近年来主要应用于图像识别、语音识别、语言翻译、专家系统、机器人等领域。</p></li><li><p>数据处理</p><p>用计算机对各种数据进行分析、加工、变换或综合处理。据统计，80%以上的计算机主要用于数据处理。</p></li><li><p>计算机辅助应用</p><ul><li>计算机辅助设计（CAD）</li><li>计算机辅助制造（CAM）</li><li>计算机辅助教学（CAI）</li><li>计算机辅助测试（CAT）</li><li>计算机辅助工程（CAE）</li></ul></li><li><p>网络应用</p><p>计算机技术与通信技术的结合构成了计算机网络。目前，网络应用已经涉及人类生活的方方面面，正在改变着整个世界。</p></li><li><p>多媒体技术</p><p>最初的计算机只能处理文字，由于新技术的运用，计算机可以处理文字、图像、</p><p>动画、声音等各种数据，这种技术被称为“多媒体技术”。</p></li><li><p>电子商务</p><p>电子商务通常是指在全球各地广泛的商业贸易活动中，在因特网开放的网络环境下，基于浏览器/服务器应用方式进行各种商贸活动。电子商务主要的分类有： B2B、B2C、C2C、B2G、C2G、O2O 等。</p></li></ol></li><li><p>计算机的发展趋势</p><ol><li><p>巨型化</p><p>巨型化是指计算机的运算速度更高、存储容量更大、功能更强。目前正在研制的</p><p>巨型计算机其运算速度可达每秒亿亿次级别。</p></li><li><p>微型化</p><p>微型计算机已进入仪器、仪表、家用电器等小型仪器设备中，同时也作为工业控制过程的心脏，使仪器设备实现“智能化”。随着微电子技术的进一步发展，笔记本型、掌上型等微型计算机必将以更优的性能价格比受到人们的欢迎。</p></li><li><p>智能化</p><p>计算机人工智能化是未来发展的必然趋势。现代计算机具有强大的功能和运行速度，但与人脑相比，其智能化和逻辑能力仍有待提高。新一代计算机，将可以模拟人的感觉行为和思维过程的机理，进行“看”、“听”、“说”、“想”、“做”，具有逻辑推理、学习与证明的能力。</p></li><li><p>网络化</p><p>互联网将世界各地的计算机连接在一起，从此进入了互联网时代。</p></li><li><p>多媒体化</p><p>传统的计算机处理的信息主要是字符和数字。事实上，人们更习惯的是图片、文字、声音等多种形式的多媒体信息。多媒体技术可以集图形、图像、音频、视频、文字为一体，使信息处理的对象和内容更加接近于真实世界。</p></li></ol></li></ol><h2 id="1-2-计算机的特点和分类"><a href="#1-2-计算机的特点和分类" class="headerlink" title="1.2 计算机的特点和分类"></a>1.2 计算机的特点和分类</h2><ol><li><p>按数据处理方式</p><ol><li><p>数字式计算机</p><p>数字式电子计算机是当今世界电子计算机行业中的主流，其内部处理的是一种称为符号信号或数字信号的电信号。</p></li><li><p>模拟式计算机</p><p>模拟式电子计算机问世较早，内部所使用的电信号模拟自然界的实际信号，因而称为模拟电信号。</p></li><li><p>数字模拟混合式计算机</p><p>混合计算机是取数字、模拟计算机之长，既能高速运算，又便于存储信息。</p></li></ol></li><li><p>按计算机用途</p><ol><li><p>专用计算机</p><p>专用计算机是指为适应某种特殊应用而设计的计算机，一般用在过程控制中，如智能仪表、飞机的自动控制、导弹的导航系统等。</p></li><li><p>通用计算机</p><p>通用计算机是指为解决各种问题，具有较强的通用性而设计的计算机。该机适用于一般的科学计算、学术研究、工程设计和数据处理等用途，具有较大的适用范围。</p></li></ol></li><li><p>按计算机性能</p><ol><li><p>巨型计算机</p><p>运算速度快、存储容量大，价格相当昂贵，主要用于复杂、尖端的科学研究领域，特别是军事科学计算。</p></li><li><p>大/中型计算机</p><p>通用性能好、外部设备负载能力强、处理速度快。它有完善的指令系统，丰富的外部设备和功能齐全的软件系统，并允许多个用户同时使用。主要用于科学计算、数据处理或做网络服务器。</p></li><li><p>小型计算机</p><p>具有规模较小、结构简单、成本较低、操作简单、易于维护、与外部设备连接容易等特点。</p></li><li><p>微型计算机</p><p>以运算器和控制器为核心，加上由大规模集成电路制作的存储器、输入/输出接口和系统总线，构成了体积小、结构紧凑、价格低但又具有一定功能的计算机。</p></li><li><p>单片机</p><p>单片机把 CPU、一定容量的存储器和输入/输出接口电路集成到一个芯片上，它是一片特殊的、具有计算机功能的集成电路芯片，一般用作专用机或用来控制高级仪器、家用电器等。</p></li></ol></li><li><p>按计算机使用方式</p><ol><li><p>桌面型计算机</p><p>桌上型计算机包括 PC 机、工作站和笔记本型计算机，为用户提供良好的计算性能和较低成本的工作环境。桌上型计算机是成本低、应用广的计算机类型。</p></li><li><p>服务器型计算机</p><p>服务器型计算机是指在网络环境或具有客户-服务器结构的分布式计算环境中，为客户请求提供服务的节点计算机。</p></li><li><p>嵌入式计算机</p><p>嵌入式计算机是将计算机作为一个部件，成为某个设备的一部分，嵌入式计算机成本更低，用途更广。它一般面向特定应用。不同的嵌入式应用有不同的要求，需要根据不同的应用进行专门的开发设计。</p></li></ol></li></ol><h2 id="1-3-计算机的性能指标"><a href="#1-3-计算机的性能指标" class="headerlink" title="1.3 计算机的性能指标"></a>1.3 计算机的性能指标</h2><ol><li><p>字长</p><p>字长以二进制为单位，是 CPU 一次能够处理的二进制数据的位数，它直接关系到计算机的计算精度和运算能力。微机字长一般都以 2 的 n 次方为单位，如 8 位、16 位、32 位、64 位等。</p></li><li><p>运算速度</p><p>由于计算机执行不同类型指令所需时间不同，所以通常用各类指令的平均执行时间和相应指令的运行比例进行综合计算，作为衡量计算机运行速度的标准。用来衡量运算速度的指标有 MIPS（百万条指令/秒）、MFLOPS（百万次浮点运算/秒）以及 CPI（Clock cycle Per Instruction，执行一条指令所需的时钟周期）。</p></li><li><p>时钟频率</p><p>时钟频率，也称主频，是指 CPU 在单位时间（秒）内发出的脉冲数。通常，时钟频率以兆赫（MHz）和吉赫（GHz）为单位。一般时钟频率越高，其运算速度就越快。</p></li><li><p>内存容量</p><ul><li><p>位</p><p>计算机中最小的数据单位是二进制的一个数位，简称为位（bit，比特）。一个二进制位可表示两种状态（0 或 1）</p></li><li><p>字节</p><p>为了表示数据中的字符（包括字母、数字以及各种专用符号等），需要用 7 位或8 位二进制数，人们选定 8 位为一个字节（Byte），通常用 B 表示。字节是计算机中用来表示存储空间的最基本的容量单位。</p><p>除用字节为单位表示存储容量外，还可以用千字节（KB）、兆字节（MB）以及吉兆字节（GB）等表示存储容量，它们之间存在下列换算关系</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1B</span> = <span class="hljs-number">8</span> bit<br><span class="hljs-attribute">1KB</span> = <span class="hljs-number">2</span>^<span class="hljs-number">10</span> B =<span class="hljs-number">1024</span> B<br><span class="hljs-attribute">1MB</span> = <span class="hljs-number">2</span>^<span class="hljs-number">20</span> B =<span class="hljs-number">1024</span> KB<br><span class="hljs-attribute">1GB</span> = <span class="hljs-number">2</span>^<span class="hljs-number">30</span> B = <span class="hljs-number">1024</span> MB<br><span class="hljs-attribute">1TB</span> = <span class="hljs-number">2</span>^<span class="hljs-number">40</span> B = <span class="hljs-number">1024</span> GB<br></code></pre></td></tr></table></figure><p>内存一般以 KB、MB 或 GB 为单位。内存容量反映了内存储器存储数据的能力。存储容量越大，其主机处理数据的范围就越广，运算速度一般也就越快。</p></li></ul></li></ol><h2 id="1-4-计算机系统的组成和结构"><a href="#1-4-计算机系统的组成和结构" class="headerlink" title="1.4 计算机系统的组成和结构"></a>1.4 计算机系统的组成和结构</h2><ol><li><p>冯·诺依曼计算机</p><p><strong>存储程序</strong>的概念是由冯·诺依曼于 1945 年提出的，它奠定了现代计算机的结构基础。尽管过去了几十年，但目前广泛应用的计算机仍然是依据冯·诺依曼提出的结构体系和工作原理来设计制造的，故又统称为“冯·诺依曼计算机”。</p><ol><li><p>冯·诺依曼思想</p><ul><li><p>计算机的五大组成</p><p>计算机由运算器、控制器、存储器、输入设备和输出设备五大部件组成。</p></li><li><p>采用二进制</p><p>采用二进制形式存储所有的信息，即计算机内不管是程序还是待处理的数据或是其他信息均为二进制编码形式。</p></li><li><p>存储程序</p><p>这是冯·诺依曼思想的核心。将事先编好的程序存入计算机中，计算机按照这些程序自动运行，这是计算机自动连续工作的基础。</p></li></ul></li><li><p>冯·诺依曼计算机的工作原理</p><ol><li><p>存储程序：将要执行的程序和数据事先编成二进制形式的编码存入主存储器中。</p></li><li><p>程序控制：程序自动地、连续地从主存储器中依次取出指令并执行，直到获得所要求的结果为止。</p></li></ol><p>典型的冯·诺依曼计算机是以运算器为中心的，而现代的计算机已经转为以存储器为中心。</p></li></ol></li><li><p>计算机系统的构成</p><p>一个计算机系统包括硬件系统和软件系统两大部分。硬件是由各种电介质、磁介质及机械的器件组成的物理实体，包括运算器、控制器、存储器、输入设备和输出设备等五个基本部分。软件则是程序和有关文档的总称，通常存放在计算机的主存或辅存内。</p><p>在一个具体的计算机系统中，硬件、软件是紧密相关、缺一不可的，但对某一具体功能来说，既可以用硬件实现，也可以用软件实现，这是硬件、软件在逻辑功能上的等效。硬件、软件在逻辑功能上的等效是指任何由硬件实现的操作，在原理上均可用软件模拟来实现；同样，任何由软件实现的操作，在原理上都可由硬件来实现。因此在设计一个计算机系统时，须根据设计要求、现有技术与器件条件，首先确定哪些功能直接由硬件实现，哪些功能通过软件实现，这是硬件和软件的功能分配。</p><ol><li><p>硬件系统</p><p>计算机的硬件系统由主机系统和外部设备两部分组成，把运算器、控制器与内存储器统称为计算机主机，而把外存储器、输入设备、输出设备称为计算机的外部设备</p><p><img src="/images/image-20210809161507099.png" alt="image-20210809161507099"></p><ol><li>主机</li></ol><ul><li><p>运算器用于对数据的加工处理，完成算术运算和逻辑运算。算术运算是指按照算术运算规则进行的运算，如加、减、乘、除及其复合运算。逻辑运算为非算术性的运算，如与、或、非、异或等。运算器的核心是算术逻辑部件(ALU，Arithmetic Logical Unit)。运算器中还设有若干寄存器，用于暂存操作数据和中间结果。由于这些寄存器往往兼备多种用途，如用作累加器、变址寄存器、基址寄存器等，所以通常称为通用寄存器。</p></li><li><p>控制器是整个计算机的指挥中心，它按照事先安排好的步骤，控制计算机各个部件有条不紊地自动工作。通常把运算器和控制器统称为 CPU。</p></li><li><p>计算机具有超强的记忆能力，是因为计算机中有存储器部件。CPU 能够直接访问的是内存储器（也称内存，主存）。内存主要由两部分组成：随机存储器和只读存储器。</p><p><strong>随机存储器</strong></p><p> 随机存储器（RAM，Random Access Memory）可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</p><p><strong>只读存储器</strong></p><p>只读存储器（ROM，Read Only Memory）所存数据，一般是装入整机前事先写好的，计算机工作过程中只能读出，而不像随机存储器那样能快速、方便地加以改写。ROM 所存数据稳定，断电后也不会改变，常用于存储各种固定程序和数据。</p></li></ul><ol start="2"><li>外部设备</li></ol><ul><li>外存储器又称为外存、辅存，是计算机系统中除内存储器外，以计算机能接受的形式存储信息的媒体，如硬盘、软盘、光盘、U 盘等。其特点是能长期保存数据，而且价格便宜，存储量大。</li><li>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入到计算机内。最常用也是最基本的输入设备是键盘、鼠标、扫描仪、摄像机等。</li><li>输出设备的任务是将计算机处理的结果以人们所能接受的信息形式或其他系统所要求的信息形式输出。最常用且最基本的输出设备是显示器、打印机、绘图仪等。</li></ul></li><li><p>软件系统</p><p>计算机软件系统包括系统软件和应用软件两大类。</p><ul><li>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。主要有以下几类：操作系统，语言处理程序如编译器和解释器，数据库管理系统，各种服务程序如装入程序、调试程序、诊断程序等。</li><li>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、数据统计与处理程序、情报检索程序、生产过程控制程序等。</li></ul></li><li><p>计算机系统的层次结构</p><p><img src="/images/image-20210809162855358.png" alt="image-20210809162855358"></p><ul><li>第 0 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。</li><li>第 1 级是机器语言层，这一层由微程序解释机器指令系统。</li><li>第 2 级是操作系统层，它由操作系统程序实现。操作系统由机器指令和广义指令组成的，这些广义指令是为扩展机器功能而设置的，是由操作系统定义和解释的软件指令。</li><li>第 3 级是汇编语言层，它为用户提供一种符号形式语言，借此可编写汇编语言源程序，这一层由汇编程序支持和执行。</li><li>第 4 级是高级语言层，它是面向用户的，为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。</li></ul></li></ol><p>从计算机系统的多级层次结构来看，可以将硬件研究的主要对象归结为机器语言层和微程序机器层。软件的研究对象主要是操作系统级以上的各级虚拟机。软硬件交界界面的划分并不是一成不变的，随着超大规模集成电路技术的不断发展，一部分软件功能将由硬件来实现，如目前操作系统已实现了部分固化（把软件永久地存于只读存储器中），称为固件。可以认为固件是一种介于传统的软件和硬件之间的实体，就它的功能来说，类似软件，但从形态来说，又类似硬件。</p></li></ol><h1 id="2-数据的表示和运算"><a href="#2-数据的表示和运算" class="headerlink" title="2. 数据的表示和运算"></a>2. 数据的表示和运算</h1><h2 id="2-1-进制转换"><a href="#2-1-进制转换" class="headerlink" title="2.1 进制转换"></a>2.1 进制转换</h2><h3 id="2-1-1-非十进制数转换成十进制数"><a href="#2-1-1-非十进制数转换成十进制数" class="headerlink" title="2.1.1 非十进制数转换成十进制数"></a>2.1.1 非十进制数转换成十进制数</h3><ol><li><p>方法</p><p>每位上的数码×基的位次方，然后求和。</p></li><li><p>例题</p><ul><li><p>二进制转化成十进制</p><p><img src="/images/image-20210809164512606-1628498745947.png" alt="image-20210809164512606"></p></li><li><p>八进制转化成十进制</p><p><img src="/images/image-20210809164624318.png" alt="image-20210809164624318"></p></li><li><p>十六进制转换成十进制</p><p><img src="/images/image-20210809164711882.png" alt="image-20210809164711882"></p></li></ul></li></ol><h3 id="2-1-2-十进制数转换成非十进制数"><a href="#2-1-2-十进制数转换成非十进制数" class="headerlink" title="2.1.2 十进制数转换成非十进制数"></a>2.1.2 十进制数转换成非十进制数</h3><ol><li><p>方法</p><p>整数部分：除 N 取余数，直至商为 0，余数倒输出。</p><p>小数部分：乘 N 取整数，直至小数部分为 0（或满足精度），整数正输出。</p></li><li><p>例题</p><ul><li><p>十进制数转换成二进制数</p><p>将十进制数（37.75）10 转换为二进制数</p><p>整数部分 37 转换如下：</p><p><img src="/images/image-20210809164922824.png" alt="image-20210809164922824"></p><p>小数部分 0.75 转换如下：</p><p><img src="/images/image-20210809165213659.png" alt="image-20210809165213659"></p></li><li><p>十进制数转换成八进制数</p><p>将十进制数（1725.6875）10 转换成八进制数。</p><p>整数部分 1725 转换如下：</p><p><img src="/images/image-20210809165314031.png" alt="image-20210809165314031"></p><p>小数部分 0.6875 转换如下：</p><p><img src="/images/image-20210809165349992.png" alt="image-20210809165349992"></p></li></ul></li></ol><h3 id="2-1-3-二-八-十六进制数的互相转换"><a href="#2-1-3-二-八-十六进制数的互相转换" class="headerlink" title="2.1.3 二/八/十六进制数的互相转换"></a>2.1.3 二/八/十六进制数的互相转换</h3><ol><li><p>方法</p><p>由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。</p></li><li><p>例题</p><ol><li><p>八进制数转换成二进制数</p><p>将八进制数（624.31）8 转换成二进制数。</p><p><img src="/images/image-20210809165850639.png" alt="image-20210809165850639"></p></li><li><p>二进制数转换成八进制数</p><p>将二进制数（11101.00101011）2转换成八进制数。</p><p><img src="/images/image-20210809165955164.png" alt="image-20210809165955164"></p></li><li><p>十六进制数转换成二进制数</p><p>将十六进制数（1AC0.6D）16 转换成相应的二进制数。</p><p><img src="/images/image-20210809170053141.png" alt="image-20210809170053141"></p></li><li><p>二进制数转换成十六进制数</p><p>将二进制数（10111100101.00011001101）2 转换成相应的十六进制数。</p><p><img src="/images/image-20210809170155255.png" alt="image-20210809170155255"></p></li></ol></li></ol><h2 id="2-2-数值型数据的表示"><a href="#2-2-数值型数据的表示" class="headerlink" title="2.2 数值型数据的表示"></a>2.2 数值型数据的表示</h2><h3 id="2-2-1-机器数"><a href="#2-2-1-机器数" class="headerlink" title="2.2.1 机器数"></a>2.2.1 机器数</h3><p>无符号数，是指整个机器字长的全部二进制位均表示数值位（没有符号位），相当于数的绝对值。例如：0101 表示无符号数 5，1100 表示无符号数 12。然而，大量用到的数据还是带符号数，即正数和负数。在日常生活中用“＋”、“－”加绝对值来表示数值的大小，用这种形式表示的数值在计算机中称为“真值”。</p><p>对于数的符号 “＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，<strong>“0”表示正号</strong>，<strong>“1”表示负号</strong>。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。</p><ol><li><p>原码</p><p>原码表示法是机器数的一种简单的表示法。其符号位用 0 表示正号，用 1 表示负号，数值一般用二进制形式表示。设有一数用 X 表示真值，则原码表示可记作[X]<sub>原</sub>，例如：</p><p><img src="/images/image-20210809170718607.png" alt="image-20210809170718607"></p></li><li><p>反码</p><p>机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用 X 表示真值，那么 X 的反码表示记作[X]<sub>反</sub>，例如</p><p><img src="/images/image-20210809170845433.png" alt="image-20210809170845433"></p></li><li><p>补码</p><p>机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用 X 表示真值，则 X 的补码表示记作[X]<sub>补</sub>，例如：</p><p><img src="/images/image-20210809171108042.png" alt="image-20210809171108042"></p></li><li><p>补码的加减法运算</p><ul><li><p>补码加法</p><p>两个补码表示的数相加，符号位参加运算，且两数和的补码等于两数补码之和，即：</p><p><img src="/images/image-20210809171245746.png" alt="image-20210809171245746"></p></li><li><p>补码减法</p><p>根据补码加法公式可推出：</p><p><img src="/images/image-20210809171327665.png" alt="image-20210809171327665"></p></li><li><p>符号扩展</p><p>在计算机算术运算中，有时必须将采用给定位数表示的数转换成具有更多位数的某种表示形式。如某个程序需要将一个 8 位数与另外一个 32 位数相加。要想得到正确的结果，在将 8 位数与 32 位数相加之前，必须将 8 位数转换成 32 位数形式，这被称为“符号扩展”。</p><p>对于补码，符号扩展方法是：原有符号位保持不变，若为正数则所有附加位都用0 进行填充；若为负数则所有附加位都用 1 进行填充。该方法也可以理解为是用符号位来填充附加的高位。</p><p>如将用 8 位二进制补码表示的十进制数−121，扩展成 16 位二进制补码，结果用十六进制表示。</p><p>【解析】：十进制数−121 的 8 位二进制补码表示为 10000111，扩展成 16 位二进制补码，符号扩展表示为 1111111110000111= FF87H。</p></li><li><p>补码溢出的产生</p><p>在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为 0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为 n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于 2<sup>n-1</sup> 或小于-2<sup>n</sup>时，就产生溢出。</p><p>设参加运算的两数为 X、Y，做加法运算：</p><ul><li>若 X、Y 异号，不会溢出；</li><li>若 X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。</li></ul></li><li><p>补码溢出的检测</p><p>设被操作数为[X]补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补</p><p>=SsS1S2…Sn，则判断溢出的方法有以下三种：</p><ol><li>采用一个符号位</li></ol><p>两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：</p><ul><li>当 Xs=Ys=0，Ss=1 时，产生正溢；</li><li>当 Xs=Ys=1，Ss=0 时，产生负溢。</li></ul><ol start="2"><li>采用进位位 (没看懂)</li></ol><p>两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1为</p><p>最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1=1）而符号位不产生进位（Cs=0）时，发生正溢。两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs=1）时，发生负溢。</p><p>3）采用变形补码（双符号位补码）</p><p>在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：</p><p><img src="/images/image-20210809173329983.png" alt="image-20210809173329983"></p></li></ul></li></ol><h3 id="2-2-2-定点数和浮点数表示"><a href="#2-2-2-定点数和浮点数表示" class="headerlink" title="2.2.2 定点数和浮点数表示"></a>2.2.2 定点数和浮点数表示</h3><p>(这里没看懂)</p><p>在计算机中，一般用若干个二进制位表示一个数或一条指令，把它们作为一个整体来处理、存储和传送。这种作为一个整体来处理的二进制位串，称为计算机字。表示数据的字称为数据字，表示指令的字称为指令字。</p><p>计算机是以字为单位进行处理、存储和传送的，所以运算器中的加法器、累加器以及其他一些寄存器，都选择与字长相同的位数。字长一定，则计算机数据字所能表示的数的范围也就确定了。例如，使用 8 位字长的计算机，它可以表示无符号整数的最大值是（255）10=（11111111）2。运算时，若数值超出机器数所能表示的范围，就会停止运算和处理，这种现象称为溢出。</p><ol><li><p>定点数</p><p>计算机中运算的数有整数也有小数，对于小数点的位置的确定，通常有两种约定：一种是规定小数点的位置固定不变，这时的机器数称为定点数；另一种是小数点的位置可以浮动，这时的机器数称为浮点数。微型机多使用定点数。</p><p>数的定点表示是指数的小数点位置是固定不变的。小数点位置可以固定在符号位和第一数值位之间，这时表示一个纯小数；如果把小数点位置固定在数值位的最后，这时表示一个纯整数。</p></li><li><p>浮点数</p><p>浮点表示法就是小数点在数中的位置是浮动的。在以数值计算为主要任务的计算机中，由于定点表示法所能表示的数的范围太窄，不能满足计算问题的需要，因此就要采用浮点表示法。在同样字长的情况下，浮点表示法能表示的数的范围扩大了。</p><p>计算机中的浮点表示法包括两个部分：一部分是阶码（表示指数，记作 E）；另一部分是尾数（表示有效数字，记作 M）。设任意一个数 N 可以表示为</p><p><img src="/images/image-20210809182327967.png" alt="image-20210809182327967"></p><p>由尾数部分隐含的小数点位置可知，尾数总是小于 1 的数字，它给出该浮点数的有效数字。尾数部分的符号位确定该浮点数的正负。阶码给出的总是整数，它确定小数点浮动的位数。</p><p>浮点数表示法对尾数有如下规定：0.5 ≤M＜l，即要求尾数中第一位数不为零，这样的浮点数称为规格化数。</p><p>在浮点数表示和运算中，当一个数的阶码大于机器所能表示的最大阶码时，产生“上溢”。上溢时机器一般不再继续运算而转入“溢出”处理。当一个数的阶码小于机器所能表示的最小阶码时，产生“下溢”，此时溢出的数绝对值很小，通常将尾数各位置为 0，按机器零来处理，此时计算机可以继续运行。 </p><p><img src="/images/image-20210809182535771.png" alt="image-20210809182535771"></p></li><li><p>IEEE754 标准</p><ul><li><p>标准格式</p><p>IEEE754 标准中 32 位浮点数的标准格式为：</p><p><img src="/images/image-20210809182642383.png" alt="image-20210809182642383"></p><p>这里 <em>M</em> 是尾数的二进制表示， (<em>E</em>)<sub>10</sub> 为阶码的十进制表示，其范围是 1～254。</p><p>当阶码 <em>E</em> 和尾数 <em>M</em> 取特殊值时，对应的 <em>x</em> 值如表 2-1 所示。</p><p><img src="/images/image-20210809182856019.png" alt="image-20210809182856019"></p></li><li><p>习题举例</p><p><img src="/images/image-20210809183233934.png" alt="image-20210809183233934"></p></li></ul></li></ol><h2 id="2-3-浮点加减法运算"><a href="#2-3-浮点加减法运算" class="headerlink" title="2.3 浮点加减法运算"></a>2.3 浮点加减法运算</h2><p>暂时不深入学习</p><h2 id="2-4-逻辑运算和移位操作"><a href="#2-4-逻辑运算和移位操作" class="headerlink" title="2.4 逻辑运算和移位操作"></a>2.4 逻辑运算和移位操作</h2><p>运算器除了要完成数值数据的算术运算外，还要完成逻辑运算和移位运算。</p><h3 id="2-4-1-逻辑运算"><a href="#2-4-1-逻辑运算" class="headerlink" title="2.4.1 逻辑运算"></a>2.4.1 逻辑运算</h3><p>计算机中的逻辑运算包括与、或、非、异或等运算。由于逻辑数是非数值数据，其每一位的 “0”、“1”仅用于表示逻辑上的“真”与“假”，因此逻辑运算的特点是：按位运算，运算结果的各位之间互不影响，不存在进位、借位、溢出等问题。</p><ol><li><p>“与”运算</p><p>“与”运算又称逻辑乘，用符号“∧”、或“×”、或 AND 表示（一假皆假）</p></li><li><p>“或”运算</p><p>“或”运算又称逻辑加，用符号“＋”、或“∨”、或 OR 表示（一真皆真）。</p></li><li><p>“非”运算</p><p>“非”运算又称“求反”，一般在变量上加横线、或加 NOT 表示（取其反值）。</p></li><li><p>“异或”运算</p><p>“异或”运算又称“按位加”，一般用符号⊕表示（相异为真）。</p></li></ol><h3 id="2-4-2-移位运算"><a href="#2-4-2-移位运算" class="headerlink" title="2.4.2 移位运算"></a>2.4.2 移位运算</h3><p>移位运算称为移位操作，对计算机来说有很大的实用价值。如当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，以实现乘（除）运算。</p><p>计算机中机器数的字长往往是固定的，当机器数左移 n 位或右移 n 位时，必然会使其 n 位低位或 n 位高位出现空位。对空出的空位应该添补 0 还是 l，与机器数采用有符号数还是无符号数有关。对有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。</p><p>算术移位的规则是：</p><ul><li><p>首先，不论是正数还是负数，移位后其符号位均不变；</p></li><li><p>其次，对于正数，移位后出现的空位均添 0；</p></li></ul><p> 对于负数，其空位的添补规则也不同：</p><ol><li><p>原码时，其空位均添 0； </p></li><li><p>反码时，其空位均添 1； </p></li><li><p>补码时，左移其空位添 0，右移其空位添 1。</p></li></ol><p>逻辑移位的规则是：</p><ul><li><p>逻辑左移时，高位移丢，低位添 0；</p></li><li><p>逻辑右移时，低位移丢，高位添 0。</p></li></ul><p>如寄存器内容为 10110010，逻辑右移为 01011001，若将其视为补码，算术右移为11011001。</p><h2 id="2-5-非数值型数据的表示"><a href="#2-5-非数值型数据的表示" class="headerlink" title="2.5 非数值型数据的表示"></a>2.5 非数值型数据的表示</h2><h3 id="2-5-1-ASCII-码"><a href="#2-5-1-ASCII-码" class="headerlink" title="2.5.1 ASCII 码"></a>2.5.1 ASCII 码</h3><p>美国信息交换标准代码（American Strandard Code for Information Interchage，ASCII）是一种西文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等 95 种可打印字符，以及 33 种控制字符（如回车、换行等），通常采用一个字节编码，由 7 位二进制编码组成，字节的最高位一般规定为 0，或用作校验码，可表示 128 个不同的字符。</p><h3 id="2-5-2-汉字的编码"><a href="#2-5-2-汉字的编码" class="headerlink" title="2.5.2 汉字的编码"></a>2.5.2 汉字的编码</h3><ol><li><p>国标码</p><p>《信息交换用汉字编码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的 6763 个汉字和 682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低 7位，最高位为 0。</p></li><li><p>汉字机内码</p><p>汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。</p></li><li><p>汉字输入码</p><p>汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。</p></li><li><p>汉字字形码</p><p>汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，主要有 16×16 点阵、32×32 点阵、256×256 点阵等。</p></li></ol><h3 id="2-5-3-十进制数的编码"><a href="#2-5-3-十进制数的编码" class="headerlink" title="2.5.3 十进制数的编码"></a>2.5.3 十进制数的编码</h3><p>人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。</p><p>人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或 BCD 编码。BCD 编码方法很多，通常采用的是 8421 编码。其方法是用四位二进制数表示一位十进制数，自左至右每一位对应的位权分别是 8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了 0000～1001 十种状态，而 1010～1111 六种状态在这种编码中没有意义。如十进制数 864，其 BCD 进制编码为 100001100100。 </p><h2 id="2-6-数据校验码"><a href="#2-6-数据校验码" class="headerlink" title="2.6 数据校验码"></a>2.6 数据校验码</h2><h3 id="2-6-1-奇偶校验码"><a href="#2-6-1-奇偶校验码" class="headerlink" title="2.6.1 奇偶校验码"></a>2.6.1 奇偶校验码</h3><p>为了校验编码的正确性，在被传送的 n 位有效信息代码上增加一位校验位，并使其配置后的 n+1 位代码中“1”的个数为奇数，则称其为奇校验；若配置后“1”的个数为偶数，则称其为偶校验。对于奇校验码而言，倘若传送过程中“1”的个数不为奇数，则表明传送出错，可见，奇校验码具有检错能力。同理，偶校验码也具有检错能力。</p><h3 id="2-6-2-循环冗余校验码"><a href="#2-6-2-循环冗余校验码" class="headerlink" title="2.6.2 循环冗余校验码"></a>2.6.2 循环冗余校验码</h3><p>循环冗余校验码（CRC）在磁介质存储器和计算机之间通信方面有广泛应用。CRC码是基于模 2 运算建立的校验码，将待编码的有效信息左移若干位后，用另一个约定的多项式去除，所产生的余数就是检验位。有效信息和检验位相拼接就构成了 CRC码。</p><h3 id="2-6-3-海明校验码"><a href="#2-6-3-海明校验码" class="headerlink" title="2.6.3 海明校验码"></a>2.6.3 海明校验码</h3><p>海明码是目前广泛采用的一种有效的校验码，其实现原理是：在有效信息位中加入几个校验位形成海明码，当某一位出错后，就会引起有关的几个校验位的值发生变化，因此海明码不但可以发现错误，还能指出错误的位置，为自动纠错提供了依据。</p><h1 id="3-指令和总线"><a href="#3-指令和总线" class="headerlink" title="3. 指令和总线"></a>3. 指令和总线</h1><h2 id="3-1-指令系统"><a href="#3-1-指令系统" class="headerlink" title="3.1 指令系统"></a>3.1 指令系统</h2><h3 id="3-1-1-指令系统概述"><a href="#3-1-1-指令系统概述" class="headerlink" title="3.1.1 指令系统概述"></a>3.1.1 指令系统概述</h3><ol><li><p>指令系统组成</p><p>计算机的程序是由一系列的机器指令组成的。</p><p>指令就是要计算机执行某种操作的命令。从计算机组成的层次结构来说，计算机的指令有<strong>微指令</strong>、<strong>机器指令</strong>和<strong>宏指令</strong>之分，微指令是微程序级的命令，它属于硬件；宏指令是由若干条机器指令组成的软件指令，它属于软件；而机器指令则介于微指令与宏指令之间，是硬件和软件的交界面，通常简称为指令，每条指令可完成一个独立的算术运算或逻辑运算操作。</p><p>一台计算机中所有机器指令的集合，称为这台计算机的指令系统。指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。</p><p>指令系统一般由两种类型的指令组成：</p><p>1）<strong>非特权指令</strong></p><p>主要供用户使用，又可分为功能性指令和非功能性指令两种。功能性指令主要包括算术逻辑指令、数据传送指令、浮点运算指令、字符串指令等；非功能性指令主要包括转移指令、控制指令等。</p><p>2）<strong>特权指令</strong></p><p>主要供系统程序员使用，一般不允许用户使用。其中包括 I/O 指令、停机等待指令、存储管理及保护指令、控制系统状态指令、诊断指令等。若用户希望使用这类指令，必须先通过访管指令调用操作系统，再由操作系统控制和执行这些特权指令。</p><p>性能较好的指令系统一般都满足以下几个原则：</p><p>1）完备性</p><p>完备性指的是指令系统应功能齐全，给用户带来方便。用户的所有操作均可通过指令或指令串（程序或软件）实现。因此，为提高效率，指令系统应将用户常用的、简单的操作通过指令（硬件）直接实现，而复杂的操作则通过指令串（程序或软件）实现。</p><p>2）规整性 </p><p>规整性指的是指令系统的正交性、均匀性、对称性。</p><ul><li>正交性表示指令格式中各个互不相关的字段之间，在编码时应相互独立、互不相关，以方便译码和执行，如指令字可分成操作码和地址码两部分。</li><li>均匀性表示指令实现的操作与处理的数据类型无关，以方便数据类型扩展，如同一指令可支持对字节、字、双字整数的运算等。</li><li>对称性表示对不同指令中相同或相似的操作数具有相同的规定，以减少配件实现的复杂性，如对不同指令中的存储单元地址所占位数、寄存器号所占位数应具有相同的规定。</li></ul><p>3）兼容性</p><p>兼容性指不同机种之间具有相同的基本结构和共同的基本指令集，目的是给软件资源的重复利用带来方便。指令系统的兼容性主要指向前兼容。对系列机而言，因为不同机种具有相同的基本指令集，因而系列机中各机种上的指令系统是兼容的，所有已编的软件基本可以通用。</p><p>4）可扩充性</p><p>可扩充性指指令系统中要保留一定的指令字空间，以便在需要时进行指令系统的功能扩充。因为计算机应用和硬件是不断发展的，原来不常用的、复杂的操作可能会变成常用的、基本的操作，需要添加到指令系统中。</p></li><li><p>指令分类</p><p>按照功能类型的不同，指令可分为数据传送类指令、算术运算类指令、逻辑运算类指令、程序控制类指令、输入输出类指令、字符串类指令、系统控制类指令和其他指令。</p><p>1）数据传送类指令</p><p>这类指令主要完成将数据从一个地方传送到另一个地方的功能，一般可按字节、字传送，特殊情况下可以位为单位进行传送。</p><p>2）算术运算类相令</p><p>这类指令主要实现对数据进行算术运算功能，主要包括加、减、乘、除指令，求反、求补指令，算术移位、算术比较指令等。</p><p>3）逻辑运算类相令</p><p>这类指令主要包括逻辑与、逻辑或、逻辑非、逻辑异或、逻辑移位等。逻辑非指令和算术运算中的求反指令含义相同。</p><p>4）程序控制类指令</p><p>这类指令主要实现改变指令执行方向的功能。主要包括无条件转移、条件转移、转子、返主、循环指令等。</p><p>计算机执行程序时，通常按 CPU 中程序计数器 PC（Program Counter） 的内容取指令并执行。<strong>PC 中的内容为下一条（后续执行）指令的地址</strong>，在指令取指完成时，CPU 将自动修改 PC的内容，以保持其总是后续执行的指令地址。</p><p>若当前指令为顺序执行指令，PC 的内容总是原 PC 的内容加上当前指令的长度（字节数）。若当前指令为非顺序执行指令（如程序控制类指令），那么后续执行指令的地址（即 PC 的内容）在转移发生时，必须从当前指令的地址码字段中取得，而不是当前指令取指完成时的下一条指令地址。程序控制类指令的地址码给出的地址格式可以是直接给定的地址，也可以是相对于当前指令位量的偏移地址，或其他方式给出的地址。</p><p>5）输入输出类指令</p><p>这类指令主要实现 CPU 与外部设备间交换数据、传送控制命令及取得设备状态等功能。各种计算机的输入输出类指令差别较大，外部设备独立编址的计算机，其指令系统必须设置这类指令。</p><p>这类指令只有输入和输出两种指令。</p><p>6）字符串类指令</p><p>这类指令主要完成对字符串操作的功能，是一组非数值运算的指令。主要包含字符串转换（把一种编码格式的字符串转换成另一种编码格式的字符串）、字符串传送、字符串比较、字符串查找（查找字符串中某一子串）、字符串抽取（提取某一子串）、字符串替换（把某一子字符串用另一字符串替换）等指令。</p><p>7）系统控制类指令</p><p>这类指令主要完成改变系统的工作状态、实现操作系统所需要的特殊功能。大多数计算机将这类指令划为特权指令，只能被操作系统等系统软件使用，而用户一般不可以使用。主要包括停机、开中断、关中断、系统管理、存储管理指令等。</p><p>8）其他指令</p><p>除上述类型指令外，系统尚有一些必须具有特定功能的专用指令。这类指令主要包含状态寄存器置位、暂停、测试、空操作、中断返回等指令。</p></li><li><p>指令格式</p><ol><li><p>基本格式</p><p>指令格式是指令字用二进制代码表示的结构形式，通常由操作码字段和地址码字段组成，操作码字段表征指令的操作特性与功能，如进行加法、取数等等；地址码字段通常指定参与操作的操作数的地址，特殊情况下也可能直接给出操作数本身。指令的基本格式如下：</p><p><img src="/images/image-20210809194403535.png" alt="image-20210809194403535"></p></li><li><p>指令长度</p><p>指令的长度是指一条指令中所包含的二进制代码的位数，它取决于操作码字段的长度、操作数地址的个数及长度。指令长度应：①尽可能短；②等于字节的整数倍。</p><p>指令长度可以等于机器字长，也可以大于或小于机器字长。</p><ul><li>指令长度等于机器字长的指令，称为单字长指令；</li><li>指令长度等于半个机器字长的指令，称为半字长指令；</li><li>指令长度等于两个机器字长的指令，称为双字长指令。</li></ul><p>使用多字长指令的目的，在于提供足够的地址位来解决访问内存任何单元的寻址问题，但是使用多字长指令的主要缺点是必须多次访问内存以取出一整条指令，这降低了 CPU 的运算速度，同时又占用了更多的存储空间。</p><p>在一个指令系统中，若所有指令的长度都是相等的，称为定长指令字结构，这种指令结构简单；若各种指令的长度随指令功能而异，称为变长指令字结构，这种指令结构灵活，能充分利用指令长度，但指令的控制较为复杂。</p></li><li><p>操作码</p><p>指令系统中的每一条指令都有一个唯一确定的操作码，指令不同，其操作码的编码也不同。为了能表示整个指令系统中的全部指令，指令的操作码字段应当具有足够的位数。一般来说，一个包含 n 位的操作码最多能表示 2<sup>n</sup>条指令。</p><p>指令操作码通常有两种编码格式：一种是固定格式，即操作码的长度固定，且集中放在指令字的一个字段中，这种格式对简化硬件设计非常有利，在字长较长的大中型计算机中广泛采用；另一种是可变格式，即操作码的长度可变，且分散地放在指令字的不同字段中，在字长较短的微型和小型计算机中广泛采用。</p><p>操作码长度不同会增加指令译码和分析的难度，使控制器的设计复杂。通常采用扩展操作码技术，使操作码的长度随地址数的减少而增加，既充分利用指令字的各字段，又在不增加指令长度的情况下扩展操作码的长度。</p></li><li><p>地址码</p><p>地址码用来指出该指令的<strong>源操作数的地址</strong>、<strong>结果的地址</strong>以及<strong>下一条指令的地址</strong>。这里的“地址”可以是主存的地址，也可以是寄存器的地址，甚至可以是 I/O 设备的地址。</p><p>下面以主存地址为例，讨论双操作数指令的地址码结构。一条双操作数指令的除操作码之外，还应包含以下信息：第一操作数地址，用 A1 表示；第二操作数地址，用 A2 表示；操作结果存放地址，用 A3 表示；下条将要执行指令的地址，用 A4 表示。这些信息可以在指令中明显的给出，称为显地址；也可以依照某种事先的约定，用隐含的方式给出，称为隐地址。</p><p>1）四地址指令</p><p><img src="/images/image-20210809195145427.png" alt="image-20210809195145427"></p><p>（A1）OP（A2）→A3, A4＝下条将要执行指令的地址</p><p>执行一条四地址指令需 4 次访问主存。</p><p>四地址指令可直接寻址的地址范围与地址字段的位数有关。如果指令字长为 32</p><p>位，操作码占 8 位，4 个地址字段各占 6 位，则指令操作数的直接寻址范围为 2<sup>6</sup>= 64。  </p><ol start="2"><li>三地址指令</li></ol><p><img src="/images/image-20210809195359829.png" alt="image-20210809195359829"></p><p>（A1）OP（A2）→A3, （PC）＋ 1＝ 下条将要执行指令的地址</p><p>执行一条三地址指令也需 4 次访问主存。</p><p>同理，若指令字长不变，设 OP 仍为 8 位，则 3 个地址字段各占 8 位，故三地址</p><p>指令操作数的直接寻址范围可达 2<sup>8</sup>=256。</p><ol start="3"><li>二地址指令 </li></ol><p><img src="/images/image-20210809195525681.png" alt="image-20210809195525681"></p><p>（A1）OP（A2）→A1, （PC）＋ 1＝下条将执行指令的地址</p><p>A1 中原存内容在指令执行后被破坏。</p><p>执行一条二地址指令需 4 次访问主存。若使其完成（A1）OP（A2）→ACC，中间结果暂存于累加器 ACC 中，则只需访存 3 次。</p><p>在不改变指令字长和操作码的位数前提下，二地址指令操作数的直接寻址范围为2<sup>12</sup> =4 K。 </p><ol start="4"><li>一地址指令</li></ol><p><img src="/images/image-20210809195747057.png" alt="image-20210809195747057"></p><p>（ACC）OP（A1）→ ACC, （PC）＋ 1＝ 下条将要执行指令的地址</p><p>执行一条一地址指令需 2 次访问主存。</p><p>一地址指令短，又由于一个操作数已在 CPU 内，所以执行速度较快。</p><p>在指令字长仍为 32 位、操作码位数为 8 位的情况下，一地址指令操作数的直接寻址范围达 2<sup>24</sup>= 16 M。</p><ol start="5"><li>零地址指令</li></ol><p><img src="/images/image-20210809195908855.png" alt="image-20210809195908855"></p><p>零地址指令的指令字中只有操作码，没有地址码。例如空操作、停机等不需要操作数的指令，或者操作数隐含在堆栈中，其地址为堆栈的栈顶或次栈顶。</p><p>指令中地址个数的选取要考虑诸多的因素。从缩短程序长度，用户使用方便等方面来看，选用三地址指令格式较好；从减少访存次数，简化硬件设计等方面来看，一地址指令格式较好。对于同一个问题，用三地址指令编写的程序最短，但指令长度最长，而用二、一地址指令来编写程序，程序的长度逐个递增，但指令的长度逐个递减。</p><p>示例：计算 x=(a×b+c-d) ÷(e+f)</p><p>①三地址指令</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">MUL A，B，<span class="hljs-keyword">X</span><br>ADD <span class="hljs-keyword">X</span>，C，<span class="hljs-keyword">X</span><br>SUB <span class="hljs-keyword">X</span>，D，<span class="hljs-keyword">X</span><br>ADD E，F，<span class="hljs-keyword">Y</span><br><span class="hljs-keyword">DIV</span> <span class="hljs-keyword">X</span>，<span class="hljs-keyword">Y</span>，<span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure><p>需要 5 条指令，每条指令 4 次访存，执行此程序共访存 20 次。</p><p>②二地址指令</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tp">MOV <span class="hljs-keyword">X</span>，A<br>MUL <span class="hljs-keyword">X</span>，B<br>ADD <span class="hljs-keyword">X</span>，C<br>SUB <span class="hljs-keyword">X</span>，D<br>MOV <span class="hljs-keyword">Y</span>，E<br>ADD <span class="hljs-keyword">Y</span>，F<br><span class="hljs-keyword">DIV</span> <span class="hljs-keyword">X</span>，<span class="hljs-keyword">Y</span><br></code></pre></td></tr></table></figure><p>需要 7 条指令，其中 MOV 指令 3 次访存，算逻指令 4 次访存，执行此程序共访存 2×3+5×4=26 次。</p><p>③一地址指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">LOAD  E<br><span class="hljs-keyword">ADD </span>  F<br>STORE X<br>LOAD  A<br><span class="hljs-keyword">MUL </span>  <span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">ADD </span>  C<br><span class="hljs-keyword">SUB </span>  D<br><span class="hljs-keyword">DIV </span>  X<br>STORE X<br></code></pre></td></tr></table></figure><p>需要 9 条指令，每条指令 2 次访存，执行此程序共访存 9×2=18 次。</p></li></ol></li></ol><h3 id="3-1-2-寻址方式"><a href="#3-1-2-寻址方式" class="headerlink" title="3.1.2 寻址方式"></a>3.1.2 寻址方式</h3><p>存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为<strong>数据寻址</strong>和<strong>指令寻址</strong>。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。</p><ol><li><p>指令寻址</p><p>指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器 PC 加 1，自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。</p><p>跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。</p></li><li><p>数据寻址</p><p>数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作 A。操作数的真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。</p><p><img src="/images/image-20210809200634180.png" alt="image-20210809200634180"></p><p>指令中的形式地址 A→(寻址方式)→有效地址 EA</p><ol><li><p>立即寻址</p><p>在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度。立即寻址的特点是操作数本身设在指令字内，即形式地址 A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。</p><p><img src="/images/image-20210809200901874.png" alt="image-20210809200901874"></p></li><li><p>直接寻址</p><p>指令中地址码字段给出的地址 A 就是操作数的有效地址：EA=A。直接寻址的缺点在于 A 的位数限制了操作数的寻址范围，且必须修改 A 的值，才能修改操作数的地址。</p><p><img src="/images/image-20210809201025610.png" alt="image-20210809201025610"></p></li><li><p>间接寻址</p><p>指令中给出的地址 A 不是操作数的地址，而是存放操作数地址的地址：EA=（A）。</p><p>间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。 </p><p><img src="/images/image-20210809201251742.png" alt="image-20210809201251742"></p><p>除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。</p></li><li><p>寄存器寻址</p><p>指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。</p><p><img src="/images/image-20210809201521215.png" alt="image-20210809201521215"></p></li><li><p>寄存器间接寻址</p><p>指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中。</p><p><img src="/images/image-20210809201625926.png" alt="image-20210809201625926"></p></li><li><p>变址寻址</p><p>把指令给出的形式地址 A 与变址寄存器 Rx 的内容相加，形成操作数有效地址：EA ＝ A ＋（Rx），Rx 的内容为变址值。</p><p><img src="/images/image-20210809201741051.png" alt="image-20210809201741051"></p><p>变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了。</p><p>如要把一组连续存放在主存单元中的数据（首地址是 A）依次传送到另一存储区（首地址为 B）中去，则只需在指令中指明两个存储区的首地址 A 和 B（形式地址），用同一变址寄存器提供修改量 K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。</p></li><li><p>基址寻址</p><p>将基址寄存器 Rb 的内容与形式地址 A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值。</p><p><img src="/images/image-20210809201924613.png" alt="image-20210809201924613"></p><p>基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。</p><p>但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。</p></li><li><p>相对寻址</p><p>相对寻址是基址寻址的一种变通，由程序计数器 PC 提供基准地址，即EA＝（PC）＋ A， A 是操作数和现行指令之间的相对位置。</p><p>相对寻址方式的特点是：操作数的地址不是固定的，它随着 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值 A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量 A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。</p><p><img src="/images/image-20210809202251330.png" alt="image-20210809202251330"></p></li><li><p>隐含寻址</p><p>隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器 ACC 中，故累加器 ACC 对一地址指令格式来说是隐含地址。</p><p><img src="/images/image-20210809202346390.png" alt="image-20210809202346390"></p></li><li><p>堆栈寻址</p><p>在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。</p></li></ol></li></ol><h3 id="3-1-3-RISC-技术"><a href="#3-1-3-RISC-技术" class="headerlink" title="3.1.3 RISC 技术"></a>3.1.3 RISC 技术</h3><p>随着超大规模集成电路的飞速发展，计算机硬件结构越来越复杂，大多数计算机的指令系统多达几百条，这些计算机被称为复杂指令系统计算机，简称 CISC(Complex Instruction Set Computer)。CISC的指令系统复杂庞大，指令数目多；CPU 中设有专用寄存器；指令字长不固定，指令格式多，寻址方式多；可访存指令不受限制；各种指令的执行时间相差大；采用微程序控制器；难以用优化编译生成高效的目标代码。</p><p>大量测试表明，最常使用的是一些比较简单的指令，这类指令仅占指令总数的20％，但在各种程序中出现的频率却占 80%，其余大多数指令是功能复杂的指令，这类指令占指令总数的 80%，但其使用频率很低，仅占 20%。因此，人们把这种情况称为“20%-80%律”。</p><p>从“20%-80%律”出发，人们开始了对指令系统合理性的研究，提出了精简指令系统的想法，出现了精简指令系统计算机，简称 RISC(Reduced Instruction Set Computer)。RISC 的主要特点是：</p><ol><li>选取使用频度较高的简单指令，以及很有用但不复杂的指令；</li><li>指令长度固定，指令格式种类少，寻址方式种类少；</li><li>只有取数/存数（LOAD/STORE）指令访问存储器，其余指令的操作都在寄存器内完成；</li><li>CPU 中有多个通用寄存器。</li><li>采用流水线技术，大部分指令在一个时钟周期内完成；</li><li>控制器采用组合逻辑控制为主；</li><li>采用优化编译技术。</li></ol><h2 id="3-2-总线系统"><a href="#3-2-总线系统" class="headerlink" title="3.2 总线系统"></a>3.2 总线系统</h2><h3 id="3-2-1-总线系统"><a href="#3-2-1-总线系统" class="headerlink" title="3.2.1 总线系统"></a>3.2.1 总线系统</h3><p>计算机系统各部件之同的互连方式有两种，一种是各部件之同使用单独的连线，称为分散连接；另一种是将各部件连到一组公共信息传输线上，称为总线连接。</p><p>总线是连接多个部件的信息传输线，是各部件共享的传输介质。从不同角度，总线有不同分类方法：按数据传送方式，可分为<strong>串行传输总线</strong>和<strong>并行传输总线</strong>；按连接部件不同，可分为<strong>片内总线</strong>、<strong>系统总线</strong>和<strong>通信总线</strong>。</p><ul><li>片内总线是指芯片内部的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算逻单元 ALU 之间都由片内总线连接。</li><li>通信总线用于计算机系统之间，或者计算机系统与其他系统如控制仪表、移动通信等之间的通信。</li><li>系统总线是微机系统中各部件之间传输信息的公共通路。信息可以从多个信息源中的任一信息源通过总线传送到多个信息接收部件中的任一部件。总线首先包括一组物理导线，这是信息传输的物理媒质。系统总线按照传输信息的不同，又可分为三类：地址总线、数据总线和控制总线。</li></ul><ol><li><p>地址总线</p><p>地址总线用来传送 CPU 发出的地址信息，是单向总线。</p></li><li><p>数据总线</p><p>数据总线用来传送数据信息，是双向总线。</p></li><li><p>控制总线</p><p>控制总线用来传送控制信号、时序信号和状态信息等，是双向总线。</p></li></ol><h3 id="3-2-2-总线的特性"><a href="#3-2-2-总线的特性" class="headerlink" title="3.2.2 总线的特性"></a>3.2.2 总线的特性</h3><ul><li>物理特性：总线的物理连接方式</li><li>功能特性：总线每一根线的功能</li><li>电气特性：定义每一根线上信号的传递方向及有效电平范围</li><li>时间特性：定义每一根线在什么时间有效</li></ul><h3 id="3-2-3-总线性能指标"><a href="#3-2-3-总线性能指标" class="headerlink" title="3.2.3 总线性能指标"></a>3.2.3 总线性能指标</h3><p>总线性能指标主要包括以下六个方面：</p><ol><li><p>总线频率 （我理解频率就是每秒干那一件事干了多少次）</p><p>总线的工作频率以 MHz 表示。它是总线工作进度的一个重要参数，工作频率越高，速度越快。</p></li><li><p>总线宽度</p><p>总线宽度是指数据总线的位数，用 bit（位）来表示，如 8 位、16 位、32 位、64位总线宽度。</p></li><li><p>总线的数据传输率</p><p>总线的数据传输率是指在一定的时间内总线上可传送的数据总量，用每秒最大传输数据字节量来表示。总线的数据传输率的计算公式是：</p><p><strong>总线的数据传输率＝（总线宽度/8 位）× 总线频率</strong></p><p>其单位是 MB/s，总线频率以 MHz 为单位。如 PCI 总线的总线频率为 33.3MHz，总线宽度为 32 位的情况下，其数据传输率为 133MB/s。</p></li><li><p>时钟同步/异步</p><p>总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作的总线称为异步总线。</p></li><li><p>总线复用</p><p>通常情况下，地址线和数据线在物理上是分开的，但为了提高总线的利用率和优化设计，在有些总线中将地址线和数据线共用同一组物理线路，然后分时传送地址或数据信号，这就是总线复用。</p></li><li><p>总线负载能力</p><p>不同的电路对总线的负载是不同的，即使是同一块电路板，在不同的工作频率下，总线的负载也不一样，所以对总线负载能力的指标并不太严格，一般情况下用可连接的扩充电路板的数目来反映总线的负载能力。</p></li></ol><p>在这些性能指标中，总线频率、总线宽度和总线的数据传输率是最重要的 3 个指标。</p><h3 id="3-2-4-总线结构"><a href="#3-2-4-总线结构" class="headerlink" title="3.2.4 总线结构"></a>3.2.4 总线结构</h3><p>按照总线的排列布置及计算机内各部件连接方式的不同，可以将单机总线结构分为三种：单总线结构、双总线结构和三总线结构。</p><ol><li><p>单总线结构</p><p>用一条系统总线连接计算机系统的各个功能部件，各功能部件间所有的信息传输都靠这条总线来实现。单总线结构多为小型机和微型机采用。</p><p><img src="/images/image-20210809205222105.png" alt="image-20210809205222105"></p></li><li><p>双总线结构</p><p>系统内增加了存储总线，存储总线专门负责 CPU 和主存之间的信息高速传输。双总线结构以增加硬件为代价，提高了 CPU 的效率，同时又保持了单总线结构系统简单、易于扩充的优点。</p><p><img src="/images/image-20210809205428249.png" alt="image-20210809205428249"></p></li><li><p>三总线结构</p><p>三总线结构在双总线结构的基础上增加了 I/O 总线，系统内有 3 条各自独立的总线：系统总线是 CPU、主存和通道之间进行信息传输的公共通路；I/O 总线是多个外部设备与通道之间进行数据传送的公共通路；存储总线负责 CPU 和主存之间的信息传输。</p><p><img src="/images/image-20210809205608729.png" alt="image-20210809205608729"></p><p>由于通道分担了一部分 CPU 的功能，可以实现对外设的统一管理及外设与主存之间的信息传输，所以三总线结构系统的效率有很大提高。</p></li></ol><h3 id="3-2-5-总线标准"><a href="#3-2-5-总线标准" class="headerlink" title="3.2.5 总线标准"></a>3.2.5 总线标准</h3><p>总线标准是系统与各模块、模块与模块之间的一个互连标准界面，按总线标准设计的接口可视为通用接口，这为计算机接口的软硬件设计提供了方便。主要的总线标准有以下几种：</p><ol><li><p>PCI</p><p>PCI（Peripheral Component Interconnect，外围部件互连）总线是现代计算机中最常用的总线之一，PCI 总线是并行的，有 32 位或 64 位，支持即插即用，支持 5V 和3.3V 两种电压标准，具有良好的兼容性和可扩充性。</p></li><li><p>SCSI</p><p>SCSI（Small Computer System Interface，小型计算机系统接口）是一种通用的并行接口标准，用于在计算机和外部设备之间进行物理连接和传输数据。SCSI 通常用在硬盘和磁带上，也可以用于其他设备如扫描仪、CD 和 DVD 驱动器等。</p></li><li><p>RS-232C</p><p>RS-232C（ RS 即 Recommended Standard，232 为标识号，C 表示修改次数）是一种串行通信总线标准，它是应用于串行二进制交换的数据终端设备和数据通信设备之间的标准接口。</p></li><li><p>FireWire</p><p>FireWire 串行总线标准由苹果公司开发，被 IEEE 组织采用并定名为 IEEE1394 标准。FireWire 可实现即插即用，能连接多个不同的设备。</p></li><li><p>USB</p><p>USB(Universal Serial Bus，通用串行总线)是一种计算机串行接口总线标准，它可实现外设的简单快速连接，几乎所有的外设装置包括显示器、键盘、鼠标、打印机、数码相机、U 盘等可直接插入标准 USB 插口。</p><p>USB2.0 版的数据传输速度最高为 480Mbps，接口供电能力为 0.5A。</p><p>USB3.0 版的理论最高数据传输速度为 5.0Gbps，接口供电能力为 1A。USB3.0 引入了全双工数据传输，5 根线路中 2 根用来发送数据，2 根用来接收数据，1 根是地线，即USB 3.0可以同步全速地进行读写操作。之前的USB版本并不支持全双工数据传输。</p></li></ol><h3 id="3-2-6-总线控制"><a href="#3-2-6-总线控制" class="headerlink" title="3.2.6 总线控制"></a>3.2.6 总线控制</h3><ol><li><p>总线仲裁</p><p>系统中多个设备或模块可能同时申请对总线的使用权，为避免产生总线冲突，在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。</p><p>按照总线仲裁电路的位置不同，总线仲裁方式可分为：<strong>集中式仲裁</strong>和<strong>分布式仲裁</strong>。</p><p>集中式总线仲裁的控制逻辑基本集中在一处，需要中央仲裁器，分为：链式查询方式、计数器定时查询方式、独立请求方式。</p><p>分布式仲裁不需要中央仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当它们有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤消它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。显然，分布式仲裁是以优先级仲裁策略为基础。</p><p>以下对集中式总线仲裁的三种方式作简要介绍：</p><ul><li><p><strong>链式查询</strong></p><p>链式查询时，总线授权信号 BG 串行地从一个 I/O 接口传送到下一个 I/O 接口。假如 BG 到达的接口无总线请求，则继续往下查询；假如 BG 到达的接口有总线请求，BG 信号便不再往下查询，该 I/O 接口获得了总线控制权。离中央仲裁器最近的设备具有最高优先级，通过接口的优先级排队电路来实现。</p><p><img src="/images/image-20210809210605892.png" alt="image-20210809210605892"></p><p>链式查询的优点在于只用很少几根线就能按一定优先次序实现总线仲裁，很容易扩充设备。其主要缺点是对询问链的电路故障很敏感，如果第 i 个设备的接口中有关链的电路有故障，那么第 i 个以后的设备都不能进行工作。查询链的优先级是固定的，如果优先级高的设备出现频繁的请求时，优先级较低的设备可能长期不能使用总线。</p></li><li><p><strong>计数器定时查询</strong></p><p>总线上的任一设备要求使用总线时，通过总线请求线 BR 发出总线请求。中央仲裁器接到请求信号以后，在总线状态线 BS 为“0”的情况下让计数器开始计数，计数值通过一组地址线发向各设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址相一致时，该设备置“1”BS 线，获得了总线使用权，此时中止计数查询。</p><p><img src="/images/image-20210809210720371.png" alt="image-20210809210720371"></p></li><li><p><strong>独立请求</strong></p><p>独立请求的每一个共享总线的设备均有一对总线请求线 BRi 和总线授权线 BGi。当设备要求使用总线时，便发出该设备的请求信号。中央仲裁器中的排队电路决定首先响应哪个设备的请求，给设备以授权信号 BGi。</p><p>这种方式的优点是响应时间快，确定优先响应的设备所花费的时间少，用不着一个设备接一个设备地查询。其次，对优先次序的控制相当灵活，可以预先固定也可以通过程序来改变优先次序；还可以用屏蔽某个请求的办法，不响应来自无效设备的请求。</p><p><img src="/images/image-20210809211223016.png" alt="image-20210809211223016"></p></li></ul></li><li><p>总线通信控制</p><p>总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合。通常用四种方式：同步通信、异步通信、半同步通信和分离式通信。</p><ol><li><p>同步通信</p><p>通信双方由统一时标控制数据传送称为同步通信。时标通常由 CPU 的总线控制部件发出，送到总线上的所有部件；也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步。</p><p>这种通信的优点是规定明确、统一，模块间的配合简单一致，缺点是主、从模块时间配合属于强制性同步，必须在限定时间内完成规定的要求。</p><p>同步通信一般用于总线长度较短、各部件存取时间比较一致的场合。</p></li><li><p>异步通信</p><p>异步通信没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式，即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。</p><p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型。</p><ul><li><p>不互锁方式</p><p>主模块发出请求信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块已收到请求信号后，便撤销其请求信号；从模块接到请求信号后，在条件允许时发出回答信号，并且经过一段时间确认主模块已收到回答信号后，自动撤销回答信号。通信双方并无互锁关系。</p></li><li><p>半互锁方式</p><p>主模块发出请求信号，必须待接到从模块的回答信号后再撤销其请求信号，有互锁关系；而从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一段时间后自动撤销其回答信号，无互锁关系。由于一方存在互锁关系，一方不存在互锁关系，故称半互锁方式。</p></li><li><p>全互锁方式</p><p>主模块发出请求信号，必须待从模块回答后再撤销其请求信号；从模块发出回答信号，必须待获知主模块请求信号已撤销后，再撤销其回答信号。双方存在互锁关系，故称为全互锁方式。</p><p>异步串行通信的数据传送速率用波特率来衡量。波特率是指单位时间内传送二进制数据的位数，单位用 bps(位/秒)表示，记作波特。</p></li></ul></li><li><p>半同步通信</p><p>半同步通信既保留了同步通信的基本特点，如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别；同时又像异步通信那样，允许不同速度的模块和谐地工作。</p></li><li><p>分离式通信</p><p>为提高系统性能，人们提出了“分离式”的通信方式，其基本思想是将一个传输周期（或总线周期）分解为两个子周期。在第 1 个子周期中，主模块 A 在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号发到系统总线上，经总线传输后，由有关的从模块 B 接收下来。主模块 A 向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使用权，以便其他模块使用。在第 2 个子周期中，当 B 模块收到 A 模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将 A 模块所需的数据准备好，便由 B 模块申请总线使用权，一旦获准，B 模块便将 A 模块的编号、B 模块的地址、A 模块所需的数据等一系列信息送到总线上，供 A 模块接收。很明显，上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。</p></li></ol></li></ol><h3 id="3-3-7-总线的信息传送模式"><a href="#3-3-7-总线的信息传送模式" class="headerlink" title="3.3.7 总线的信息传送模式"></a>3.3.7 总线的信息传送模式</h3><ol><li><p>读、写操作</p><p>读操作是从方到主方的数据传送；写操作是主方到从方的数据传送。</p></li><li><p>块传送操作</p><p>对固定块长度的数据连续读或写。</p></li><li><p>写后读、读修改写操作</p><p>写后读用于校验；读修改写用于多道程序系统中对共享存储资源的保护。</p></li><li><p>广播、广集操作</p><p>广播操作允许一个主方对多个从方进行写操作；和广播操作相反，广集将选定的多个从方数据在总线上完成 AND 或 OR 操作，用以检测多个中断源。</p></li></ol><h1 id="4-存储系统"><a href="#4-存储系统" class="headerlink" title="4. 存储系统"></a>4. 存储系统</h1><h2 id="4-1-存储器概述"><a href="#4-1-存储器概述" class="headerlink" title="4.1 存储器概述"></a>4.1 存储器概述</h2><p>存储器是计算机系统中的记忆设备，用来存放程序和数据。存储器中含有大量的存储单元。存储单元包含若干个存储元件（存储元），每个存储元能寄存一个“0”或“1”二进制数，故<strong>存储单元可存储一串二进制数，称为一个字</strong>，其位数称为存储字长，可为 8 位、16 位、32 位、64 位等，存储元件是存储器中最小的存储单元。</p><p>存放一个机器字的存储单元，通常称为字存储单元，相应的单元地址叫字地址。存放一个字节的单元，称为字节存储单元，相应的地址称为字节地址。若计算机中可编址的最小单位是字存储单元，则该计算机称为按字编址的计算机。若计算机中可编址的最小单位是字节，则该计算机称为按字节编址的计算机。通常计算机系统既可以按字寻址，也可按字节寻址。</p><h3 id="4-1-1-数据的存储"><a href="#4-1-1-数据的存储" class="headerlink" title="4.1.1 数据的存储"></a>4.1.1 数据的存储</h3><ol><li><p>存储方式</p><p>通常计算机中的数据可以存储在寄存器或存储器中。</p><p>对寄存器而言，可以存放数据的长度是固定的，一般与机器字长一致。</p><p>对存储器而言，一次访问存储器单元的取得位数一般与计算机机器字长是相同的，目的是使 CPU 能够一次访问到数据的全部。</p><p>现代计算机的存储器大多以字节为单位编址，即每个存储单元地址对应一个字节的数据空间。存储器硬件特性决定了一次访问存储器所能取得的数据肯定是在连续的地址中，因此当数据长度大于一个字节时，数据就必须存放在从指定地址开始的、相邻的多个字节的存储器空间中。</p><p>按照数据的高字节和低字节在存储器中的存储次序，可分为大端（Big-endian）和小端（Little-endian）两种数据存储方式。将最低字节存储在指定存储器空间中最小地址位置的存储方法称为小端方式；将最低字节存储在指定存储器空间中最大地址位置的存储方法称为大端方式。</p><p>假设一个数据由 4 个字节组成，需要存储在从 N 开始的存储器地址中，用 B3、 B2、B1、B0 分别表示操作数的 4 个字节，其中 B3为数据的最高字节，B0 为数据的最低字节，该操作数的大端和小端数据存储方式结果如图所示。</p><p>注意，大端、小端存储方式是指数据的字节间的存储次序，而字节内的数据无大、小端之分，永远是 bit7 为字节内数据的最高位，bit0 为字节内数据的最低位。</p><p><img src="/images/image-20210809213532023.png" alt="image-20210809213532023"></p></li><li><p>数据对齐方式</p><p>对机器指令而言，操作数长度有字节、半字、字、双字等数据长度，要求存储器必须一次能够存取这些长度的操作数。因此，数据在存储器中应存储在存储空间阵列的同一行。假如操作数不能够存储在同一行，则机器指令取操作数至少需要两个访存周期，严重影响机器指令的执行速度。</p></li></ol><h3 id="4-1-2-存储器的分类"><a href="#4-1-2-存储器的分类" class="headerlink" title="4.1.2 存储器的分类"></a>4.1.2 存储器的分类</h3><p>根据存储元件的性能及使用方法，存储器可有不同的分类。</p><ol><li><p>按存储介质分类</p><p>目前使用的存储介质主要是半导体器件、磁性材料和光盘等。用半导体器件组成的存储器称为半导体存储器；用磁性材料做成的存储器有磁表面存储器和磁芯存储器，常见的磁表面存储器有磁盘和磁带；光盘存储器是应用激光在磁光材料上进行读/写的存储器。</p></li><li><p>按存取方式分类</p><p>若存储器中任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关，这种存储器称为随机存储器。半导体存储器和磁芯存储器都是随机存储器。</p><p>如果存储器只能接某种顺序来存取，即存取时间和存储单元的物理位置有关，这种存储器称为顺序存储器，如磁带存储器就是顺序存储器。</p><p>磁盘存储器是半顺序存储器，在对磁盘读/写时，首先直接指出该存储器中的某个小区域（磁道），然后再顺序寻访，直至找到位置。即其前段是直接访同，后段是顺序访问，也称为直接存取存储器。</p></li><li><p>按存储器的读写功能分类</p><p>有些半导体存储器存储的内容是固定不变的，即只能读出而不能写入，因此这种半导体存储器称为只读存储器（ROM）。</p><ul><li>早期采用掩模工艺，把原始信息记录在芯片中，一旦制成后无法更改，这种只读存储器称为掩模型只读存储器（Masked ROM，MROM）。之后又派生出可编程只读存储器（Programmable ROM，PROM）、可擦除可编程只读存储器（Erasable Programmable ROM，EPROM）以及用电可擦除可编程只读存储器（Electrically Erasable Programmable ROM，EEPROM）。PROM 只能写一次，而 EPROM 和 EEPROM 则可多次改写。后来出现的闪速存储器 Flash Memory，它具有 EPROM 和 EEPROM 的特点，但性价比更好、可靠性更高、擦除重写速度比 EEPROM 快得多。</li></ul><p>既能读出又能写入的半导体存储器，称为随机存储器（RAM）。RAM 又分为 SRAM（静态随机存储器）和 DRAM（动态随机存储器）。</p></li><li><p>按信息的可保存性分类</p><p>断电后信息即消失的存储器，称为易失性存储器。断电后仍能保存信息的存储器，称为非易失性存储器，如磁性材料做成的存储器。</p></li><li><p>按在计算机系统中的作用分类</p><p>根据存储器在计算机系统中所起的作用，可分为主存储器、辅助存储器、缓冲存储器等。</p><p><img src="/images/image-20210809214613100.png" alt="image-20210809214613100"></p></li></ol><h3 id="4-1-3-存储器的层次结构"><a href="#4-1-3-存储器的层次结构" class="headerlink" title="4.1.3 存储器的层次结构"></a>4.1.3 存储器的层次结构</h3><ol><li><p>性能指标</p><p>存储器的性能指标主要有三个：速度、容量和位价。一般来说，速度越高，位价就越高；容量越大，速度就越低，价位也越低。人们追求大容量、高速度、低价位的存储器，这就需要存储系统来平衡各种存储器。</p><p><img src="/images/image-20210809214754978.png" alt="image-20210809214754978"></p></li><li><p>层次结构</p><p>存储系统层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上。缓存-主存层次主要解决 CPU 和主存速度不匹配的问题，主存-辅存层次主要解决存储系统的容量问题。现代的计算机系统几乎都具有这两个存储层次，构成了缓存、主存、辅存三级存储系统。</p></li></ol><h2 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h2><h3 id="4-2-1-主存的技术指标"><a href="#4-2-1-主存的技术指标" class="headerlink" title="4.2.1 主存的技术指标"></a>4.2.1 主存的技术指标</h3><p>主存储器的技术性能指标主要是存储容量、存取时间和存取周期。</p><p>在一个存储器中可以容纳的存储单元总数通常称为该存储器的存储容量。存储容量常用 B、KB、MB、GB、TB 等单位表示。存储容量反映了存储空间的大小。</p><p>存取时间又称存储器访问时间，是指从启动一次存储器操作到完成该操作所经历的时间。具体对于读操作而言，从一次读操作命令发出到该操作完成，将数据读入数据缓冲寄存器为止所经历的时间，即为存储器存取时间。</p><p>存取周期也称为存储周期，指连续启动两次独立的存储器操作（如连续两次读操作）所需的最小间隔时间。通常，存取周期略大于存取时间。存取时间和存取周期是主存的速度指标。</p><h3 id="4-2-2-半导体存储芯片的基本结构"><a href="#4-2-2-半导体存储芯片的基本结构" class="headerlink" title="4.2.2 半导体存储芯片的基本结构"></a>4.2.2 半导体存储芯片的基本结构</h3><p>现代计算机的主存都由半导体集成电路构成，而半导体存储芯片采用超大规模集成电路制造工艺，在一个芯片内集成具有记忆功能的存储矩阵、译码驱动电路和读/写电路等。</p><p>译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对被选中单元的读/写操作；读/写电路包括读出放大器和写入电路，用来完成读/写操作；存储芯片通过地址总线、数据总线和控制总线与外部连接。</p><p>主存各存储单元的空间位置是由单元地址号来表示的，地址总线用来指出存储单元地址号，根据该地址可读出或写入一个存储字。</p><p>地址线的位数、数据线的位数均与芯片容量有关。地址线和数据线的位数共同反映存储芯片的容量。如地址线为 10 根，数据线为 4 根，则芯片容量为 2<sup>10</sup>×4＝4K 位；又如地址线为 14 根，数据线为 1 根，则其容量为 2<sup>14</sup>×1＝16K 位。控制线主要有读/写控制线与片选线两种，读/写控制线决定芯片进行读/写操作，片选线用来选择存储芯片。如一个 64K×8 位的存储器可由 32 片 16K×1 位的存储芯片组成，每次读出一个存储字时，只需选中 8 片。</p><h3 id="4-2-3-DRAM的刷新"><a href="#4-2-3-DRAM的刷新" class="headerlink" title="4.2.3 DRAM的刷新"></a>4.2.3 DRAM的刷新</h3><p>动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。</p><p>DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对 DRAM 的全部基本单元电路必作一次刷新，一般取 2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证 DRAM 内的信息不会丢失。通常有三种方式刷新：<strong>集中刷新</strong>、<strong>分散刷新</strong>和<strong>异步刷新</strong>。</p><ol><li><p>集中刷新</p><p>集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于128个读周期。若读/写周期为0.5μs，则对128行集中刷新共需128×0.5＝64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。</p></li><li><p>分散刷新</p><p>分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为0.5μs，则存取周期为 1μs，那么每隔 128μs 就可将 128 行的存储芯片全部刷新一遍，但这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。</p></li><li><p>异步刷新</p><p>前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms 内对 128 行各刷新一遍，即每隔 15.6μs（2000/128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为 2ms，“死时间”缩短为 0.5μs。</p></li></ol><h3 id="4-2-4-存储器与-CPU-的连接"><a href="#4-2-4-存储器与-CPU-的连接" class="headerlink" title="4.2.4 存储器与 CPU 的连接"></a>4.2.4 存储器与 CPU 的连接</h3><ol><li><p>存储容量的扩展</p><p>由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有<strong>位扩展</strong>和<strong>字扩展</strong>。</p><ol><li><p>位扩展</p><p>位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。如用 64K×1 的 SRAM 芯片组成 64K×8 的存储器，需要 8 个芯片。</p><p><img src="/images/image-20210809220941362.png" alt="image-20210809220941362"></p></li><li><p>字扩展</p><p>字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成 64K×8 的存储器，需要 4 个芯片。</p><p><img src="/images/image-20210809221101383.png" alt="image-20210809221101383"></p></li><li><p>字和位同时扩展</p><p>字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用 16K×4 的 SRAM 组成 64K×8 的存储器，需要 8 个芯片</p><p><img src="/images/image-20210809221227138.png" alt="image-20210809221227138"></p></li></ol></li><li><p>存储器与 CPU 的连接</p><p>存储芯片与 CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。</p><ol><li><p>地址线的连接</p><p>存储芯片的容量不同，其地址线数也不同，CPU 的地址线数往往比存储芯片的地址线数多。通常总是将 CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。</p></li><li><p>数据线的连接</p><p>CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等。</p></li><li><p>读/写命令线的连接</p><p>CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。</p></li><li><p>片选线的连接</p><p>片选线的连接是 CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端是否能接收到来自 CPU 的片选有效信号。</p></li><li><p>合理选择存储芯片</p><p>合理选择存储芯片主要是指存储芯片类型（RAM 或 ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。</p></li></ol></li></ol><h2 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h2><h3 id="4-3-1-背景"><a href="#4-3-1-背景" class="headerlink" title="4.3.1 背景"></a>4.3.1 背景</h3><p>在多体并行存储系统中，由于 I/O 设备向主存请求的级别高于 CPU 访存，这就出现了 CPU 等待 I/O 设备访存的现象，降低了 CPU 的工作效率。为了避免 CPU 与 I/O设备争抢访存，在 CPU 和主存之间加一级缓存；另一角度看，Cache 的提出也缓解了主存和 CPU 之间速度不匹配的问题。</p><h3 id="4-3-2-工作原理"><a href="#4-3-2-工作原理" class="headerlink" title="4.3.2 工作原理"></a>4.3.2 工作原理</h3><p>CPU 欲读出主存的某个字时，有两种可能：一种是所需的字已在缓存中，即可直接访问 Cache（CPU 与 Cache 之间通常一次传送一个字），称为 CPU 访问 Cache 命中；另一种是所需的字不在 Cache 中，此时需将该字所在的主存整个字块一次调入 Cache中（Cache 与主存之间是字块传送），称为 CPU 访问 Cache 不命中。</p><p>Cache 的容量与块长是影响 Cache 效率的重要因素，通常用“命中率”来衡量 Cache的效率。命中率是指 CPU 要访问的信息已在 Cache 内的比率。在一个程序执行期间，设 <em>A</em> 为访问 Cache 的总命中次数，<em>B</em> 为访问主存的总次数，则命中率 <em>H</em> 为 </p><p><img src="/images/image-20210809222212904.png" alt="image-20210809222212904"></p><p>上面介绍的是读操作，而写操作则比较复杂，因为对 Cache 块内写入的信息，必须与被映射的主存块内的信息完全一致。当程序运行过程中需对某个单元进行写操作时，会出现如何使 Cache 与主存内容保持一致的问题。目前主要采用以下几种方法：</p><ol><li>写直达法，即写操作时数据既写入 Cache 又写入主存，能随时能保证主存和Cache 的数据始终一致，但增加了访存次数；</li><li>写回法，即写操作时只把数据写入 Cache 而不写入主存，但当 Cache 数据被替换出去时才写回主存，这样就会导致 Cache 中的数据会与主存中的不一致。为了识别Cache 中的数据是否与主存一致，Cache 中的每一块要增设一个标志位，该位有两个状态：“清”（表示未修改过，与主存一致）和“浊”（表示修改过，与主存不一致）。Cache 替换时，“清”的 Cache 块不必写回主存，因为此时主存中相应块的内容与 Cache块一致。在写 Cache 时，要将该标志位设置为“浊”，替换时此 Cache 块要写回主存，同时要使标志位为“清”。</li></ol><h3 id="4-3-3-改进"><a href="#4-3-3-改进" class="headerlink" title="4.3.3 改进"></a>4.3.3 改进</h3><ol><li><p>单一缓存和两级缓存</p><p>单一缓存是指在 CPU 和主存之间只设一个缓存。这个缓存直接与 CPU 制作在同一个芯片内，故又称为片内缓存。如果在主存与片内缓存之间再加一级缓存，称为片外缓存，由静态 RAM 组成。</p><p>由片外缓存和片内缓存组成的 Cache 称为两级缓存，并称片内缓存为第一级，片外缓存为第二级。</p></li><li><p>统一缓存和分立缓存</p><p>统一缓存是指指令和数据都存放在同一缓存内的 Cache；分立缓存是指指令和数据分别存放在两个缓存中，一个称为指令 Cache，一个称为数据 Cache。</p></li></ol><h3 id="4-3-4-地址映射"><a href="#4-3-4-地址映射" class="headerlink" title="4.3.4 地址映射"></a>4.3.4 地址映射</h3><p>由主存地址映射到 Cache 地址称为地址映射。地址映射方式有很多，有<strong>直接映射</strong>、<strong>全相联映射</strong>、<strong>组相联映射</strong>。</p><ol><li><p>直接映射</p><p>直接映射是一种固定的映射关系，每个主存块只与一个缓存块相对应，映射关系公式为：</p><p><img src="/images/image-20210809222730568.png" alt="image-20210809222730568"></p><p>其中，<em>i</em> 为缓存块号，<em>j</em> 为主存块号，<em>C</em> 为缓存块数或缓存地址位数。</p><p>如缓存有 0～3 号四块，主存有 0～15 号十六块，则直接映射方式主存块和缓存块的对应关系</p><p><img src="/images/image-20210809222846762.png" alt="image-20210809222846762"></p><p>这种方式的优点是实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中；缺点是不够灵活，因每个主存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能利用。</p></li><li><p>全相联映射</p><p>全相联映射允许主存中每一字块映射到 Cache 中的任何一块位置上。优点是灵活，命中率也高，缩小了块冲突率；缺点就是所需的逻辑电路较多，成本较高。</p></li><li><p>组相联映射</p><p>组相联映射是对直接映射和全相联映射的一种折中。它把 Cache 分为 Q 组，每组有 R 块，则</p><p>​    i＝j mod Q</p><p>其中，i 为缓存的组号，j 为主存的块号。</p><p>组相联映射本质为分组采用的是直接映射的理念，而在每个分组内采用的是全相联映射的理念。</p></li></ol><h3 id="4-3-5-替换策略"><a href="#4-3-5-替换策略" class="headerlink" title="4.3.5 替换策略"></a>4.3.5 替换策略</h3><p>当新的主存块需要调入 Cache 并且它的可用空间位置又被占满时，需要替换掉Cache 的数据，这就产生了替换策略问题。常用的替换算法有先进先出（First In First Out，FIFO）算法，近期最少使用（Least Recently Used，LRU）算法，随机法。 </p><h1 id="5-中央处理器"><a href="#5-中央处理器" class="headerlink" title="5. 中央处理器"></a>5. 中央处理器</h1><h2 id="5-1-CPU-的组成和功能"><a href="#5-1-CPU-的组成和功能" class="headerlink" title="5.1 CPU 的组成和功能"></a>5.1 CPU 的组成和功能</h2><h3 id="5-1-1-CPU-的组成"><a href="#5-1-1-CPU-的组成" class="headerlink" title="5.1.1 CPU 的组成"></a>5.1.1 CPU 的组成</h3><p>计算机的工作过程就是程序的运行过程，程序一旦装入内存，就可以由计算机来自动完成取出指令和执行指令。专门用来完成此项工作的计算机部件称为中央处理器，简称 CPU（Central Processing Unit）。CPU 是整个计算机的核心，主要包括运算器和控制器。</p><p>运算器由算术逻辑单元（ALU）、累加寄存器、数据缓冲寄存器和状态标志寄存器组成，它是数据加工处理部件。相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。运算器有两个主要功能：</p><ol><li>执行所有的算术运算</li><li>执行所有的逻辑运算，并进行逻辑测试，如两个值的比较</li></ol><p>通常，一个算术操作产生一个运算结果，而一个逻辑操作则产生一个判决。</p><p>控制器是计算机系统的指挥中心，由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成。控制器的主要功能有：</p><ol><li>从内存中取出指令，并指出下一条指令在内存中的位置</li><li>对指令进行译码或测试，并产生相应的操作控制信号，以启动规定的动作</li><li>指挥并控制 CPU、内存和输入/输出设备之间数据流动的方向</li></ol><h3 id="5-1-2-CPU-的功能"><a href="#5-1-2-CPU-的功能" class="headerlink" title="5.1.2 CPU 的功能"></a>5.1.2 CPU 的功能</h3><p>CPU 的主要功能有：</p><ol><li><p>指令控制</p><p>程序的顺序控制，称为指令控制。由于程序是一个指令序列，这些指令的相互顺序不能任意颠倒，必须严格按程序规定的顺序进行，因此，保证机器按顺序执行程序是 CPU 的首要任务。</p></li><li><p>操作控制</p><p>一条指令的功能往往是由若干个操作信号的组合来实现的，因此，CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</p></li><li><p>时间控制</p><p>对各种操作实施时间上的控制，称为时间控制。因为在计算机中，各种指令的操作信号均受到时间的严格控制。另一方面，一条指令的整个执行过程也受到时间的严格控制。只有这佯，计算机才能有条不紊地自动工作。</p></li><li><p>数据加工</p><p>数据加工就是对数据进行算术运算和逻辑运算处理。完成数据的加工处理，这是CPU 的根本任务。</p></li></ol><h3 id="5-1-3-CPU-的主要寄存器"><a href="#5-1-3-CPU-的主要寄存器" class="headerlink" title="5.1.3 CPU 的主要寄存器"></a>5.1.3 CPU 的主要寄存器</h3><p>CPU 中的主要寄存器是用来暂时保存在运算和控制过程中的中间结果、最终结果以及控制、状态信息的，在 CPU 中有两类寄存器：一类是通用寄存器，另一类是专用寄存器。</p><ol><li><p>通用寄存器</p><p>通用寄存器可用来存放原始数据和运算结果，有的还可以作为变址寄存器、基址寄存器、栈指针等。通用寄存器都属于用户可见的寄存器，即可以通过机器语言或汇编语言访问的寄存器。</p></li><li><p>专用寄存器</p><p>专用寄存器是 CPU 专门用来完成某一种特殊功能的寄存器。这其中有一部分属于用户可见的寄存器，而另一部分在 CPU 中起操作控制作用的寄存器在大部分机器上对用户是透明的。</p><ol><li><p>指令寄存器（IR）</p><p>指令寄存器用来存放从存储器中取出的指令。当指令从主存取出暂存于指令寄存器之后，在执行指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。</p></li><li><p>程序计数器（PC）</p><p>程序计数器用来存放现行指令的地址或接着要执行的下条指令地址。</p><p>对于顺序执行的情况，PC 的内容修改通常是对 PC 值加 1。当遇到转移指令时，PC 的内容（即后续指令的地址）必须从指令寄存器中的地址字段取得。</p></li><li><p>存储器数据寄存器（MDR）</p><p>存储器数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也暂时将它们存放在存储器数据寄存器中。</p></li><li><p>存储器地址寄存器（MAR）</p><p>存储器地址寄存器用来保存当前 CPU 所访问的存储单元的地址。由于主存和 CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到主存的读/写操作完成为止。</p></li><li><p>状态标志寄存器（PSWR）</p><p>状态标志寄存器保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，如进位标志，结果为零标志等。除此之外，状态标志寄存器还保存中断和系统工作状态等信息，以便使 CPU 和系统能及时了解机器运行状态和程序运行状态。</p></li></ol></li></ol><h2 id="5-2-指令周期和指令流水"><a href="#5-2-指令周期和指令流水" class="headerlink" title="5.2 指令周期和指令流水"></a>5.2 指令周期和指令流水</h2><h3 id="5-2-1-指令周期"><a href="#5-2-1-指令周期" class="headerlink" title="5.2.1 指令周期"></a>5.2.1 指令周期</h3><p>CPU 每取出并执行一条指令所需的全部时间称为指令周期，也即 CPU 完成一条指令的时间。其中，取指阶段完成取指令和分析指令的操作，又称<strong>取指周期</strong>；执行阶段完成执行指令的操作，又称<strong>执行周期</strong>。</p><p>在大多数情况下，CPU 就是按“取指-执行-再取指-再执行……”的顺序自动工作的。由于各种指令的操作功能不同，因此各种指令的指令周期也不尽相同。</p><p>当遇到间接寻址的指令时，由于指令字中只给出操作数有效地址的地址，因此，为了取出操作数，需先访问一次存储器，取出有效地址，然后再访问存储器，取出操作数。故<strong>间接寻址的指令周期就包括取指周期、间址周期和执行周期 3 个阶段</strong>，其中间址周期用于取操作数的有效地址。</p><p>当 CPU 采用中断方式实现主机与 I/O 设备交换信息时，CPU 在每条指令执行阶段结束前，都要发中断查询信号，以检测是否有某个 I/O 设备提出中断请求。如果有请求，CPU 则要进入中断响应阶段，又称中断周期。在中断周期，由中断隐指令自动完成保护断点、寻找中断服务程序入口地址以及硬件关中断的操作。此时，一个完整的指令周期应包括取指、间址、执行和中断 4 个子周期。</p><h3 id="5-2-2-指令流水"><a href="#5-2-2-指令流水" class="headerlink" title="5.2.2 指令流水"></a>5.2.2 指令流水</h3><ol><li><p>原理</p><p>计算机的流水处理过程同工厂中的流水装配线类似，为了实现流水，首先必须把输入的任务（或过程）分割为一系列子任务，使各子任务能在流水线的各个阶段并发地执行，将任务连续不断地输入流水线，从而实观了子任务级的并行。因此流水处理大幅度地改善了计算机的系统性能，是在计算机上实现时间并行性的一种非常经济的方法。</p><p>计算机执行程序是按顺序的方式进行的，即程序中各条机器指令是按顺序串行执行的。如按 4 个周期完成一条指令来考虑，串行执行的过程如下。</p><p><img src="/images/image-20210809230215002.png" alt="image-20210809230215002"></p><p>如将一条指令分成 4 段，若每段所需时间为 T，那么一条指令的时间为 4T，但当第一条指令处理完后每隔 T 时间就能得到一条指令的处理结果，平均速度提高到 4 倍，把这种处理机称为流水线处理机，其工作过程如下。</p><p><img src="/images/image-20210809230305756.png" alt="image-20210809230305756"></p></li><li><p>影响流水性能的因素</p><p>流水过程中会出现三种相关，使得不断流实现起来很困难，这三种相关是：资源相关（结构相关）、数据相关和控制相关。</p><ol><li><p>资源相关</p><p>资源相关是指多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突，也称结构相关。解决冲突的方法可以让流水线在完成前一条指令对数据的存储器访问时，暂停取后一条指令的操作，另一种方式是采用将指令和数据分别存在两个存储器中来减少冲突。</p></li><li><p>数据相关</p><p>数据相关是在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是数据相关的。其解决办法主要有两个：</p><ul><li>采用后推法，即将相关指令延迟到所需操作数被写回到寄存器后再执行</li><li>采用定向技术，即直接将执行结果送到其他指令需要的地方，而不必等某条指令的执行结果送回寄存器，再从寄存器取出该结果来作为下条指令的操作数</li></ul></li><li><p>控制相关</p><p>控制相关冲突是由转移指令引起的。当执行转移指令时，依据转移条件的产生结果，可能是顺序取下条指令，也可能转移到新的目标地址取指令，从而使流水线发生断流。解决办法可以采用转移猜测法等来减少转移指令对流水线性能的影响。</p></li></ol></li><li><p>流水线的性能</p><p>流水线的性能通常用三个指标来衡量：吞吐率、加速比和效率。</p><ol><li><p>吞吐率</p><p>吞吐率是指单位时间内流水线所完成指令或输出结果的数量。吞吐率有最大吞吐率和实际吞吐率之分。</p><p><img src="/images/image-20210809230757059.png" alt="image-20210809230757059"></p></li><li><p>加速比</p><p><img src="/images/image-20210809230823598.png" alt="image-20210809230823598"></p></li><li><p>效率</p><p>效率是指流水线中各功能段的利用率，通常用流水线各段处于工作时间的时空区与流水线中各段总的时空区之比来衡量流水线的效率。由图易知效率的计算公式为：</p><p><img src="/images/image-20210809230921890.png" alt="image-20210809230921890"></p></li><li><p>流水线中的多发技术</p><p>为了在一个时钟周期内，产生更多条指令的结果，可开发流水线中的多发技术，包括超标量技术、超流水线技术、超长指令字技术</p><p><img src="/images/image-20210809231055866.png" alt="image-20210809231055866"></p><ol><li><p>超标量技术</p><p>超标量技术指在每个时钟周期内可同时并发多条独立指令，即以并行操作方式将两条或两条以上指令编译并执行。</p></li><li><p>超流水线技术</p><p>超流水线技术是将一些流水线寄存器插入到流水线段中，相当于将流水线再分段，如将原来的一个时钟周期又分为 3 段，使超流水线的处理器周期比普通流水线的处理器周期短。</p></li><li><p>超长指令字（VLIW）技术</p><p>由编译程序在编译时挖掘出指令间潜在的并行性后，把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令，由这条超长指令控制 VLIW 机中多个独立工作的功能部件，由每一个操作码字段控制一个功能部件，相当于同时执行多条指令。</p></li></ol></li></ol></li></ol><h2 id="5-3-时序系统和控制方式"><a href="#5-3-时序系统和控制方式" class="headerlink" title="5.3 时序系统和控制方式"></a>5.3 时序系统和控制方式</h2><h3 id="5-3-1-时序系统"><a href="#5-3-1-时序系统" class="headerlink" title="5.3.1 时序系统"></a>5.3.1 时序系统</h3><ol><li><p>机器周期 (我的理解是他是一个和指令挂钩的周期)</p><p><strong>指令周期常常用若干个 CPU 周期数来表示，CPU 周期也称为机器周期。</strong>机器周期可看做是所有指令执行过程中的—个基准时间，机器周期取决于指令的功能及器件的速度。由于 CPU 内部的操作速度较快，而 CPU 访问一次内存所花的时间较长，因此通常用内存中读取一个指令字的最短时间来规定 CPU 周期。在存储字长等于指令字长的前提下，取指周期也可看做机器周期，即一条指令的取出阶段需要一个 CPU 周期时间。</p></li><li><p>时钟周期（节拍）</p><p><strong>一个机器周期又包含有若干个时钟周期（通常称为节拍或 T 周期）</strong>。</p><p>在一个机器周期里可完成若干个微操作，每个微操作都需要一定的时间，可用时钟信号来控制产生每一个微操作命令。用时钟信号控制节拍发生器，就可产生节拍。每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作，它是控制计算机操作的最小时间单位。</p><p>一个指令周期包含若干个机器周期，一个机器周期又包含若干个时钟周期（节拍），每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。</p><p>机器周期、节拍组成了多级时序系统。</p></li></ol><h3 id="5-3-2-控制方式"><a href="#5-3-2-控制方式" class="headerlink" title="5.3.2 控制方式"></a>5.3.2 控制方式</h3><p>控制单元（CU）是提供完成计算机全部指令操作的微操作命令序列部件。现代计算机中微操作命令序列的形成方法主要有两种：一种是组合逻辑设计方法，为硬连线逻辑；另一种是微程序设计方法，为存储逻辑。</p><p>通常将如何形成控制不同微操作序列所采用的时序控制方式称为 CU 的控制方式。常见的控制方式有<strong>同步控制</strong>、<strong>异步控制</strong>、<strong>联合控制</strong>和<strong>人工控制</strong>四种。</p><ol><li><p>同步控制方式</p><p>同步控制方式是指，任何一条指令或指令中任何一个微操作的执行都是事先确定的，并且都是受统一基准时标的时序信号所控制的方式。由于不同的指令，操作时间长短不一致，同步控制方式应以最复杂指令的操作时间作为统一的时间间隔标准。</p><p>这种控制方式设计简单，容易实现，但是对于许多简单指令来说会有较多的空闲时间，造成较大数量的时间浪费，从而影响了指令的执行速度。在同步控制方式中，各指令所需的时序由控制器统一发出，所有微操作都与时钟同步，所以又称为集中控制方式或中央控制方式。</p></li><li><p>异步控制方式</p><p>异步控制方式中，各项操作不采用统一的时序信号控制，而根据指令或部件的具体情况决定，需要多少时间，就占用多少时间。</p><p>异步控制采用不同时序，没有时间上的浪费，因而提高了机器的效率，但是控制比较复杂。由于这种控制方式没有统一的时钟，而是由各功能部件本身产生各自的时序信号自我控制，故又称为分散控制方式或局部控制方式。</p></li><li><p>联合控制方式</p><p>这是同步控制和异步控制相结合的方式。实际上现代计算机中几乎没有完全采用同步或完全采用异步的控制方式，大多数是采用联合控制方式。通常的设计思想是：在功能部件内部采用同步方式或以同步方式为主的控制方式，在功能部件之间采用异步方式。</p></li><li><p>人工控制方式</p><p>人工控制是为了调机和软件开发的需要，在机器面板或内部设置一些开关或按键，如 Reset 键、连续或单条执行转换开关及符合停机开关，来达到人工控制的目的。</p></li></ol><h2 id="5-4-微程序设计"><a href="#5-4-微程序设计" class="headerlink" title="5.4 微程序设计"></a>5.4 微程序设计</h2><p>微程序设计技术的实质是将程序设计技术和存储技术相结合，即用程序设计的思想方法来组织操作控制逻辑，将操作控制信号按一定规则进行信息编码，形成微指令，存放在一个只读存储器中。当机器运行时，一条又一条地读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应部件执行所规定的操作。</p><h3 id="5-4-1-基本概念"><a href="#5-4-1-基本概念" class="headerlink" title="5.4.1 基本概念"></a>5.4.1 基本概念</h3><p>一条机器指令对应于一段微程序，微程序是一系列微指令的有序集合。微程序和程序是两个不同的概念。程序由机器指令组成，它是由软件设计人员事先编制好并存放在主存或辅存中的。而微程序是由微指令组成，它实际上是机器指令的实时解释器，由计算机的设计者事先编制好并存放在控制存储器中的。对于程序员来说，计算机系统中微程序的结构和功能是透明的。</p><p>一条微指令由一组实现一定操作功能的微命令构成。微命令是控制计算机各部件完成某个基本微操作的命令。这些微操作是计算机中最基本的、不可再分解的操作。微命令和微操作是一一对应的。微操作可分为相容性和相斥性两种，所谓相容性的微操作，是指在同时或同一个 CPU 周期内可以并行执行的微操作，所谓相斥性的微操作，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。</p><p>一条微指令通常包含两部分信息：</p><ol><li>操作控制字段，又称微操作码字段，用以产生某一步操作所需的各微操作控制信号</li><li>顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址</li></ol><p>微程序控制的计算机涉及到两个层次：一个是机器语言或汇编语言程序员所看到的传统机器层，包括：机器指令、程序、主存储器；另一个是机器设计者看到的微程序层，包括：微指令、微程序和控制存储器。</p><h3 id="5-4-2-微指令编码"><a href="#5-4-2-微指令编码" class="headerlink" title="5.4.2 微指令编码"></a>5.4.2 微指令编码</h3><p>微指令编码法指的是微指令中的操作控制字段的编码方法。通常有以下三种方法：</p><ol><li><p>直接编码法（直接控制法）</p><p>操作控制字段中的各位分别可以直接控制计算机，不需要进行译码。操作控制字段的每一个独立的二进制位代表一个微命令，该位为“1”表示这个微命令有效，为“0”表示这个微命令无效。</p><p>这种方法结构简单，并行性强，操作速度快，但是微指令字太长，若微命令的总数为 N 个，则微指令字的操作控制字段就要有 N 位。</p></li><li><p>字段编码法</p><p>字段编码法可进一步分为字段直接编码法和字段间接编码法。</p><ol><li><p>字段直接编码法</p><p>字段直接编码法将一组相斥性的微命令信号组成一个字段，然后通过译码器对每一个字段译码，便可对应一个微命令。各字段都可以独立地定义本字段的微命令，而和其他字段无关，这种方式靠字段直接译码发出微命令，因此又称为显式编码。这种方法缩短了微指令字，目前应用较为普遍。</p></li><li><p>字段间接编码法</p><p>字段间接编码法是在字段直接编码法的基础上，用来进一步缩短微指令字长的方法。间接编码的含义是，一个字段的某些编码不能独立地定义某些微命令，而需要与其他字段的编码来联合定义，因此又称为隐式编码。</p><p>这种方法虽然可以进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常用做字段直接编码法的一种辅助手段。</p><p>字段编码法中操作控制字段的分段原则：</p><ul><li>把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内。这样不仅有助于提高信息的利用率，缩短微指令字长，而且有助于充分利用硬件所具有的并行性，加快执行的速度。</li><li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此当某字段的长度为三位时，最多只能表示七个互斥的微命令，通常用 000 表示不操作。</li></ul></li></ol></li><li><p>最短编译法</p><p>最短编译法的基本思想是：每一条 L 位字长的微指令只定义一个微命令。如若 L取值为 6，就有 64 种编码状态，则可定义的微指令最多有 64 条。</p><p>按最短编译法编码的微指令比较简单，且微指令字长较短，微指令字中各位都能得到充分利用，然而，由于每条微指令只能对应一个微命令，因此并行控制能力差，微程序长度较长，执行速度慢。</p><p>假设某计算机共有 256 个微命令，如果采用直接控制法，微指令的操作控制字段就要有 256 位；而如果采用最短编译法，操作控制字段只需要 8 位就可以了；如果采用字段直接编码法，若 4 位为一个段，共需 18 段，操作控制字段只需 72 位，而且在同一时刻可以并行发出 18 个不同的微命令。</p></li></ol><h3 id="5-4-3-微指令格式"><a href="#5-4-3-微指令格式" class="headerlink" title="5.4.3 微指令格式"></a>5.4.3 微指令格式</h3><p>微指令有垂直型和水平型之分，水平型微指令则具有良好的并行性，每条微指令可以完成较多的基本操作。垂直型微指令接近于机器指令的格式，每条微指令只能完成一个基本操作。</p><ol><li><p>水平型微指令</p><p>水平型微指令是指一次能定义并能并行执行多个微命令的微指令。它的并行操作能力强，效率高，灵活性强，执行一条机器指令所需微指令的数目少，执行时间短；但微指令字较长，同时微指令和机器指令的差别很大，一般用户不易掌握。按直接编码法、字段直接编码法、字段间接编码法编码的微指令都属于水平型微指令。</p></li><li><p>垂直型微指令</p><p>垂直型微指令的结构类似于机器指令的结构，它有操作码，功能简单，并行操作能力差，但由于微指令与机器指令很相似，所以容易掌握和利用，编程比较简单，且微指令字较短。按最短编译法编码的微指令属于垂直型微指令。</p></li></ol><h3 id="5-4-4-微地址的形成"><a href="#5-4-4-微地址的形成" class="headerlink" title="5.4.4 微地址的形成"></a>5.4.4 微地址的形成</h3><p>微程序是由微指令组成的，执行当前一条微指令时，必须指出后继微指令的地址，以便当前一条微指令执行完毕后，取出下一条微指令。决定后继微指令地址的方法不只一种，主要有两大基本类型：增量方式和断定方式。</p><p><img src="/images/image-20210809232905351.png" alt="image-20210809232905351"></p><h1 id="6-外部设备和系统"><a href="#6-外部设备和系统" class="headerlink" title="6. 外部设备和系统"></a>6. 外部设备和系统</h1><h2 id="6-1-外存储器"><a href="#6-1-外存储器" class="headerlink" title="6.1 外存储器"></a>6.1 外存储器</h2><p>CPU 和主存构成了主机，除主机外的大部分硬件设备都可称为外部设备，简称外设。计算机的外部设备主要包括外存储器、输入设备、输出设备。</p><p><img src="/images/image-20210809233054201.png" alt="image-20210809233054201"></p><p><strong>外存储器简称外存或辅存，它与主存一起组成了存储器系统的主存-辅存层次。</strong>与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属“非易失性”存储器。常见的外存储器有软盘、硬盘、磁带、光盘等。前三种均属磁表面存储器。</p><h3 id="6-1-1-磁表面存储器的主要技术指标"><a href="#6-1-1-磁表面存储器的主要技术指标" class="headerlink" title="6.1.1 磁表面存储器的主要技术指标"></a>6.1.1 磁表面存储器的主要技术指标</h3><ol><li><p>记录密度</p><p>记录密度是指单位长度内所存储的二进制信息量。磁盘存储器用道密度和位密度表示；磁带存储器则用位密度表示。</p><p>道密度是磁盘沿半径方向单位长度的磁道数，单位是 tpi（道/英寸）或 tpm(道/毫 米)。相邻两条磁道中心线之间的距离称为道距，道密度等于道距的倒数。</p><p>位密度是单位长度磁道能记录二进制信息的位数，也称为线密度，单位是 bpi（位/英寸）或 bpm（位/毫米）。</p><p>在磁盘各磁道上所记录的信息量是相同的，而位密度不同。一般泛指磁盘位密度时，是指最内圈磁道上的位密度（最大位密度）。</p></li><li><p>存储容量</p><p>存储容量是指外存所能存储的二进制信息总数量，一般以位或字节为单位。</p></li><li><p>平均寻址时间</p><p>磁盘的寻道时间是指磁盘的磁头移动到指定磁道所需的时间；磁盘的等待时间是指磁头已处于要访问的磁道，等待所要访问的扇区旋转至磁头下方的时间。因磁盘每次的寻道时间和等待时间并不相同，故取这些时间的平均值并求和，得到磁盘的平均寻址时间，即：平均寻址时间=平均寻道时间+平均等待时间。</p><p>平均寻址时间是磁盘存储器的一个重要指标。硬盘的平均寻址时间比软盘的平均寻址时间短，故硬盘比软盘的速度快。</p></li><li><p>数据传输率</p><p>数据传输率是指单位时间内磁表面存储器向主机传送数据的位数或字节数。</p></li><li><p>误码率</p><p>误码率是衡量磁表面存储器出错概率的参数，它等于从外存读出时，出错信息位数和读出信息的总位数之比。为减少出错率，磁表面存储器通常采用循环冗余码（CRC）来发现并纠正错误。</p></li></ol><h3 id="6-1-2-磁表面存储器的记录方式"><a href="#6-1-2-磁表面存储器的记录方式" class="headerlink" title="6.1.2 磁表面存储器的记录方式"></a>6.1.2 磁表面存储器的记录方式</h3><ol><li><p>记录方式</p><p>磁记录方式又称为编码方式，它是按某种规律将一串二进制数字信息变换成磁表面相应的磁化状态。常用的记录方式有六种</p><p><img src="/images/image-20210809233535396.png" alt="image-20210809233535396"></p><ol><li>归零制（RZ）</li></ol><p>归零制记录“1”时，通以正向脉冲电流，记录“0”时，通以反向脉冲电流。由于两位信息之间驱动电流归零，故称为归零制记录方式。</p><ol start="2"><li>不归零制（NRZ）</li></ol><p>不归零制记录信息时，磁头线圈始终有驱动电流，不是正向，便是反向，不存在无电流状态。当连续记“1”或“0”时，其写电流方向不变，只有当相邻两信息代码不同时，写电流才改变方向，故称为“见变就翻”的不归零制。</p><ol start="3"><li>“见1就翻”的不归零制（NRZ1）</li></ol><p>“见 1 就翻”的不归零制在记录信息时，磁头线圈也始终有电流。但只有在记录“1”时电流改变方向，使磁层磁化方向发生翻转；记录“0”时，电流方向保持不变，使磁层的磁化方向也维持原来状态，因此称为“见 1 就翻”的不归零制。</p><ol start="4"><li>调相制（PM）</li></ol><p>调相制又称为相位编码（PE），其记录规则是：记录“1”时，写电流由负变正；记录“0”时，写电流由正变负，电流变化出现在一位信息记录时间的中间时刻，它以相位差为 180 度的磁化翻转方向来表示“1”和“0”。调相制在磁带存储器中用得较多。</p><ol start="5"><li>调频制（FM）</li></ol><p>调频制的记录规则是：以驱动电流变化的频率不同来区别记录“1”还是“0”。当记录“0”时，在一位信息的记录时间内电流保持不变；当记录“1”时，在一位信息记录时间的中间时刻，使电流改变一次方向。而且无论记录“0”还是“1”，在相邻信息的交界处，线圈电流均变化一次。因此写“1”时，在位单元的起始和中间位置都有磁通翻转；在写“0”时，仅在位单元起始位置有翻转。则记录“1”的磁翻转频率为记录“0”的两倍，故又称为倍频制。调频制记录方式被广泛应用在硬盘和软盘中。</p><ol start="6"><li>改进型调频制（MFM）</li></ol><p>这种记录方式基本上同调频制，即记录“0”时，在位记录时间内电流不变；记录“l”时，在位记录时间的中间时刻电流发生一次变化。两者不同之处在于，改进型调频制只有当连续记录两个或两个以上的“0”时，才在每位的起始处改变一次电流，不必在每个位起始处都改变电流方向。由于这一特点，在写入同样数据序列时，MFM比 FM 磁翻转次数少，在相同长度的磁层上可记录的信息量将会增加，从而提高了磁记录密度。FM 制记录一位二进制代码最多是两次磁翻转，MFM 制最多只要一次翻转，记录密度提高了一倍，故又称为倍密度记录方式。</p></li><li><p>评价指标</p><p>评价一种记录方式的优劣标准主要反映在编码效率和自同步能力等方面。</p><ol><li>编码效率</li></ol><p>编码效率是指位密度与磁化翻转密度的比值，可用记录一位信息的最大磁化翻转次数来表示。例如，FM、PM 记录方式中，记录一位信息最大磁化翻转次数为 2，因此编码效率为 50%；而 MFM、NRZ、NRZ1 三种记录方式的编码效率为 100%，因为它们记录一位信息磁化翻转最多一次。</p><ol start="2"><li>自同步能力</li></ol><p>自同步能力是指从单个磁道读出的脉冲序列中所提取同步时钟脉冲的难易程度。磁表面存储器为了进行读写操作，必须有时间基准信号，称为同步信号。</p><p>同步信号可以从专门设置用来记录同步信号的磁道中取得，这种方法称为外同步，如 NRZ1 制，但它占用了磁表面存储器的有效记录面积。</p><p>对于高密度的记录系统，可直接从磁盘读出的信号中提取同步信号，这种方法称为自同步。</p><p>自同步能力可用最小磁化翻转间隔和最大磁化翻转间隔之比值 R 来衡量。如 FM记录方式的最大磁化翻转间隔是 T（T 为一位信息的记录时间），最小磁化翻转间隔是 T/2，所以 R=0.5。R 越大，自同步能力也越强。</p><p>NRZ 和 NRZ1 方式在连续记录“0”时，磁层都不发生磁化磁转，且 NRZ 方式在连续记录“1”时，磁层也不发生磁化翻转，因此，NRZ 和 NRZ1 都没有自同步能力。而 PM、FM、MFM 记录方式均有自同步能力。</p></li></ol><h3 id="6-1-3-常见的外存储器"><a href="#6-1-3-常见的外存储器" class="headerlink" title="6.1.3 常见的外存储器"></a>6.1.3 常见的外存储器</h3><ol><li><p>软盘</p><p>软盘是个人计算机中最早使用的可移介质，常用的有 3.5 英寸和 2.5 英寸的软盘，容量在 1MB 以上。软盘存取速度慢，容量也小，携带方便，20 世纪八九十年代曾作为外存的主要部件。</p></li><li><p>硬盘</p><p>硬盘是计算机系统中最主要的外存设备。硬盘的存储介质材料是一种由铝合金材料制成的圆盘，盘的表面涂有一层可被磁化的硬磁特性材料。目前应用最广泛的是温彻斯特磁盘，它是一种可移动磁头固定盘片的磁盘存储器，简称温盘。</p><p>硬盘主要由磁盘、磁头及控制电路组成，信息存储在磁盘上，磁头负责读出或写入。当硬盘接到一个系统读取数据指令后磁头根据给出的地址，首先按磁道号产生驱动信号进行定位，然后再通过盘片的转动找到具体的扇区，最后由磁头读取指定位置的信息并传送到硬盘缓存中。</p></li><li><p>光盘</p><p>光盘是利用光存储技术进行读/写信息的存储设备，主要由光盘、光盘驱动器和光盘控制器组成。主要有 CD 和 DVD 两大类。</p></li><li><p>移动存储设备</p><p>U 盘是一种采用闪存为存储介质，通过 USB 接口与计算机交换数据的可移动存储设备，具有可多次擦写、体积小、即插即用等特点。</p><p>移动硬盘以硬盘为存储介质，通过 USB 接口与计算机相连，且普遍采用了热插拔技术，具有高速、大容量、即插即用、轻巧便捷的特点。</p></li></ol><h2 id="6-2-输入输出设备"><a href="#6-2-输入输出设备" class="headerlink" title="6.2 输入输出设备"></a>6.2 输入输出设备</h2><h3 id="6-2-1-输入设备"><a href="#6-2-1-输入设备" class="headerlink" title="6.2.1 输入设备"></a>6.2.1 输入设备</h3><p>输入设备是计算机的外部设备之一，是向计算机输送数据的设备。其功能是将计算机的程序、文本、图形、图像、声音以及现场采集的各种数据转换为计算机能处理的数据形式并输送到计算机内部。常见的输入设备有键盘、鼠标、手写笔、扫描仪等。</p><ol><li><p>鼠标</p><p>鼠标是一种输入设备，分有线和无线两种，也是计算机显示系统纵横坐标定位的指示器，因形似老鼠而得名“鼠标”。鼠标的使用是为了使计算机的操作更加简便快捷，来代替键盘繁琐的指令。</p></li><li><p>键盘</p><p>键盘是用于操作设备运行的一种指令和数据输入装置，是应用最普遍的输入设备。</p></li></ol><h3 id="6-2-2-输出设备"><a href="#6-2-2-输出设备" class="headerlink" title="6.2.2 输出设备"></a>6.2.2 输出设备</h3><p>输出设备的功能是将计算机中的数据信息传送到外部媒介，并转化成某种人们所认识的表示形式。最常用的输出设备有显示器和打印机。</p><ol><li><p>显示器</p><p>显示器通常也被称为监视器，它是一种将一定的电子文件通过特定的传输设备显示到屏幕的显示工具，它是目前计算机系统中应用最广泛的人-机界面设备。</p><p>按显示设备所用的显示器分类，有阴极射线管（CRT）显示器、等离子显示器（PDP）、液晶显示器（LCD）、发光二极管显示器（LED）等。</p><p>显示器的主要性能指标有：</p><p>1）分辨率</p><ul><li>分辨率是指显示器屏幕能表示的像素点数，分辨率越高，图像越清晰</li></ul><p>2）灰度级</p><ul><li>灰度级是指显示像素点相对亮暗的级差，在彩色显示器中它还表现为色彩的差别</li></ul><p>3）刷新频率</p><ul><li>刷新频率指的是每分钟内屏幕画面更新的次数。刷新频率过低，可出现屏幕画面闪烁或抖动的情况。</li></ul><p>4）点距</p><ul><li>点距是指显示器屏幕上相邻像素点之间的距离。点距越小，图像越清晰</li></ul><p>5）屏幕尺寸</p><ul><li>屏幕尺寸是指矩形屏幕对角线的长度</li></ul></li><li><p>打印机</p><p>打印机是计算机的输出设备之一，用于将计算机处理结果打印在相关介质上，是一种硬拷贝设备。</p><p>打印机有多种划分方法。按印字原理划分，有击打式打印机和非击打式打印机。击打式打印机是利用机械动作使印字机构与色带和纸相撞击而打印字符。它又分为活字打印机和点阵针式打印机两种。活字打印机现在用得越来越少。点阵针式打印机利用钢针打击色带产生打印效果，打印成本低，目前仍用得较普遍。非击打式打印机采用电、磁、光、喷墨等物理和化学方法来印刷字符，主要有激光打印机、喷墨打印机等。</p><p>按数据传输方式划分，有串行打印机和并行打印机两种，前者是逐字打印，后者是逐行打印。</p><p>打印机常见的参数指标主要有以下几个：</p><p>1）打印速度</p><ul><li>打印速度一般用 PPM 表示，指打印机每分钟可打印的页数</li></ul><p>2）打印分辨率</p><ul><li>打印分辨率指打印输出时，在横向和纵向上每英寸最多能够打印的点数，一般用DPI（点/英寸）表示</li></ul><p>3）最大打印尺寸</p><ul><li>最大打印尺寸指打印机所能打印的最大纸张尺寸，一般主要有A4和A3两种规格</li></ul></li></ol><h2 id="6-3-I-O系统概述"><a href="#6-3-I-O系统概述" class="headerlink" title="6.3 I/O系统概述"></a>6.3 I/O系统概述</h2><p>在计算机的硬件系统中，输入输出系统是除了 CPU 和存储器二者之外的第三个关键部分。</p><h3 id="6-3-1-主机与-I-O-设备的联系"><a href="#6-3-1-主机与-I-O-设备的联系" class="headerlink" title="6.3.1 主机与 I/O 设备的联系"></a>6.3.1 主机与 I/O 设备的联系</h3><ol><li><p>I/O 指令</p><p>I/O 指令是机器指令的一类，其一般格式主要由三部分组成：操作码、命令码和设备码。操作码可作为 I/O 指令与其他指令（如访存指令、控制指令等）的判别代码；命令码体现 I/O 设备的具体操作；设备码是 I/O 设备的选择码。</p></li><li><p>编址方式</p><p>将 I/O 设备码看做地址码，对 I/O 地址码的编址可采用两种方式：统一编址或不统一编址。统一编址就是将 I/O 地址看做是存储器地址的一部分；不统一编址（或称独立编址）指 I/O 地址和存储器地址是分开的，所有对 I/O 设备的访问必须有专用的I/O 指令。统一编址占用存储空间，减少了主存容量，但无须专用的 I/O 指令；不统一编址不占用主存空间，不影响主存容量，但需设 I/O 专用指令。</p></li><li><p>传送方式</p><p>n 位信息同时在 CPU 和 I/O 设备之间进行传输，这种传送方式称为并行传送。其特点是传送速度较快，要求数据线多，如 32 位信息并行传送需要 32 根数据线。</p><p>若连续逐位传送信息，这种传送方式称为串行传送。当远距离数据通信时，采用串行传送较为合理。</p></li></ol><h3 id="6-3-2-I-O-接口"><a href="#6-3-2-I-O-接口" class="headerlink" title="6.3.2 I/O 接口"></a>6.3.2 I/O 接口</h3><p>主机和外设具有不同的工作特点，它们在信息形式和工作速度上存在很大的差异，要将各种各样的外部设备与计算机连接起来，解决它们之间的差异，使之能协调地工作，就要通过各种接口来连接。I/O 接口是指主机与 I/O 设备之间设置的硬件电路及其相应的软件控制。</p><p>接口（Interface）与端口（Port）是两个不同的概念。端口是指接口电路中的一些寄存器，这些寄存器分别存放数据信息、控制信息和状态信息，相应的称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑电路才组成接口。</p><ol><li><p>接口功能</p><p>1）选址功能</p><p>CPU 对于设备的选择，通过设备选择线上的设备码来确定。将设备码送至所有设备的接口，故要求每个接口都必须具有选址功能，即当设备选择线上的设备码与本设备码相符时，应发出设备选中信号，这种功能可通过接口内的设备选择电路来实现。</p><p>2）传送命令的功能</p><p>当 CPU 向 I/O 设备发出命令时，要求 I/O 设备能做出响应，如果 I/O 接口不具备传送命令信息的功能，那么设备将无法响应，故通常在 I/O 接口中设有存放命令的命令寄存器以及命令译码器。</p><p>3）传送数据的功能</p><p>接口处于主机与 I/O 设备之间，因此数据必须通过接口才能实现主机与 I/O 设备之间的传送。接口中通常设有数据缓冲寄存器（Data Buffer Register，DBR），与 I/O总线中的数据线相连，用来暂存 I/O 设备与主机准备交换的信息。</p><p>4）反映 I/O 设备工作状态的功能</p><p>为使 CPU 能及时了解各 I/O 设备的工作状态，接口内必须设置一些反映设备工作状态的触发器。</p></li><li><p>接口类型</p><p>I/O 接口按不同方式分类有以下几种：</p><p>1）按数据传送方式分类</p><ul><li>分为并行接口和串行接口两类。并行接口是将一个字节（或一个字）的所有位同时传送；串行接口是在设备与接口间一位一位传送。</li></ul><p>2）按功能选择的灵活性分类</p><ul><li>分为可编程接口和不可编程接口两种。可编程接口的功能及操作方式可用程序来改变或选择；不可编程接口不能由程序来改变其功能，但可通过硬连线逻辑来实现不同的功能。</li></ul><p>3）按通用性分类</p><ul><li>分为通用接口和专用接口。通用接口可供多种 I/O 设备使用；专用接口是为某类外设或某种用途专门设计的。</li></ul><p>4）按数据传送的控制方式分类</p><ul><li>有程序型接口和 DMA 型接口。程序型接口用于连接速度较慢的 I/O 设备，如显示终端、键盘、打印机等；DMA 型接口用于连接高速 I/O 设备，如磁盘、磁带等。</li></ul></li></ol><h3 id="6-3-3-主机与-I-O-设备信息传送的控制方式"><a href="#6-3-3-主机与-I-O-设备信息传送的控制方式" class="headerlink" title="6.3.3 主机与 I/O 设备信息传送的控制方式"></a>6.3.3 主机与 I/O 设备信息传送的控制方式</h3><p>主机和 I/O 设备之间的信息传送的控制方式可以分为以下四种：</p><ol><li><p>程序查询方式</p><p>程序查询方式是主机与 I/O 设备之间进行信息交换的最简单方式，由 CPU 通过程序不断查询 I/O 设备是否已做好准备，从而控制 I/O 设备与主机交换信息。</p><p>这种方式控制简单，但CPU和I/O设备处于串行工作状态，CPU的工作效率不高，主要适用于 I/O 设备少，数据传输率较低的系统。</p></li><li><p>程序中断方式</p><p>I/O 设备作好输入/输出准备时，向 CPU 发出中断请求，CPU 接到请求后就暂时中止原来执行的程序，转去执行中断服务程序，从而可以输入/输出一个数据。当中断处理完毕后，CPU 返回原来的程序继续执行。</p><p>这种方式实现了 CPU 和 I/O 设备的并行工作，提高了 CPU 的工作效率，一般适用于随机出现的服务。</p></li><li><p>直接存储器存取（DMA）方式</p><p>DMA 方式是在主存和 I/O 设备之间开辟一条直接的数据通路，可以进行基本上不需要 CPU 介入的信息传送，此时，DMA 控制器从 CPU 完全接管对总线的控制，数据交换不经过 CPU，而直接在内存和 I/O 设备之间进行。</p><p>这种方式进一步提高了 CPU 的资源利用率，能满足高速 I/O 设备的需要。</p></li><li><p>I/O 通道控制方式</p><p>通道的出现进一步提高了 CPU 的效率，这是因为 CPU 将部分权利下放给通道，通道可视为一种具有特殊功能、但不完全独立的处理器。它依据 CPU 的 I/O 指令工作，是从属于 CPU 的一个专用处理器，用来负责管理 I/O 设备、实现主存与 I/O 设备之间交换信息。</p><p>依赖通道管理的 I/O 设备在与主机交换信息时，CPU 不直接参与管理，故 CPU 的工作效率大为提高，但这种提高是以花费更多硬件为代价的。</p><p>目前，小型机和微型机大都采用程序查询方式、程序中断方式和 DMA 方式，通道方式一般用在中、大型计算机中。</p></li></ol><h2 id="6-4-中断方式"><a href="#6-4-中断方式" class="headerlink" title="6.4 中断方式"></a>6.4 中断方式</h2><p>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断”。通常把实现中断所需的软硬件技术统称为中断技术。</p><ol><li><p>中断的提出</p><p>引起中断的因素大致可分为以下几类：</p><p>1）人为设置的中断</p><p>人为设置的中断一般称为自愿中断，一旦计算机执行人为中断，便停止现行程序而转入中断处理。</p><p>2）程序性事故</p><p>程序性事故是由程序设计不周而引起的中断，如定点溢出、操作码不能识别等。</p><p>3）硬件故障</p><p>硬件故障有电源掉电、插件接触不良等。</p><p>4）I/O 设备</p><p>I/O 设备启动后，一旦准备就绪，就向 CPU 发出中断请求。</p><p>5）外部事件</p><p>用户通过键盘来中断现行程序属于外部事件中断。</p><p>上述各种中断因素除自愿中断是人为的以外，大多都是随机的。通常将能引起中断的各个因素称为中断源。中断源可分两大类：一类为不可屏蔽中断，这类中断 CPU不能禁止响应，如电源掉电；另一类为可屏蔽中断，对可屏蔽中断源的请求，CPU 可根据该中断源是否被屏蔽来确定是否给予响应。若未屏蔽则可以响应；若已被屏蔽，则 CPU 不能响应。</p></li></ol><h3 id="6-4-2-中断处理过程-（后面一部分没弄完）"><a href="#6-4-2-中断处理过程-（后面一部分没弄完）" class="headerlink" title="6.4.2 中断处理过程 （后面一部分没弄完）"></a>6.4.2 中断处理过程 （后面一部分没弄完）</h3><p>计算机的中断处理过程表面上看起来有点类似于调用子程序的过程，但是它们之间却是有着本质上的区别：首先，子程序的执行是由程序员事先安排好的，而中断服务程序的执行则大多是由随机的中断事件引起的；其次，子程序的执行受到主程序或上层子程序的控制，而中断服务程序一般与被中断的现行程序毫无关系；最后，不存在同时调用多个子程序的情况，而有可能发生多个 I/O 设备同时请求 CPU 为自己服务的情况。</p><p>一次中断处理过程可简单地归纳为以下几个阶段：中断请求、中断判优、中断响应、中断服务和中断返回。</p><ol><li><p>中断请求</p><p>为了判断是哪个中断源提出请求，在中断系统中必须设置中断请求标记触发器，简称中断请求触发器，记作 INTR。当其状态为 1”时，表示中断源有请求。这种触发器可集中设在 CPU 的中断系统内，组成一个中断请求标记寄存器，也可以分散到各个中断源中，如分散在各个接口电路内。</p></li><li><p>中断判优</p><p>当某一时刻有多个中断源提出中断请求时，中断系统必须按其优先顺序予以响应，这称为中断判优。各中断源的优先顺序根据该中断源若得不到及时响应，致使机器工作出错的严重程度而定。</p><p>中断判优可用硬件实现，也可用软件实现。</p></li><li><p>中断响应</p><p>1）中断响应的条件和时间</p><ul><li>一个中断系统，在任一时刻，只能响应一个中断源的请求。CPU 响应中断源提出中断请求的条件是：必须满足 CPU 中的允许中断触发器 EINT 为“1”。允许中断触发器 EINT 可用开中断指令置“1”（称为开中断），意味着 CPU 允许响应中断源的请求；也可用关中断指令或硬件自动使其置“0”（称为关中断），意味着 CPU 禁止响应中断。</li><li>CPU 响应中断的时间是在每条指令执行阶段的结束时刻。CPU 在执行周期的结束时刻统一向所有中断源发中断查询信号，只有此时，CPU 才能获知哪个中断源有请求。若有中断，CPU 进入中断周期；若无中断，则进入下一条指令的取指周期。</li></ul><p>2）中断隐指令</p><ul><li>中断隐指令即在机器指令系统中没有的指令，它是 CPU 在中断周期内由硬件自动完成的一条指令。CPU 响应中断后，即进入中断周期。在中断周期内，CPU 要自动完成一系列操作：</li></ul></li></ol><h2 id="6-5-DMA方式"><a href="#6-5-DMA方式" class="headerlink" title="6.5 DMA方式"></a>6.5 DMA方式</h2><p>DMA适合于内存与高速I/O设备或外存之间的信息交换。DMA方式中，由于DMA接口与 CPU 共享内存，为有效分时使用内存，通常 DMA 与内存交换数据时采用以下三种方法：</p><ol><li><p>CPU 停止访问内存法</p><p>当外设要求传送一批数据时，由 DMA 接口向 CPU 发一个停止信号，要求 CPU放弃地址线、数据线和有关控制线的使用权。DMA 接口获得总线控制权后，开始进行数据传送，直到一组数据传送完毕后，DMA 接口通知 CPU 可以使用内存，并把总线控制权交回给 CPU。这种方法的优点是控制简单，适用于高速 I/O设备的数据成组传送。缺点是在 DMA 接口访问内存期间，CPU 基本处于保持或不工作状态，CPU 对主存的利用率得不到充分发挥。</p><p><img src="/images/image-20210810000754912.png" alt="image-20210810000754912"></p></li><li><p>周期挪用法</p><p>周期挪用也叫周期窃取，在这种方法中，每当 I/O 设备发出 DMA 请求时，I/O 设备便挪用或窃取总线占用权一个或几个内存周期，而 DMA 不请求时，CPU 仍继续访问内存。周期窃取法每次在 DMA 控制器传送完一个数据后立即释放总线，使 I/O 设备在准备下一数据时，CPU 能插空访问主存。</p><p><img src="/images/image-20210810000853241.png" alt="image-20210810000853241"></p><p>若 I/O 设备请求 DMA 传送时，CPU 不需要访存，则周期挪用对 CPU 执行程序无任何影响；若 CPU 正在访问内存，此时必须待存取周期结束，CPU 才能将总线占有权让出；若同一时刻，发生 CPU 与 DMA 的访存冲突，那么优先保证 DMA 工作，因为 I/O 设备不立即访问内存就可能丢失数据，这时 I/O 设备要窃取一、二个存取周期，CPU 则延缓一、二个存取周期再访问内存。</p><p>与 CPU 停止访问内存法相比，周期挪用的方法既实现了 I/O 传送，又较好地发挥了内存和 CPU 的效率，是一种广泛采用的方法。</p><p>但应该指出，I/O 设备每挪用一个内存周期都要申请总线控制权、建立总线控制权和归还总线控制权。因此，尽管传送一个字对内存而言只占用一个内存周期，但对DMA 接口而言，实质上要占 2～5 个内存周期。故周期挪用的方法比较适合于 I/O 设备的读/写周期大于内存周期的情况。</p></li><li><p>DMA 与 CPU 交替访问</p><p>如果 CPU 的工作周期比内存存取周期长很多，此时采用交替访问的方法可以使得DMA 传送和 CPU 同时发挥最高的效率。如图所示，把一个 CPU 周期分成两个时间片，一个给 CPU，一个给 DMA，使 CPU 和 DMA 交替地访问内存。这种方法不需要申请和归还总线，总线控制权的转移几乎不需要什么时间，具有很高的 DMA 传送效率。而且 CPU 既不停止现行程序的运行，也不进入等待状态，不知不觉地就完成了DMA 的数据传送，故又被称为“透明的 DMA”方式。</p><p><img src="/images/image-20210810001122895.png" alt="image-20210810001122895"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2021/08/02/5.%20ElasticSearch/"/>
    <url>/2021/08/02/5.%20ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="1-初识ElasticSearch"><a href="#1-初识ElasticSearch" class="headerlink" title="1. 初识ElasticSearch"></a>1. 初识ElasticSearch</h1><h2 id="1-1-倒排索引"><a href="#1-1-倒排索引" class="headerlink" title="1.1 倒排索引"></a>1.1 倒排索引</h2><p><strong>倒排索引</strong>：将文档进行分词，形成词条和id的对应关系即为反向索引。</p><p>以唐诗为例，所处包含“前”的诗句</p><p>正向索引：由《静夜思》–&gt;床前明月光—&gt;“前”字</p><p>反向索引：“前”字–&gt;床前明月光–&gt;《静夜思》</p><p>反向索引的实现就是对诗句进行分词，分成单个的词，由词推据，即为反向索引</p><p>“床前明月光”–&gt; 分词</p><p>将一段文本按照一定的规则，拆分为不同的词条（term）</p><p><img src="/images/image-20210802232553086.png" alt="image-20210802232553086"></p><h2 id="1-2-ES存储和查询的原理"><a href="#1-2-ES存储和查询的原理" class="headerlink" title="1.2 ES存储和查询的原理"></a>1.2 ES存储和查询的原理</h2><ul><li>index（索引）：相当于mysql的数据库</li><li>映射：相当于mysql 的表结构</li><li>document(文档)：相当于mysql的表中的数据</li></ul><p>数据库查询存在的问题：</p><ol><li>性能低：使用模糊查询，左边有通配符，不会走索引，会全表扫描，性能低</li><li>功能弱：如果以”华为手机“作为条件查询下图索引库，查询不出来数据</li></ol><p>Es使用倒排索引，对title 进行分词</p><p><img src="/images/image-20210802233002078.png" alt="image-20210802233002078"></p><ol><li><p>使用“手机”作为关键字查询</p><p>生成的倒排索引中，词条会排序，形成一颗树形结构，提升词条的查询速度</p></li><li><p>使用“华为手机”作为关键字查询</p><p>华为：1,3</p><p>手机：1,2,3</p></li></ol><p><img src="/images/image-20210802233215711.png" alt="image-20210802233215711"></p><h2 id="1-3-ES概念详解"><a href="#1-3-ES概念详解" class="headerlink" title="1.3 ES概念详解"></a>1.3 ES概念详解</h2><ul><li><p>ElasticSearch是一个基于Lucene的搜索服务器</p><p><img src="/images/image-20210802233322245.png" alt="image-20210802233322245"></p></li><li><p>是一个分布式、高扩展、高实时的搜索与数据分析引擎</p></li><li><p>基于RESTful web接口</p></li><li><p>Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎</p></li></ul><p>官网：<a href="https://www.elastic.co/">https://www.elastic.co/</a></p><p>应用场景：</p><ol><li>搜索：海量数据的查询</li><li>日志数据分析</li><li>实时数据分析</li></ol><h1 id="2-安装ElasticSearch"><a href="#2-安装ElasticSearch" class="headerlink" title="2. 安装ElasticSearch"></a>2. 安装ElasticSearch</h1><h2 id="2-1-ES安装"><a href="#2-1-ES安装" class="headerlink" title="2.1 ES安装"></a>2.1 ES安装</h2><ol><li><p>上传ElasticSearch安装包(在官网下载到了宿主机上，也可以直接在虚拟机中用命令下载)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">alt+p # 打开sftp窗口<br><span class="hljs-meta">#</span><span class="bash"> 上传es安装包</span><br>put e:/software/elasticsearch-7.4.0-linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>执行解压操作 ，如下图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将elasticsearch-7.4.0-linux-x86_64.tar.gz解压到opt文件夹下. -C 大写</span><br>tar -zxvf elasticsearch-7.4.0-linux-x86_64.tar.gz  -C /opt<br></code></pre></td></tr></table></figure></li><li><p>创建普通用户</p><p>因为安全问题，Elasticsearch 不允许root用户直接运行，所以要创建新用户，在root用户中创建新用户,执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd itheima  # 新增itheima用户<br>passwd  itheima  # 为itheima用户设置密码<br></code></pre></td></tr></table></figure></li><li><p>为新用户授权，如下图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R itheima:itheima /opt/elasticsearch-7.4.0 #文件夹所有者<br></code></pre></td></tr></table></figure></li><li><p>修改elasticsearch.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /opt/elasticsearch-7.4.0/config/elasticsearch.yml <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ======================== Elasticsearch Configuration =========================</span><br>cluster.name: my-application<br>node.name: node-1<br>network.host: 0.0.0.0  # 配置成这个地址可以让外网访问到，localhost外网访问不到<br>http.port: 9200<br>cluster.initial_master_nodes: [&quot;node-1&quot;]<br></code></pre></td></tr></table></figure><p>cluster.name：配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称</p><p>node.name：节点名，elasticsearch会默认随机指定一个名字，建议指定一个有意义的名称，方便管理</p><p>network.host：设置为0.0.0.0允许外网访问</p><p>http.port：Elasticsearch的http访问端口</p><p>cluster.initial_master_nodes：初始化新的集群时需要此配置来选举master</p></li><li><p>修改配置文件</p><p>新创建的itheima用户最大可创建文件数太小，最大虚拟内存太小，切换到root用户，编辑下列配置文件， 添加类似如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换到root用户</span><br>su root <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">1. ===最大可创建文件数太小=======</span><br>vim /etc/security/limits.conf <br><span class="hljs-meta">#</span><span class="bash"> 在文件末尾中增加下面内容</span><br>itheima soft nofile 65536<br>itheima hard nofile 65536<br><span class="hljs-meta">#</span><span class="bash"> =====</span><br>vim /etc/security/limits.d/20-nproc.conf<br><span class="hljs-meta">#</span><span class="bash"> 在文件末尾中增加下面内容</span><br>itheima soft nofile 65536<br>itheima hard nofile 65536<br>*  hard    nproc     4096<br><span class="hljs-meta">#</span><span class="bash"> 注：* 代表Linux所有用户名称</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">2. ===最大虚拟内存太小=======</span><br>vim /etc/sysctl.conf<br><span class="hljs-meta">#</span><span class="bash"> 在文件中增加下面内容</span><br>vm.max_map_count=655360<br><span class="hljs-meta">#</span><span class="bash"> 重新加载，输入下面命令：</span><br>sysctl -p<br></code></pre></td></tr></table></figure></li><li><p>启动elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su itheima  # 切换到itheima用户启动<br>cd /opt/elasticsearch-7.4.0/bin<br>./elasticsearch #启动<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-2-访问elasticsearch"><a href="#2-2-访问elasticsearch" class="headerlink" title="2.2 访问elasticsearch"></a>2.2 访问elasticsearch</h2><ol><li><p>在访问elasticsearch前，请确保防火墙是关闭的，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">暂时关闭防火墙</span><br>systemctl  stop  firewalld<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 或者</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">永久设置防火墙状态</span><br>systemctl enable firewalld.service  #打开防火墙永久性生效，重启后不会复原 <br>systemctl disable firewalld.service #关闭防火墙，永久性生效，重启后不会复原 <br></code></pre></td></tr></table></figure></li><li><p>浏览器输入<a href="http://192.168.200.129:9200/">http://192.168.200.129:9200/</a></p><p><img src="/images/image-20210802234919469.png" alt="image-20210802234919469"></p><p>看到上图说明此时elasticsearch已成功启动：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d">重点几个关注下即可:<br>numbe<span class="hljs-string">r&quot; : &quot;</span><span class="hljs-number">7.4</span><span class="hljs-number">.0</span><span class="hljs-string">&quot;   表示elasticsearch版本</span><br><span class="hljs-string">lucene_version&quot;</span> : <span class="hljs-string">&quot;8.2.0&quot;</span>  表示lucene版本<br>name ： 默认启动的时候指定了 ES 实例名称<br>cluster_name ： 默认名为 elasticsearch<br></code></pre></td></tr></table></figure></li></ol><h1 id="3-Elasticsearch辅助插件Kibana安装"><a href="#3-Elasticsearch辅助插件Kibana安装" class="headerlink" title="3. Elasticsearch辅助插件Kibana安装"></a>3. Elasticsearch辅助插件Kibana安装</h1><p>什么是Kibana?</p><ul><li>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。</li><li>Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。</li></ul><h2 id="3-1-Kibana安装"><a href="#3-1-Kibana安装" class="headerlink" title="3.1 Kibana安装"></a>3.1 Kibana安装</h2><ol><li><p>上传kibana</p><p>CRT中克隆一个窗口，上传Kibana</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">put ‪E:\software\kibana-7.4.0-linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压kibana</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xzf kibana-7.4.0-linux-x86_64.tar.gz -C /opt<br></code></pre></td></tr></table></figure></li><li><p>修改kibana.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /opt/kibana-7.4.0-linux-x86_64/config/kibana.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server.port:</span> <span class="hljs-number">5601</span><br><span class="hljs-attr">server.host:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-attr">server.name:</span> <span class="hljs-string">&quot;kibana-itcast&quot;</span><br><span class="hljs-attr">elasticsearch.hosts:</span> [<span class="hljs-string">&quot;http://127.0.0.1:9200&quot;</span>] <span class="hljs-comment"># 因为他和es是装一个上面了，所以直接用的127.0.0.1本机ip，如果不在一个上面的话，要改成装es的那台服务器的ip</span><br><span class="hljs-attr">elasticsearch.requestTimeout:</span> <span class="hljs-number">99999</span><br></code></pre></td></tr></table></figure><p>server.port：http访问端口</p><p>server.host：ip地址，0.0.0.0表示可远程访问</p><p>server.name：kibana服务名</p><p>elasticsearch.hosts：elasticsearch地址</p><p>elasticsearch.requestTimeout：请求elasticsearch超时时间，默认为30000，此处可根据情况设置</p></li><li><p>启动kibana</p><p>由于kibana不建议使用root用户启动，如果用root启动，需要加–allow-root参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换到kibana的bin目录</span><br>cd /opt/kibana-7.4.0-linux-x86_64/bin<br><span class="hljs-meta">#</span><span class="bash"> 启动</span><br>./kibana --allow-root<br></code></pre></td></tr></table></figure></li><li><p>访问kibana</p><p>浏览器输入<a href="http://192.168.200.129:5601/">http://192.168.200.129:5601/</a></p><p><img src="/images/image-20210803000515080.png" alt="image-20210803000515080"></p><p>看到这个界面，说明Kibanan已成功安装。</p><ul><li><code>Discover</code>：可视化查询分析器</li><li><code>Visualize</code>：统计分析图表</li><li><code>Dashboard</code>：自定义主面板（添加图表）</li><li><code>Timelion</code>：Timelion是一个kibana时间序列展示组件（暂时不用）</li><li><code>Dev Tools</code>：Console控制台（同CURL/POSTER，操作ES代码工具，代码提示，很方便）</li><li><code>Management</code>：管理索引库(index)、已保存的搜索和可视化结果(save objects)、设置 kibana 服务器属性。</li></ul></li></ol><h1 id="4-ElasticSearch核心概念"><a href="#4-ElasticSearch核心概念" class="headerlink" title="4. ElasticSearch核心概念"></a>4. ElasticSearch核心概念</h1><p><strong>索引（index）</strong></p><p>ElasticSearch存储数据的地方，可以理解成关系型数据库中的数据库概念。</p><p><strong>映射（mapping）</strong></p><p>mapping定义了每个字段的类型、字段所使用的分词器等。相当于关系型数据库中的表结构。</p><p><strong>文档（document）</strong></p><p>Elasticsearch中的最小数据单元，常以json格式显示。一个document相当于关系型数据库中的一行数据。</p><p><strong>倒排索引</strong></p><p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表。</p><p><strong>类型（type）</strong></p><p>一种type就像一类表。如用户表、角色表等。在Elasticsearch7.X默认type为_doc</p><h1 id="5-脚本操作ES"><a href="#5-脚本操作ES" class="headerlink" title="5 脚本操作ES"></a>5 脚本操作ES</h1><p>使用脚本操作es一般是由运维人员来进行的</p><h2 id="5-1-RESTful风格介绍"><a href="#5-1-RESTful风格介绍" class="headerlink" title="5.1 RESTful风格介绍"></a>5.1 RESTful风格介绍</h2><ol><li>ST（Representational State Transfer），表述性状态转移，是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。就是一种定义接口的规范。</li><li>基于HTTP</li><li>参数使用XML格式定义或JSON格式定义</li><li>每一个URI代表1种资源</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：<ul><li>GET：用来获取资源</li><li>POST：用来新建资源（也可以用于更新资源）</li><li>PUT：用来更新资源</li><li>DELETE：用来删除资源</li></ul></li></ol><h2 id="5-2-操作索引"><a href="#5-2-操作索引" class="headerlink" title="5.2 操作索引"></a>5.2 操作索引</h2><ol><li><p><strong>添加索引</strong></p><p>添加goods_index索引，使用put请求(这里不是post，稍微注意下)，我这里是用postman操作的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">200.129</span>:<span class="hljs-number">9200</span>/goods_index<br></code></pre></td></tr></table></figure><p>操作成功后会看到</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;acknowledged&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;shards_acknowledged&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;goods_index&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询索引</strong></p><p>使用get请求</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//i</span>p:端口/索引名称  <span class="hljs-comment"># 查询单个索引信息</span><br>GET http:<span class="hljs-regexp">//i</span>p:端口/索引名称<span class="hljs-number">1</span>,索引名称<span class="hljs-number">2</span>  <span class="hljs-comment"># 查询多个索引信息</span><br>GET http:<span class="hljs-regexp">//i</span>p:端口/_all  <span class="hljs-comment"># 查询所有索引信息</span><br></code></pre></td></tr></table></figure></li><li><p><strong>删除索引</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">DELETE http:<span class="hljs-regexp">//i</span>p:端口/索引名称<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭及打开索引</strong></p><p>关闭是为了不想删除索引库，但是同时又不想让别人访问到，所以选择关闭。关闭之后不能往里面添加数据</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST http:<span class="hljs-regexp">//i</span>p:端口<span class="hljs-regexp">/索引名称/</span>_close  <br>POST http:<span class="hljs-regexp">//i</span>p:端口<span class="hljs-regexp">/索引名称/</span>_open <br></code></pre></td></tr></table></figure></li></ol><h2 id="5-3-ES数据类型"><a href="#5-3-ES数据类型" class="headerlink" title="5.3 ES数据类型"></a>5.3 ES数据类型</h2><ol><li><p><strong>简单数据类型</strong></p><ul><li><p>字符串</p><p>text：会分词，不支持聚合（聚合相当于mysql中的求和）</p><p>keyword：不会分词，将全部内容作为一个词条，支持聚合</p></li><li><p>数值</p></li><li><p>布尔</p><p>boolean</p></li><li><p>二进制</p><p>binary</p></li><li><p>范围类型</p><p>integer_range, float_range, long_range, double_range, date_range </p></li></ul></li><li><p><strong>复杂数据类型</strong></p><ul><li>数组：[ ] </li><li>对象：{ } </li></ul></li></ol><h2 id="5-4-操作映射"><a href="#5-4-操作映射" class="headerlink" title="5.4 操作映射"></a>5.4 操作映射</h2><p>下面的操作都是基于kibana的</p><ol><li><p><strong>添加映射</strong></p><p>先创建一个person索引</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">PUT person</span><br></code></pre></td></tr></table></figure><p>给索引添加映射</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /person/_mapping<br>&#123;<br>  <span class="hljs-attr">&quot;properties&quot;</span>:&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>:&#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;age&quot;</span>:&#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>或者用另外一种方法直接在创建索引的同时创建好映射关系</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">#创建索引并添加映射<br>PUT /person1<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;age&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>查询映射</strong></p><p>注意</p><ul><li>只用在kibana中写上查询方式以及映射名称就行了，不用写ip和端口啥的，比较方便</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">GET</span> person1/_mapping<br></code></pre></td></tr></table></figure><p>查询的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;person1&quot;</span> : &#123;# 索引名称<br>    <span class="hljs-attr">&quot;mappings&quot;</span> : &#123;# 映射<br>      <span class="hljs-attr">&quot;properties&quot;</span> : &#123;  # 映射的属性<br>        <span class="hljs-attr">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;integer&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>添加字段</strong></p><p>要是添加的是映射本来就有的，会报错，要是没有就直接添加。注意，对映射关系的修改中是没有直接删除映射的，因为这样容易产生事故</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">#添加字段<br>PUT /person1/_mapping<br>&#123;<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;age&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-5-操作文档"><a href="#5-5-操作文档" class="headerlink" title="5.5 操作文档"></a>5.5 操作文档</h2><ol><li><p><strong>添加文档以及查询文档</strong></p><p>添加文档，指定id</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /person1/_doc/<span class="hljs-number">2</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京&quot;</span><br>&#125;<br><br># 添加完毕进行查询<br>GET /person1/_doc/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person1&quot;</span>,<br>  <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>  <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2&quot;</span>,<br>  <span class="hljs-attr">&quot;_version&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;_seq_no&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;_primary_term&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;found&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;北京&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>添加文档，不指定id</p><p>注意：</p><ul><li>稍微注意下如果查特定文档时候的语句以及查所有文档语句的区别</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">#添加文档，不指定id<br>POST /person1/_doc/<br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京&quot;</span><br>&#125;<br><br>#查询所有文档<br>GET /person1/_search<br></code></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;took&quot;</span> : <span class="hljs-number">778</span>,<br>  <span class="hljs-attr">&quot;timed_out&quot;</span> : <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;skipped&quot;</span> : <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;hits&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;value&quot;</span> : <span class="hljs-number">2</span>,  # 查询到的文档数量<br>      <span class="hljs-attr">&quot;relation&quot;</span> : <span class="hljs-string">&quot;eq&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;max_score&quot;</span> : <span class="hljs-number">1.0</span>,<br>    <span class="hljs-attr">&quot;hits&quot;</span> : [<br>      &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person1&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">1.0</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;张三&quot;</span>,<br>          <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">18</span>,<br>          <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;北京&quot;</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person1&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;K5KtC3sBCY0ja69ZDmup&quot;</span>,  # 如果自己不指定文档id，系统会自动分配一个<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">1.0</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;李四&quot;</span>,<br>          <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">20</span>,<br>          <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;武汉&quot;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>修改文档</strong></p></li><li><p><strong>删除文档</strong></p><p>删除指定文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">#删除指定id文档<br>DELETE /person1/_doc/K5KtC3sBCY0ja69ZDmup<br></code></pre></td></tr></table></figure></li></ol><h1 id="6-分词器"><a href="#6-分词器" class="headerlink" title="6. 分词器"></a>6. 分词器</h1><h2 id="6-1-分词器介绍"><a href="#6-1-分词器介绍" class="headerlink" title="6.1 分词器介绍"></a>6.1 分词器介绍</h2><ul><li>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包</li><li>是一个基于Maven构建的项目</li><li>具有60万字/秒的高速处理能力</li><li>支持用户词典扩展定义</li></ul><p>下载地址（注意选择和es匹配的版本）：<a href="https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip">https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip</a> </p><h2 id="6-2-ik分词器安装"><a href="#6-2-ik分词器安装" class="headerlink" title="6.2 ik分词器安装"></a>6.2 ik分词器安装</h2><h3 id="6-2-1-环境准备"><a href="#6-2-1-环境准备" class="headerlink" title="6.2.1 环境准备"></a>6.2.1 环境准备</h3><p>Elasticsearch 要使用 ik，就要先构建 ik 的 jar包，这里要用到 maven 包管理工具，而 maven 需要java 环境，而 Elasticsearch 内置了jdk， 所以可以将JAVA_HOME设置为Elasticsearch 内置的jdk</p><ol><li><p>设置JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile<br><span class="hljs-meta">#</span><span class="bash"> 在profile文件末尾添加</span><br><span class="hljs-meta">#</span><span class="bash">java environment</span><br>export JAVA_HOME=/opt/elasticsearch-7.4.0/jdk<br>export PATH=$PATH:$&#123;JAVA_HOME&#125;/bin<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 保存退出后，重新加载profile</span><br>source /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>下载maven安装包</p><p>有的镜像可能不好用，如果失败了就换其他镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://mirror.cc.columbia.edu/pub/software/apache/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz<br>wget http://maven.aliyun.com/pub/software/apache/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>解压maven安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar xzf apache-maven-3.1.1-bin.tar.gz <br></code></pre></td></tr></table></figure></li><li><p>设置软连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s apache-maven-3.1.1 maven <br></code></pre></td></tr></table></figure></li><li><p>设置path</p><p>打开文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim  /etc/profile.d/maven.sh<br></code></pre></td></tr></table></figure><p>将下面的内容复制到文件，保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MAVEN_HOME=/opt/maven  <br>export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125; <br></code></pre></td></tr></table></figure><p>设置好Maven的路径之后，需要运行下面的命令使其生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile.d/maven.sh<br></code></pre></td></tr></table></figure></li><li><p>验证maven是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn -v<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-2-2-安装IK分词器"><a href="#6-2-2-安装IK分词器" class="headerlink" title="6.2.2 安装IK分词器"></a>6.2.2 安装IK分词器</h3><ol><li><p>下载IK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip<br></code></pre></td></tr></table></figure></li><li><p>解压IK</p><p>由于这里是zip包不是gz包，所以我们需要使用unzip命令进行解压，如果本机环境没有安装unzip，请执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install zip <br>yum install unzip<br></code></pre></td></tr></table></figure><p>解压IK</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip v7.4.0.zip<br></code></pre></td></tr></table></figure></li><li><p>编译jar包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 切换到 elasticsearch-analysis-ik-7.4.0目录</span><br>cd elasticsearch-analysis-ik-7.4.0/<br><span class="hljs-meta">#</span><span class="bash">打包</span><br>mvn package  #这里用阿里云的镜像弄，改一下配置就行了<br></code></pre></td></tr></table></figure></li><li><p> jar包移动</p></li></ol><p>   package执行完毕后会在当前目录下生成target/releases目录，将其中的elasticsearch-analysis-ik-7.4.0.zip。拷贝到elasticsearch目录下的新建的目录plugins/analysis-ik，并解压</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">切换目录</span><br>cd /opt/elasticsearch-7.4.0/plugins/<br><span class="hljs-meta">#</span><span class="bash">新建目录</span><br>mkdir analysis-ik<br>cd analysis-ik<br><span class="hljs-meta">#</span><span class="bash">执行拷贝</span><br>cp -R /opt/elasticsearch-analysis-ik-7.4.0/target/releases/elasticsearch-analysis-ik-7.4.0.zip      /opt/elasticsearch-7.4.0/plugins/analysis-ik<br><span class="hljs-meta">#</span><span class="bash">执行解压</span><br>unzip  /opt/elasticsearch-7.4.0/plugins/analysis-ik/elasticsearch-analysis-ik-7.4.0.zip<br></code></pre></td></tr></table></figure><ol start="5"><li><p>拷贝辞典</p><p>将elasticsearch-analysis-ik-7.4.0目录下的config目录中的所有文件 拷贝到elasticsearch的config目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -R /opt/elasticsearch-analysis-ik-7.4.0/config/*   /opt/elasticsearch-7.4.0/config<br></code></pre></td></tr></table></figure></li></ol><p>最后记得重启es才能生效</p><h2 id="6-3-ik分词器使用"><a href="#6-3-ik分词器使用" class="headerlink" title="6.3 ik分词器使用"></a>6.3 ik分词器使用</h2><p>IK分词器有两种分词模式：ik_max_word和ik_smart模式。</p><ol><li><p><strong>ik_max_word</strong></p><p>会将文本做最细粒度的拆分，比如会将“乒乓球明年总冠军”拆分为“乒乓球、乒乓、球、明年、总冠军、冠军。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">#方式一ik_max_word<br>GET /_analyze<br>&#123;<br>  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;乒乓球明年总冠军&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ik_max_word分词器执行如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;tokens&quot;</span> : [<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;乒乓球&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">0</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;乒乓&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;球&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_CHAR&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">2</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;明年&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">3</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;总冠军&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">8</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">4</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;冠军&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">8</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">5</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ik_smart</strong></p><p>会做最粗粒度的拆分，比如会将“乒乓球明年总冠军”拆分为乒乓球、明年、总冠军。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">#方式二ik_smart<br>GET /_analyze<br>&#123;<br>  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;乒乓球明年总冠军&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ik_smart分词器执行如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;tokens&quot;</span> : [<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;乒乓球&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">0</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;明年&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;总冠军&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">8</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-4-使用IK分词器-查询文档"><a href="#6-4-使用IK分词器-查询文档" class="headerlink" title="6.4 使用IK分词器-查询文档"></a>6.4 使用IK分词器-查询文档</h2><ul><li><p>词条查询：term</p><p>词条查询不会分析查询条件，只有当词条和查询字符串完全匹配时才匹配搜索</p></li><li><p>全文查询：match</p><p>全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集</p></li></ul><p><strong>分词案例</strong></p><ol><li><p>创建索引，添加映射，并指定分词器为ik分词器</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT person2<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /person2/_doc/<span class="hljs-number">1</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京海淀区&quot;</span><br>&#125;<br><br>POST /person2/_doc/<span class="hljs-number">2</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;李四&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京朝阳区&quot;</span><br>&#125;<br><br>POST /person2/_doc/<span class="hljs-number">3</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;王五&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京昌平区&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查询映射</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET person2<br></code></pre></td></tr></table></figure><p>查询结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;person2&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;aliases&quot;</span> : &#123; &#125;,<br>    <span class="hljs-attr">&quot;mappings&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;properties&quot;</span> : &#123;<br>        <span class="hljs-attr">&quot;address&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;text&quot;</span>,<br>          <span class="hljs-attr">&quot;analyzer&quot;</span> : <span class="hljs-string">&quot;ik_max_word&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;age&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;long&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;name&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;keyword&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">&quot;settings&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;index&quot;</span> : &#123;<br>        <span class="hljs-attr">&quot;creation_date&quot;</span> : <span class="hljs-string">&quot;1627990806608&quot;</span>,<br>        <span class="hljs-attr">&quot;number_of_shards&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-attr">&quot;number_of_replicas&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-attr">&quot;uuid&quot;</span> : <span class="hljs-string">&quot;fVX6890BS1a2WBqeFtVqoA&quot;</span>,<br>        <span class="hljs-attr">&quot;version&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;created&quot;</span> : <span class="hljs-string">&quot;7040099&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;provided_name&quot;</span> : <span class="hljs-string">&quot;person2&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看分词效果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET _analyze<br>&#123;<br>  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;北京海淀&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;tokens&quot;</span> : [<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;北京&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">0</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;京海&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">1</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;token&quot;</span> : <span class="hljs-string">&quot;海淀&quot;</span>,<br>      <span class="hljs-attr">&quot;start_offset&quot;</span> : <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;end_offset&quot;</span> : <span class="hljs-number">4</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span> : <span class="hljs-string">&quot;CN_WORD&quot;</span>,<br>      <span class="hljs-attr">&quot;position&quot;</span> : <span class="hljs-number">2</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分词器查询</p><p>5.1 词条查询（term）</p><p>查询person2中匹配到”北京”两字的词条</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /person2/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;address&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;北京昌平&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询结果</p><p>可以看见并没有查到，因为分词的时候并没有一个叫做“北京昌平”的token, 所以按照term匹配的时候并没有搜索出地址为北京昌平区的那个文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;took&quot;</span> : <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">&quot;timed_out&quot;</span> : <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;skipped&quot;</span> : <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;hits&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;value&quot;</span> : <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">&quot;relation&quot;</span> : <span class="hljs-string">&quot;eq&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;max_score&quot;</span> : <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">&quot;hits&quot;</span> : [ ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>5.2 全文查询 (match)</p><p>全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /person2/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;北京昌平&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;took&quot;</span> : <span class="hljs-number">22</span>,<br>  <span class="hljs-attr">&quot;timed_out&quot;</span> : <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;_shards&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;successful&quot;</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;skipped&quot;</span> : <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;failed&quot;</span> : <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;hits&quot;</span> : &#123;<br>    <span class="hljs-attr">&quot;total&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;value&quot;</span> : <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;relation&quot;</span> : <span class="hljs-string">&quot;eq&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;max_score&quot;</span> : <span class="hljs-number">1.1505673</span>,<br>    <span class="hljs-attr">&quot;hits&quot;</span> : [<br>      &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person2&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;3&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">1.1505673</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;王五&quot;</span>,<br>          <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">18</span>,<br>          <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;北京昌平区&quot;</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person2&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">0.13786995</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;李四&quot;</span>,<br>          <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">18</span>,<br>          <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;北京朝阳区&quot;</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;person2&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">0.12562492</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;张三&quot;</span>,<br>          <span class="hljs-attr">&quot;age&quot;</span> : <span class="hljs-number">18</span>,<br>          <span class="hljs-attr">&quot;address&quot;</span> : <span class="hljs-string">&quot;北京海淀区&quot;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="7-ElasticSearch-JavaApi"><a href="#7-ElasticSearch-JavaApi" class="headerlink" title="7. ElasticSearch JavaApi"></a>7. ElasticSearch JavaApi</h1><p>开发人员一般使用这部分知识比较多。一般是操作文档，对于索引和映射一般都是通过脚本提前创建好了的</p><h2 id="7-1-SpringBoot整合ES"><a href="#7-1-SpringBoot整合ES" class="headerlink" title="7.1 SpringBoot整合ES"></a>7.1 SpringBoot整合ES</h2><ol><li><p>搭建SpringBoot工程</p></li><li><p>引入ElasticSearch相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入es的坐标--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置es的yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">elasticsearch:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.129</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9200</span><br></code></pre></td></tr></table></figure></li><li><p>配置ES客户端的测试类，用于获得es的客户端对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;elasticsearch&quot;)</span> <span class="hljs-comment">//读取配置文件中前缀为elasticsearch的属性值，并在程序启动的时候自动将这些属性注入到这个配置类中对应的成员变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticSearchConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String host;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHost</span><span class="hljs-params">(String host)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br>    <span class="hljs-comment">//创建es客户端对象</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">client</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                <span class="hljs-keyword">new</span> HttpHost(host,port,<span class="hljs-string">&quot;http&quot;</span>)<br>        ));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在测试类中测试是否能注入RestHighLevelClient 对象</p><p>如果能打印出对象的信息说明整个过程是成功的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElasticsearchApplicationTests</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestHighLevelClient client;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(client);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-2-操作索引"><a href="#7-2-操作索引" class="headerlink" title="7.2 操作索引"></a>7.2 操作索引</h2><h3 id="7-2-1-添加索引"><a href="#7-2-1-添加索引" class="headerlink" title="7.2.1 添加索引"></a>7.2.1 添加索引</h3><ol><li><p>添加索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加索引</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//1.使用client获取操作索引对象</span><br>IndicesClient indices = client.indices();<br>   <br><span class="hljs-comment">//2.具体操作获取返回值</span><br><span class="hljs-comment">//2.1 设置索引名称</span><br>CreateIndexRequest createIndexRequest=<span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;itheima1&quot;</span>);<br>CreateIndexResponse createIndexResponse = indices.create(createIndexRequest, RequestOptions.DEFAULT);<br>   <br><span class="hljs-comment">//3.根据返回值判断结果</span><br>System.out.println(createIndexResponse.isAcknowledged());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加索引，并添加映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加索引，并添加映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addIndexAndMapping</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//1.使用client获取操作索引对象</span><br>IndicesClient indices = client.indices();<br><span class="hljs-comment">//2.具体操作获取返回值</span><br><span class="hljs-comment">//2.具体操作，获取返回值</span><br>CreateIndexRequest createIndexRequest = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;itcast1&quot;</span>);<br><span class="hljs-comment">//2.1 设置mappings</span><br>String mapping = <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br><span class="hljs-string">&quot;      \&quot;properties\&quot; : &#123;\n&quot;</span> +<br><span class="hljs-string">&quot;        \&quot;address\&quot; : &#123;\n&quot;</span> +<br><span class="hljs-string">&quot;          \&quot;type\&quot; : \&quot;text\&quot;,\n&quot;</span> +<br><span class="hljs-string">&quot;          \&quot;analyzer\&quot; : \&quot;ik_max_word\&quot;\n&quot;</span> +<br><span class="hljs-string">&quot;        &#125;,\n&quot;</span> +<br><span class="hljs-string">&quot;        \&quot;age\&quot; : &#123;\n&quot;</span> +<br><span class="hljs-string">&quot;          \&quot;type\&quot; : \&quot;long\&quot;\n&quot;</span> +<br><span class="hljs-string">&quot;        &#125;,\n&quot;</span> +<br><span class="hljs-string">&quot;        \&quot;name\&quot; : &#123;\n&quot;</span> +<br><span class="hljs-string">&quot;          \&quot;type\&quot; : \&quot;keyword\&quot;\n&quot;</span> +<br><span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br><span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br><span class="hljs-string">&quot;    &#125;&quot;</span>;<br>createIndexRequest.mapping(mapping, XContentType.JSON);<br><br>CreateIndexResponse createIndexResponse = indices.create(createIndexRequest, RequestOptions.DEFAULT);<br><span class="hljs-comment">//3.根据返回值判断结果</span><br>System.out.println(createIndexResponse.isAcknowledged());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-2-2-查询、删除、判断索引"><a href="#7-2-2-查询、删除、判断索引" class="headerlink" title="7.2.2 查询、删除、判断索引"></a>7.2.2 查询、删除、判断索引</h3><p>查询索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询索引</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>IndicesClient indices = client.indices();<br><br>GetIndexRequest getRequest=<span class="hljs-keyword">new</span> GetIndexRequest(<span class="hljs-string">&quot;itcast&quot;</span>);<br>GetIndexResponse response = indices.get(getRequest, RequestOptions.DEFAULT);<br>Map&lt;String, MappingMetaData&gt; mappings = response.getMappings();<br><span class="hljs-comment">//iter 提示foreach</span><br><span class="hljs-keyword">for</span> (String key : mappings.keySet()) &#123;<br>System.out.println(key+<span class="hljs-string">&quot;===&quot;</span>+mappings.get(key).getSourceAsMap());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除索引</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>IndicesClient indices = client.indices();<br>DeleteIndexRequest deleteRequest=<span class="hljs-keyword">new</span> DeleteIndexRequest(<span class="hljs-string">&quot;itheima&quot;</span>);<br>AcknowledgedResponse delete = indices.delete(deleteRequest, RequestOptions.DEFAULT);<br>System.out.println(delete.isAcknowledged());<br>&#125;<br></code></pre></td></tr></table></figure><p>判断索引是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 索引是否存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">existIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>IndicesClient indices = client.indices();<br><br>GetIndexRequest getIndexRequest=<span class="hljs-keyword">new</span> GetIndexRequest(<span class="hljs-string">&quot;itheima&quot;</span>);<br><span class="hljs-keyword">boolean</span> exists = indices.exists(getIndexRequest, RequestOptions.DEFAULT);<br><br>System.out.println(exists);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-操作文档"><a href="#7-3-操作文档" class="headerlink" title="7.3 操作文档"></a>7.3 操作文档</h2><h3 id="7-3-1-添加文档"><a href="#7-3-1-添加文档" class="headerlink" title="7.3.1 添加文档"></a>7.3.1 添加文档</h3><ol><li><p>添加文档,使用map作为数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDoc1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Map&lt;String, Object&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;北京二环&quot;</span>);<br>IndexRequest request=<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;itcast1&quot;</span>).id(<span class="hljs-string">&quot;1&quot;</span>).source(map);<br>IndexResponse response = client.index(request, RequestOptions.DEFAULT);<br>System.out.println(response.getId());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加文档,使用对象作为数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addDoc2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Person person=<span class="hljs-keyword">new</span> Person();<br>person.setId(<span class="hljs-string">&quot;2&quot;</span>);<br>person.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>person.setAge(<span class="hljs-number">20</span>);<br>person.setAddress(<span class="hljs-string">&quot;北京三环&quot;</span>);<br>String data = JSON.toJSONString(person);<br>IndexRequest request=<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;itcast1&quot;</span>).id(person.getId()).source(data,XContentType.JSON);<br>IndexResponse response = client.index(request, RequestOptions.DEFAULT);<br>System.out.println(response.getId());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-2-修改、查询、删除文档"><a href="#7-3-2-修改、查询、删除文档" class="headerlink" title="7.3.2 修改、查询、删除文档"></a>7.3.2 修改、查询、删除文档</h3><ol><li><p>修改文档：添加文档时，如果id存在则修改，id不存在则添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Person person=<span class="hljs-keyword">new</span> Person();<br>person.setId(<span class="hljs-string">&quot;2&quot;</span>);<br>person.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br>person.setAge(<span class="hljs-number">20</span>);<br>person.setAddress(<span class="hljs-string">&quot;北京三环车王&quot;</span>);<br>   <br>String data = JSON.toJSONString(person);<br>   <br>IndexRequest request=<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;itcast1&quot;</span>).id(person.getId()).source(data,XContentType.JSON);<br>IndexResponse response = client.index(request, RequestOptions.DEFAULT);<br>System.out.println(response.getId());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>根据id查询文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id查询文档</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>   <br>    <span class="hljs-comment">//设置查询的索引、文档</span><br>    GetRequest indexRequest=<span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;itcast&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);<br>   <br>    GetResponse response = client.get(indexRequest, RequestOptions.DEFAULT);<br>    System.out.println(response.getSourceAsString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>根据id删除文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id删除文档</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>   <br><span class="hljs-comment">//设置要删除的索引、文档</span><br>DeleteRequest deleteRequest=<span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;itcast&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>   <br>DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT);<br>System.out.println(response.getId());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix</title>
    <link href="/2021/08/01/4.%20Hystrix%20%E7%86%94%E6%96%AD%E5%99%A8/"/>
    <url>/2021/08/01/4.%20Hystrix%20%E7%86%94%E6%96%AD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Hystrix-概述"><a href="#1-Hystrix-概述" class="headerlink" title="1. Hystrix 概述"></a>1. <strong>Hystrix</strong> 概述</h1><ul><li>Hystix 是 Netflix 开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败（雪崩: 一个服务失败，导致整条链路的服务都失败的情形）。</li></ul><p>Hystix 主要功能</p><ol><li>隔离<ol><li>线程池隔离 （对要请求的微服务设置可使用的线程数，这样不会导致一个微服务占用所有线程）</li><li>信号量隔离</li></ol></li><li>降级 （对异常提供降级方案，出现异常了就调用降级方案）</li><li>熔断</li><li>限流</li></ol><h2 id="1-1-Hystrix-降级"><a href="#1-1-Hystrix-降级" class="headerlink" title="1.1 Hystrix 降级"></a>1.1 <strong>Hystrix</strong> <strong>降级</strong></h2><p>Hystix 降级：当服务发生异常或调用超时，返回默认数据</p><p><img src="/images/image-20210801232052828.png" alt="image-20210801232052828"></p><h3 id="1-1-1-服务提供方"><a href="#1-1-1-服务提供方" class="headerlink" title="1.1.1 服务提供方"></a>1.1.1 服务提供方</h3><ol><li><p>在服务提供方，引入hystrix依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- hystrix --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在服务提供方的启动类上开启hystrix功能<code>@EnableCircuitBreaker</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span> <span class="hljs-comment">//该注解 在新版本中可以省略</span><br><span class="hljs-meta">@SpringBootApplication</span><br><br><span class="hljs-meta">@EnableCircuitBreaker</span> <span class="hljs-comment">// 开启Hystrix功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApp</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ProviderApp.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对要被消费者调用的方法定义降级方法</p><p>注意： </p><ul><li>使用注解<code>@HystrixCommand(fallbackMethod = &quot;findOne_fallback&quot;)</code>指定降级方法</li><li>定义降级方法注意事项<ul><li>方法的返回值需要和原方法一样</li><li>方法的参数需要和原方法一样</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Goods Controller 服务提供方</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/goods&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> GoodsService goodsService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 降级：</span><br><span class="hljs-comment">     *  1. 出现异常</span><br><span class="hljs-comment">     *  2. 服务调用超时</span><br><span class="hljs-comment">     *      * 默认1s超时</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@HystrixCommand</span>(fallbackMethod = &quot;findOne_fallback&quot;)</span><br><span class="hljs-comment">     *      fallbackMethod：指定降级后调用的方法名称</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/findOne/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;findOne_fallback&quot;,commandProperties = &#123;</span><br><span class="hljs-meta">            //设置Hystrix的超时时间，默认1s</span><br><span class="hljs-meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findOne</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br><br>        <span class="hljs-comment">//1.造个异常</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//2. 休眠2秒</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Goods goods = goodsService.findOne(id);<br><br>        goods.setTitle(goods.getTitle() + <span class="hljs-string">&quot;:&quot;</span> + port);<span class="hljs-comment">//将端口号，设置到了 商品标题上</span><br>        <span class="hljs-keyword">return</span> goods;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义降级方法：</span><br><span class="hljs-comment">     *  1. 方法的返回值需要和原方法一样</span><br><span class="hljs-comment">     *  2. 方法的参数需要和原方法一样</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findOne_fallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        Goods goods = <span class="hljs-keyword">new</span> Goods();<br>        goods.setTitle(<span class="hljs-string">&quot;降级了~~~&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> goods;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-1-2-服务消费方"><a href="#1-1-2-服务消费方" class="headerlink" title="1.1.2 服务消费方"></a>1.1.2 服务消费方</h3><ol><li><p>因为feign组件中已经集成了hystrix组件，所以hytrix的依赖就不用导入了</p></li><li><p>配置yml文件，开启feign对hystrix的支持</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 开启feign对hystrix的支持</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>定义feign 调用接口实现类，复写方法，即 降级方法</p><p>注意：</p><ul><li>降级类要实现<code>GoodsFeignClient</code>接口</li><li>记得将这个降级类放到spring容器中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Feign 客户端的降级处理类</span><br><span class="hljs-comment"> * 1. 定义类 实现 Feign 客户端接口</span><br><span class="hljs-comment"> * 2. 使用<span class="hljs-doctag">@Component</span>注解将该类的Bean加入SpringIOC容器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GoodsFeignClient</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        Goods goods = <span class="hljs-keyword">new</span> Goods();<br>        goods.setTitle(<span class="hljs-string">&quot;又被降级了~~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> goods;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 @FeignClient 注解中使用 fallback 属性设置刚编写的降级处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;HYSTRIX-PROVIDER&quot;,fallback = GoodsFeignClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GoodsFeignClient</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@GetMapping(&quot;/goods/findOne/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-2-Hystrix熔断"><a href="#1-2-Hystrix熔断" class="headerlink" title="1.2 Hystrix熔断"></a>1.2 Hystrix熔断</h2><p>Hystrix 熔断机制，用于监控微服务调用情况，当失败的情况达到预定的阈值（5秒失败20次），会打开断路器，拒绝所有请求（全都降级），直到服务恢复正常为止。</p><p>断路器状态改变图：</p><p>连续调用服务方的方法出现异常或连接超时导致服务降级时，若达到预定的阈值，断路器打开，此时无论请求是否正常都会提供降级方法给消费方。等到默认开启时间结束，断路器会转变为半开状态，这时会放过来一个请求，如果调用成功，断路器关闭；反之断路器会再次打开。</p><p><img src="/images/image-20210802212254669.png" alt="image-20210802212254669"></p><p>在1.1配置hystrix时，已经有了默认参数的熔断机制，不需要自己额外编写代码。</p><p>在服务提供方的方法上可以改变熔断机制的一些默认参数</p><p>到时候如果要改的话，参照下面<code>@HystrixProperty</code>注解代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/findOne/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;findOne_fallback&quot;,commandProperties = &#123;</span><br><span class="hljs-meta">        //设置Hystrix的超时时间，默认1s</span><br><span class="hljs-meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;),</span><br><span class="hljs-meta">        //监控时间 默认5000 毫秒</span><br><span class="hljs-meta">        @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;5000&quot;),</span><br><span class="hljs-meta">        //失败次数。默认20次</span><br><span class="hljs-meta">        @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;20&quot;),</span><br><span class="hljs-meta">        //失败率 默认50%</span><br><span class="hljs-meta">        @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;50&quot;)</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findOne</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br><br>    <span class="hljs-comment">//如果id == 1 ，则出现异常，id != 1 则正常访问</span><br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//1.造个异常</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*try &#123;</span><br><span class="hljs-comment">        //2. 休眠2秒</span><br><span class="hljs-comment">        Thread.sleep(2000);</span><br><span class="hljs-comment">    &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">        e.printStackTrace();</span><br><span class="hljs-comment">    &#125;*/</span><br>    Goods goods = goodsService.findOne(id);<br><br>    goods.setTitle(goods.getTitle() + <span class="hljs-string">&quot;:&quot;</span> + port);<span class="hljs-comment">//将端口号，设置到了 商品标题上</span><br>    <span class="hljs-keyword">return</span> goods;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-hystrix熔断监控"><a href="#1-3-hystrix熔断监控" class="headerlink" title="1.3 hystrix熔断监控"></a>1.3 hystrix熔断监控</h2><ul><li><p>Hystrix 提供了 Hystrix-dashboard 功能，用于实时监控微服务运行状态。</p></li><li><p>但是Hystrix-dashboard只能监控一个微服务。</p></li><li><p>Netflix 还提供了 Turbine ，进行聚合监控。</p></li></ul><p>这部分不详细展开了，需要用的时候去查对应博客</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Feign声明式服务调用</title>
    <link href="/2021/08/01/3.%20Feign/"/>
    <url>/2021/08/01/3.%20Feign/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Feign-概述"><a href="#1-Feign-概述" class="headerlink" title="1. Feign 概述"></a>1. Feign 概述</h1><ul><li>Feign 是一个声明式的 REST 客户端，它用了基于接口的注解方式，很方便实现客户端配置。是简化了 RestTemplate+Ribbon 一个组件</li><li>Feign 最初由 Netflix 公司提供，但不支持SpringMVC注解，后由 SpringCloud 对其封装，支持了SpringMVC注解，让使用者更易于接受。</li></ul><h1 id="2-Feign-快速入门"><a href="#2-Feign-快速入门" class="headerlink" title="2. Feign 快速入门"></a>2. <strong>Feign</strong> <strong>快速入门</strong></h1><p>基础的环境搭好了，主要研究feign的部分。如果想要了解完整过程可以查看本地笔记</p><ol><li><p>在消费端引入 open-feign 依赖 (消费端指的是 Service Consumer)</p><p><img src="/images/image-20210801205806595.png" alt="image-20210801205806595"></p><p><img src="/images/image-20210801211807913.png" alt="image-20210801211807913"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--feign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写Feign接口调用</p><p>创建包feign用于存放GoodsFeignClient接口</p><p><img src="/images/image-20210801212031590.png" alt="image-20210801212031590"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * feign声明式接口。发起远程调用的。</span><br><span class="hljs-comment"> * 代替了 RestTemplate+Ribbon 的下面两行代码</span><br><span class="hljs-comment"> * String url = &quot;http://FEIGN-PROVIDER/goods/findOne/&quot;+id;</span><br><span class="hljs-comment"> * Goods goods = restTemplate.getForObject(url, Goods.class);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. 定义接口</span><br><span class="hljs-comment"> * 2. 接口上添加注解 <span class="hljs-doctag">@FeignClient</span>,设置value属性为 服务提供者的 应用名称</span><br><span class="hljs-comment"> * 3. 编写调用接口，接口的声明规则 和 提供方接口保持一致。</span><br><span class="hljs-comment"> * 4. 注入该接口对象，调用接口方法完成远程调用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@FeignClient(value = &quot;FEIGN-PROVIDER&quot;)</span>  <span class="hljs-comment">//这里的value是provider在注册中心的名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GoodsFeignClient</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@GetMapping(&quot;/goods/findOne/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在controller类中注入刚定义好的接口，在需要使用其他微服务的地方调用接口中相应的方法</p><p>这里就是在order微服务中调用了goods微服务的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> GoodsFeignClient goodsFeignClient;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/goods/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>&#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        String url = &quot;http://FEIGN-PROVIDER/goods/findOne/&quot;+id;</span><br><span class="hljs-comment">        // 3. 调用方法</span><br><span class="hljs-comment">        Goods goods = restTemplate.getForObject(url, Goods.class);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        return goods;*/</span><br><br>        Goods goods = goodsFeignClient.findGoodsById(id);<br><br>        <span class="hljs-keyword">return</span> goods;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在启动类 添加 @EnableFeignClients 注解，开启Feign功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 激活DiscoveryClient</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">//开启Feign的功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApp</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApp.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试调用</p><p>输入服务消费方的对应url调用服务提供方的方法</p></li></ol><h1 id="3-Feign-其他功能"><a href="#3-Feign-其他功能" class="headerlink" title="3. Feign 其他功能"></a>3. <strong>Feign</strong> <strong>其他功能</strong></h1><h2 id="3-1-超时设置"><a href="#3-1-超时设置" class="headerlink" title="3.1 超时设置"></a>3.1 超时设置</h2><ul><li><p>Feign 底层依赖于 Ribbon 实现负载均衡和远程调用。</p></li><li><p>Ribbon默认1秒超时。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 设置Ribbon的超时时间</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 连接超时时间 默认1s</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment"># 逻辑处理的超时时间 默认1s</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-2-日志记录"><a href="#3-2-日志记录" class="headerlink" title="3.2 日志记录"></a>3.2 日志记录</h2><ul><li>Feign 只能记录 debug 级别的日志信息</li></ul><p>具体用法先不掌握，需要时去搜相应博客</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2021/07/30/2.%20RabbitMQ/"/>
    <url>/2021/07/30/2.%20RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="1-消息中间件概述"><a href="#1-消息中间件概述" class="headerlink" title="1. 消息中间件概述"></a>1. 消息中间件概述</h1><h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p>MQ全称为Message Queue（消息队列），消息队列在分布式系统开发中应用非常广泛</p><p>消息队列是应用程序和应用程序之间的通信方法</p><ul><li><p>使用MQ的原因</p><p>在项目中，可将一些无需即时返回且耗时的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高</strong>了<strong>系统</strong>的<strong>吞吐量</strong></p></li><li><p>开发中消息队列通常有如下应用场景：</p><ol><li><p>任务<strong>异步</strong>处理</p><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间</p></li><li><p>应用程序<strong>解耦合</strong></p><p>生产方通过MQ与消费方交互，它将应用程序进行解耦合</p></li><li><p><strong>削峰填谷</strong></p><p>如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。</p><p>如果使用MQ, 消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。</p><p><img src="/images/image-20210730231412854.png" alt="image-20210730231412854"></p><p>但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷”</p><img src="/images/image-20210730231500453.png"  style="zoom:80%;" /></li></ol></li></ul><h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2 AMQP 和 JMS"></a>1.2 AMQP 和 JMS</h2><p>实现MQ的大致有两种主流方式：AMQP、JMS</p><ul><li>AMQP（Advanced Message Queue 高级消息队列协议）是一种协议, 直接定义网络交换的数据格式, 不规定实现方式，是跨语言的</li><li>JMS即Java消息服务（JavaMessage Service）是应用程序接口, 必须使用Java语言</li></ul><p>基于这两种方式的消息队列产品</p><ul><li>ActiveMQ：基于JMS</li><li>ZeroMQ：基于C语言开发</li><li><strong>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</strong></li><li>RocketMQ：基于JMS，阿里巴巴产品</li><li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li></ul><h2 id="1-3-RabbitMQ"><a href="#1-3-RabbitMQ" class="headerlink" title="1.3 RabbitMQ"></a>1.3 RabbitMQ</h2><p>RabbitMQ官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p><p>RabbitMQ提供了7种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式，Publisher Confirms（远程调用，不太算MQ，暂不作介绍, 用到再去查博客；Publisher Confirms也暂不介绍，有需要再查博客）</p><h1 id="2-安装及配置RabbitMQ"><a href="#2-安装及配置RabbitMQ" class="headerlink" title="2. 安装及配置RabbitMQ"></a>2. 安装及配置RabbitMQ</h1><ol><li><p>在线安装依赖环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz<br></code></pre></td></tr></table></figure></li><li><p>安装Erlang</p><p>首先需要下载一个 <code>erlang-18.3-1.el7.centos.x86_64.rpm </code>文件 (版本根据网上的推荐来选，这个可能有点旧了)，然后进行安装 </p><p>注意：</p><ul><li>这个过程可能会报错，到时候根据错误查看本地文档或者上网查找相关博客来解决</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm<br></code></pre></td></tr></table></figure></li><li><p>安装RabbitMQ</p><p>需要提前把<code>socat-1.7.3.2-5.el7.lux.x86_64.rpm</code>, <code>rabbitmq-server-3.6.5-1.noarch.rpm</code>给下载好。（建议这三个rpm文件下载在一个命名为rabbitmq的文件夹。这里的版本根据需要选择）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 安装</span><br>rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm<br></code></pre></td></tr></table></figure><p>到这里就安装完成了</p></li><li><p>然后开启管理界面及配置</p><p>注意：</p><ul><li>第一步如果想要开启管理界面是必须操作的</li><li>第二步如果信息保持默认的话也可以不改，如果需要改相关信息，去网上搜相关博客</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 开启管理界面</span><br>rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br><span class="hljs-comment"># 修改默认配置信息, 比如修改密码、配置等等</span><br>vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app <br></code></pre></td></tr></table></figure></li><li><p>启动和关闭</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">service rabbitmq-server start <span class="hljs-comment"># 启动服务</span><br>service rabbitmq-server stop <span class="hljs-comment"># 停止服务</span><br>service rabbitmq-server restart <span class="hljs-comment"># 重启服务</span><br></code></pre></td></tr></table></figure></li></ol><p>RabbitMQ在配置好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码</p><p><img src="/images/image-20210730234122057.png" alt="image-20210730234122057"></p><p>(关于配置虚拟主机和用户这里的知识就先不介绍，需要的话去网上查询详细博客)</p><h1 id="3-AMQP"><a href="#3-AMQP" class="headerlink" title="3. AMQP"></a>3. AMQP</h1><h2 id="3-1-相关概念介绍"><a href="#3-1-相关概念介绍" class="headerlink" title="3.1. 相关概念介绍"></a>3.1. 相关概念介绍</h2><p>AMQP  一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p><p>AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。</p><p>RabbitMQ是AMQP协议的Erlang的实现。</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>连接Connection</td><td>一个网络连接，比如TCP/IP套接字连接。</td></tr><tr><td>会话Session</td><td>端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。</td></tr><tr><td>信道Channel</td><td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td></tr><tr><td>客户端Client</td><td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td></tr><tr><td>服务节点Broker</td><td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td></tr><tr><td>端点</td><td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td></tr><tr><td>消费者Consumer</td><td>一个从消息队列里请求消息的客户端程序。</td></tr><tr><td>生产者Producer</td><td>一个向交换机发布消息的客户端应用程序。</td></tr></tbody></table><h2 id="3-2-RabbitMQ运转流程"><a href="#3-2-RabbitMQ运转流程" class="headerlink" title="3.2 RabbitMQ运转流程"></a>3.2 RabbitMQ运转流程</h2><p>在入门案例中：</p><ul><li><p>生产者发送消息</p><ol><li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li><li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li><li>将路由键（空字符串）与队列绑定起来；</li><li>发送消息至RabbitMQ Broker；</li><li>关闭信道；</li><li>关闭连接；</li></ol></li><li><p>消费者接收消息</p><ol><li><p>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</p></li><li><p>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</p></li><li><p>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</p></li><li><p>确认（ack，自动确认）接收到的消息；</p></li><li><p>RabbitMQ从队列中删除相应已经被确认的消息；</p></li><li><p>关闭信道；</p></li><li><p>关闭连接；</p><p><img src="/images/image-20210731135723102.png" alt="image-20210731135723102"></p></li></ol></li></ul><h1 id="4-RabbitMQ入门"><a href="#4-RabbitMQ入门" class="headerlink" title="4. RabbitMQ入门"></a>4. RabbitMQ入门</h1><h2 id="4-1-HelloWorld简单模式"><a href="#4-1-HelloWorld简单模式" class="headerlink" title="4.1 HelloWorld简单模式"></a>4.1 HelloWorld简单模式</h2><p>这个入门工程就是一个<strong>简单模式 HelloWorld</strong></p><ol><li><p>创建工程</p></li><li><p>向pom.xml文件中添加依赖</p><p>注意：</p><ul><li><p>有可能报这个错，如果报了的话再加第二个包</p><p><img src="/images/image-20210730235828100-1627661205170.png" alt="image-20210730235828100"></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-nop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>   <br></code></pre></td></tr></table></figure></li><li><p>编写生产者Producer</p><p>注意：</p><ul><li><p>这里的虚拟主机名称不能乱设置，不然可能会报错，rabbitmq默认的是<code>\</code></p><p><img src="/images/image-20210731000917757.png" alt="image-20210731000917757"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;simple_queue&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">//主机地址;默认为 localhost</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;192.168.200.128&quot;</span>);<br>        <span class="hljs-comment">//连接端口;默认为 5672</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//虚拟主机名称;默认为 /</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">//连接用户名；默认为guest</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        <span class="hljs-comment">//连接密码；默认为guest</span><br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = connectionFactory.newConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">// 要发送的信息</span><br>        String message = <span class="hljs-string">&quot;你好；小兔子！&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息</p></li></ol><p><img src="/images/image-20210731001205411.png" alt="image-20210731001205411"></p><ol start="4"><li><p>编写消费者</p><p>由于连接部分都是相同的操作，我们把它抽取成工具类ConnectionUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        <span class="hljs-comment">//主机地址;默认为 localhost</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;192.168.200.128&quot;</span>);<br>        <span class="hljs-comment">//连接端口;默认为 5672</span><br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        <span class="hljs-comment">//虚拟主机名称;默认为 /</span><br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">//连接用户名；默认为guest</span><br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        <span class="hljs-comment">//连接密码；默认为guest</span><br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> connectionFactory.newConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写消息的消费者Consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, consumer);<br><br>        <span class="hljs-comment">//不关闭资源，应该一直监听消息</span><br>        <span class="hljs-comment">//channel.close();</span><br>        <span class="hljs-comment">//connection.close();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>小结</strong>  </p><p>上述的入门案例中中其实使用的是如下的简单模式：</p><p><img src="/images/image-20210731002649177.png" alt="image-20210731002649177"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><h2 id="4-2-Work-queues工作队列模式"><a href="#4-2-Work-queues工作队列模式" class="headerlink" title="4.2 Work queues工作队列模式"></a>4.2 Work queues工作队列模式</h2><p>模式说明</p><p><img src="/images/image-20210731133440033.png" alt="image-20210731133440033"></p><p><code>Work Queues</code>与入门程序的<code>简单模式</code>相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。</p><p><strong>应用场景</strong>：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。(多安排几个消费者去消费生产者的消息)</p><p>代码和简单模式几乎一样，除了要多一个或几个消费者（基础环境和简单模式相同，这里就不赘叙了）：</p><ol><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME = <span class="hljs-string">&quot;work_queue&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span> ; i++) &#123;<br>            <span class="hljs-comment">//发送信息</span><br>            String message = <span class="hljs-string">&quot;你好；小兔子！work模式--&quot;</span> + i;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">             * 参数3：消息其它属性</span><br><span class="hljs-comment">             * 参数4：消息内容</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-keyword">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br>        <span class="hljs-comment">// 创建频道</span><br>       <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();<br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//一次只能接收并处理一个消息</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//路由key</span><br>                    System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                    <span class="hljs-comment">//交换机</span><br>                    System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                    <span class="hljs-comment">//消息id</span><br>                    System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                    <span class="hljs-comment">//收到的消息</span><br>                    System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">//确认消息, 这里确认是因为下面没有设置消息自动确认</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);<br><br>        <span class="hljs-comment">//不关闭资源，应该一直监听消息</span><br>        <span class="hljs-comment">//channel.close();</span><br>        <span class="hljs-comment">//connection.close();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        <span class="hljs-keyword">final</span> Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//一次只能接收并处理一个消息</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//路由key</span><br>                    System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                    <span class="hljs-comment">//交换机</span><br>                    System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                    <span class="hljs-comment">//消息id</span><br>                    System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                    <span class="hljs-comment">//收到的消息</span><br>                    System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">//确认消息</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.QUEUE_NAME, <span class="hljs-keyword">false</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息</p><p><img src="/images/image-20210731225717102.png" alt="image-20210731225717102"></p><p><img src="/images/image-20210731225747964.png" alt="image-20210731225747964"></p></li></ol><p>在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是<strong>竞争</strong>的关系</p><h2 id="4-3-Publish-Subscribe发布与订阅模式"><a href="#4-3-Publish-Subscribe发布与订阅模式" class="headerlink" title="4.3 Publish/Subscribe发布与订阅模式"></a>4.3 Publish/Subscribe发布与订阅模式</h2><p>前面2个案例中，只有3个角色：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列</li></ul><p>而在Publish/Subscribe模型中，多了一个exchange角色，而且过程略有变化：</p><p><img src="/images/image-20210731230311829-1627743833934.png" alt="image-20210731230311829"></p><ul><li>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>C：消费者，消息的接受者，会一直等待消息到来。</li><li>Queue：消息队列，接收消息、缓存消息。</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>Publish/Subscribe模式：</p><ol><li>每个消费者监听自己的队列。</li><li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</li></ol><p>代码：</p><ol><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发布与订阅使用的交换机类型为：fanout</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_EXCHAGE = <span class="hljs-string">&quot;fanout_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_QUEUE_1 = <span class="hljs-string">&quot;fanout_queue_1&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FANOUT_QUEUE_2 = <span class="hljs-string">&quot;fanout_queue_2&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        channel.queueDeclare(FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br>        channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">// 发送信息</span><br>            String message = <span class="hljs-string">&quot;你好；小兔子！发布订阅模式--&quot;</span> + i;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">             * 参数3：消息其它属性</span><br><span class="hljs-comment">             * 参数4：消息内容</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.FANOUT_QUEUE_1, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHAGE, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.FANOUT_QUEUE_2, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>启动所有消费者，然后使用生产者发送消息；在每个消费者对应的控制台可以查看到生产者发送的所有消息；到达<strong>广播</strong>的效果。</p><p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>fanout_exchange</code> 的交换机，可以查看到如下的绑定：</p><p><img src="/images/image-20210731232129945.png" alt="image-20210731232129945"></p></li></ol><p>小结：交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p><h2 id="4-4-Routing路由模式"><a href="#4-4-Routing路由模式" class="headerlink" title="4.4. Routing路由模式"></a>4.4. Routing路由模式</h2><p><strong>模式说明</strong></p><p>路由模式特点：</p><ul><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</p></li><li><p>消息的发送方在向Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</p></li><li><p>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</p><p><img src="/images/image-20210731232559366.png" alt="image-20210731232559366"></p></li></ul><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><p><strong>代码演示</strong></p><p>在编码上与 <code>Publish/Subscribe发布与订阅模式</code> 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。</p><ol><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 路由模式的交换机类型为：direct</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_EXCHAGE = <span class="hljs-string">&quot;direct_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_QUEUE_INSERT = <span class="hljs-string">&quot;direct_queue_insert&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DIRECT_QUEUE_UPDATE = <span class="hljs-string">&quot;direct_queue_update&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>        channel.queueDeclare(DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>);<br>        channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        String message = <span class="hljs-string">&quot;新增了商品。路由模式；routing key 为 insert &quot;</span> ;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;修改了商品。路由模式；routing key 为 update&quot;</span> ;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="hljs-comment">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="hljs-comment">         * 参数3：消息其它属性</span><br><span class="hljs-comment">         * 参数4：消息内容</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHAGE, <span class="hljs-string">&quot;insert&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.DIRECT_QUEUE_INSERT, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHAGE, <span class="hljs-string">&quot;update&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达<strong>按照需要接收</strong>的效果。</p><p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>direct_exchange</code> 的交换机，可以查看到如下的绑定：</p><p><img src="/images/image-20210731233707317.png" alt="image-20210731233707317"></p></li></ol><p>小结：Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列</p><h2 id="4-5-Topics通配符模式"><a href="#4-5-Topics通配符模式" class="headerlink" title="4.5 Topics通配符模式"></a>4.5 Topics通配符模式</h2><p><strong>模式说明</strong></p><p><code>Topic</code>类型与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>。</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.insert.abc</code> 或者 <code>item.insert</code></li><li><code>item.*</code>：只能匹配<code>item.insert</code></li></ul><p><img src="/images/image-20210731234158546.png" alt="image-20210731234158546"></p><p><strong>代码</strong> </p><ol><li> 生产者</li></ol><p>   本例使用topic类型的Exchange，发送消息的routing key有3种： <code>item.insert</code>、<code>item.update</code>、<code>item.delete</code></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通配符Topic的交换机类型为：topic</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_EXCHAGE = <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_1 = <span class="hljs-string">&quot;topic_queue_1&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TOPIC_QUEUE_2 = <span class="hljs-string">&quot;topic_queue_2&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明交换机</span><br><span class="hljs-comment">         * 参数1：交换机名称</span><br><span class="hljs-comment">         * 参数2：交换机类型，fanout、topic、topic、headers</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br><br>        <span class="hljs-comment">// 发送信息</span><br>        String message = <span class="hljs-string">&quot;新增了商品。Topic模式；routing key 为 item.insert &quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.insert&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;修改了商品。Topic模式；routing key 为 item.update&quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.update&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 发送信息</span><br>        message = <span class="hljs-string">&quot;删除了商品。Topic模式；routing key 为 item.delete&quot;</span> ;<br>        channel.basicPublish(TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.delete&quot;</span>, <span class="hljs-keyword">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;已发送消息：&quot;</span> + message);<br><br>        <span class="hljs-comment">// 关闭资源</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>消费者1</p><p>接收两种类型的消息：更新商品和删除商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.TOPIC_QUEUE_1, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.update&quot;</span>);<br>        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.delete&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者1-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.TOPIC_QUEUE_1, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Connection connection = ConnectionUtil.getConnection();<br><br>        <span class="hljs-comment">// 创建频道</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明交换机</span><br>        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">// 声明（创建）队列</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否定义持久化队列</span><br><span class="hljs-comment">         * 参数3：是否独占本次连接</span><br><span class="hljs-comment">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="hljs-comment">         * 参数5：队列其它参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(Producer.TOPIC_QUEUE_2, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//队列绑定交换机</span><br>        channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHAGE, <span class="hljs-string">&quot;item.*&quot;</span>);<br><br>        <span class="hljs-comment">//创建消费者；并设置消息处理</span><br>        DefaultConsumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="hljs-comment">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="hljs-comment">             * properties 属性信息</span><br><span class="hljs-comment">             * body 消息</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//路由key</span><br>                System.out.println(<span class="hljs-string">&quot;路由key为：&quot;</span> + envelope.getRoutingKey());<br>                <span class="hljs-comment">//交换机</span><br>                System.out.println(<span class="hljs-string">&quot;交换机为：&quot;</span> + envelope.getExchange());<br>                <span class="hljs-comment">//消息id</span><br>                System.out.println(<span class="hljs-string">&quot;消息id为：&quot;</span> + envelope.getDeliveryTag());<br>                <span class="hljs-comment">//收到的消息</span><br>                System.out.println(<span class="hljs-string">&quot;消费者2-接收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> String(body, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">//监听消息</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数1：队列名称</span><br><span class="hljs-comment">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="hljs-comment">         * 参数3：消息接收到后回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(Producer.TOPIC_QUEUE_2, <span class="hljs-keyword">true</span>, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达<strong>按照需要接收</strong>的效果；并且这些routing key可以使用通配符。</p></li></ol><p>小结：</p><ul><li>Topic主题模式可以实现 <code>Publish/Subscribe发布与订阅模式</code> 和 <code> Routing路由模式</code> 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。</li></ul><h2 id="4-6-模式总结"><a href="#4-6-模式总结" class="headerlink" title="4.6. 模式总结"></a>4.6. 模式总结</h2><p>RabbitMQ工作模式：<br><strong>1、简单模式 HelloWorld</strong><br>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p><p><strong>2、工作队列模式 Work Queue</strong><br>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p><p><strong>3、发布订阅模式 Publish/subscribe</strong><br>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p><p><strong>4、路由模式 Routing</strong><br>需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><p><strong>5、通配符模式 Topic</strong><br>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p><h1 id="5-Spring-Boot整合RabbitMQ"><a href="#5-Spring-Boot整合RabbitMQ" class="headerlink" title="5. Spring Boot整合RabbitMQ"></a>5. Spring Boot整合RabbitMQ</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><p>在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。</p><p>一般在开发过程中：</p><ul><li><strong>生产者工程：</strong><ol><li>application.yml文件配置RabbitMQ相关信息；</li><li>在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定</li><li>注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机</li></ol></li><li><strong>消费者工程：</strong><ol><li>application.yml文件配置RabbitMQ相关信息</li><li>创建消息处理类，用于接收队列中的消息并进行处理</li></ol></li></ul><h2 id="5-2-搭建生产者工程"><a href="#5-2-搭建生产者工程" class="headerlink" title="5.2 搭建生产者工程"></a>5.2 搭建生产者工程</h2><h3 id="5-2-1-搭建生产者工程"><a href="#5-2-1-搭建生产者工程" class="headerlink" title="5.2.1 搭建生产者工程"></a>5.2.1 搭建生产者工程</h3><p>创建生产者工程springboot-rabbitmq-producer</p><h3 id="5-2-2-添加依赖"><a href="#5-2-2-添加依赖" class="headerlink" title="5.2.2 添加依赖"></a>5.2.2 添加依赖</h3><p>修改pom.xml文件内容为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itheima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq-producer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--主要就是这个包--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-3-启动类"><a href="#5-2-3-启动类" class="headerlink" title="5.2.3. 启动类"></a>5.2.3. 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ProducerApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-4-配置RabbitMQ"><a href="#5-2-4-配置RabbitMQ" class="headerlink" title="5.2.4. 配置RabbitMQ"></a>5.2.4. 配置RabbitMQ</h3><ol><li><p>配置文件</p><p>创建application.yml，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure></li><li><p>绑定交换机和队列</p><p>创建RabbitMQ队列与交换机绑定的配置类com.itheima.rabbitmq.config.RabbitMQConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ITEM_TOPIC_EXCHANGE = <span class="hljs-string">&quot;item_topic_exchange&quot;</span>;<br>    <span class="hljs-comment">//队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ITEM_QUEUE = <span class="hljs-string">&quot;item_queue&quot;</span>;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(&quot;itemTopicExchange&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">topicExchange</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(ITEM_TOPIC_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean(&quot;itemQueue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">itemQueue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(ITEM_QUEUE).build();<br>    &#125;<br><br>    <span class="hljs-comment">//绑定队列和交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">itemQueueExchange</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;itemQueue&quot;)</span> Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-meta">@Qualifier(&quot;itemTopicExchange&quot;)</span> Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;item.#&quot;</span>).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-3-搭建消费者工程"><a href="#5-3-搭建消费者工程" class="headerlink" title="5.3. 搭建消费者工程"></a>5.3. 搭建消费者工程</h2><h3 id="5-3-1-创建工程"><a href="#5-3-1-创建工程" class="headerlink" title="5.3.1. 创建工程"></a>5.3.1. 创建工程</h3><p>创建消费者工程springboot-rabbitmq-consumer</p><h3 id="5-3-2-添加依赖"><a href="#5-3-2-添加依赖" class="headerlink" title="5.3.2. 添加依赖"></a>5.3.2. 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itheima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--只用添加这个和消息中间件RabbitMQ有关的包--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-3-配置RabbitMQ"><a href="#5-3-3-配置RabbitMQ" class="headerlink" title="5.3.3 配置RabbitMQ"></a>5.3.3 配置RabbitMQ</h3><p>创建application.yml，内容如下：</p><p>注意：</p><ul><li>消费者和生产者的配置文件是一样的</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><h3 id="5-3-4-启动类"><a href="#5-3-4-启动类" class="headerlink" title="5.3.4 启动类"></a>5.3.4 启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConsumerApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-消息监听处理类"><a href="#5-3-5-消息监听处理类" class="headerlink" title="5.3.5 消息监听处理类"></a>5.3.5 消息监听处理类</h3><p>编写消息监听器com.itheima.rabbitmq.listener.MyListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 监听某个队列的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;item_queue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myListener1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者接收到的消息为：&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后进行测试</p><p>在生产者工程springboot-rabbitmq-producer中创建测试类，发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, <span class="hljs-string">&quot;item.insert&quot;</span>, <span class="hljs-string">&quot;商品新增，routing key 为item.insert&quot;</span>);<br>        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, <span class="hljs-string">&quot;item.update&quot;</span>, <span class="hljs-string">&quot;商品修改，routing key 为item.update&quot;</span>);<br>        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, <span class="hljs-string">&quot;item.delete&quot;</span>, <span class="hljs-string">&quot;商品删除，routing key 为item.delete&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行上述测试程序（交换机和队列才能先被声明和绑定），然后启动消费者；在消费者工程springboot-rabbitmq-consumer中控制台查看是否接收到对应消息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第六部分</title>
    <link href="/2021/07/29/1.6%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/29/1.6%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part12-分布式事务解决方案"><a href="#Part12-分布式事务解决方案" class="headerlink" title="Part12 分布式事务解决方案"></a>Part12 分布式事务解决方案</h1><h2 id="1-分布式事务解决方案"><a href="#1-分布式事务解决方案" class="headerlink" title="1. 分布式事务解决方案"></a>1. 分布式事务解决方案</h2><p>刚才我们编写的扣减库存与保存订单是在两个服务中存在的，如果扣减库存后订单保存失败了是不会回滚的，这样就会造成数据不一致的情况，这其实就是我们所说的分布式事务的问题，接下来我们来学习分布式事务的解决方案。</p><h3 id="1-1-本地事务与分布式事务"><a href="#1-1-本地事务与分布式事务" class="headerlink" title="1.1 本地事务与分布式事务"></a>1.1 本地事务与分布式事务</h3><h4 id="1-1-1-事务"><a href="#1-1-1-事务" class="headerlink" title="1.1.1 事务"></a>1.1.1 事务</h4><p>数据库事务(简称：事务，Transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><p>事务拥有以下四个特性，习惯上被称为ACID特性：</p><ol><li>原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性(Consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到(这层语义也有说应该属于原子性)</li><li>隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样</li><li>持久性(Durability)：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转</li></ol><h4 id="1-1-2-本地事务"><a href="#1-1-2-本地事务" class="headerlink" title="1.1.2 本地事务"></a>1.1.2 本地事务</h4><p>起初，事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。</p><p><img src="/images/image-20210808153508886.png" alt="image-20210808153508886"></p><h4 id="1-1-3-分布式事务"><a href="#1-1-3-分布式事务" class="headerlink" title="1.1.3 分布式事务"></a>1.1.3 分布式事务</h4><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><p>最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。</p><p><img src="/images/image-20210808153651910.png" alt="image-20210808153651910"></p><p>当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。</p><p>对于上面介绍的分布式事务应用架构，尽管一个服务操作会访问多个数据库资源，但是毕竟整个事务还是控制在单一服务的内部。如果一个服务操作需要调用另外一个服务，这时的事务就需要跨越多个服务了。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务：</p><p><img src="/images/image-20210808153833411.png" alt="image-20210808153833411"></p><p>如果将上面这两种场景(一个服务可以调用多个数据库资源，也可以调用其他服务)结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。</p><p><img src="/images/image-20210808154127517.png" alt="image-20210808154127517"></p><p>较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。</p><h3 id="1-2-分布式事务相关理论"><a href="#1-2-分布式事务相关理论" class="headerlink" title="1.2 分布式事务相关理论"></a>1.2 分布式事务相关理论</h3><h4 id="1-2-1-CAP定理"><a href="#1-2-1-CAP定理" class="headerlink" title="1.2.1 CAP定理"></a>1.2.1 CAP定理</h4><p><img src="/images/image-20210808154429381.png" alt="image-20210808154429381"></p><p>CAP定理是在 1998年加州大学的计算机科学家 Eric Brewer （埃里克.布鲁尔）提出，分布式系统有三个指标:</p><ol><li>Consistency (一致性)</li><li>Availability (可用性)</li><li>Partition tolerance(分区容错性)</li></ol><p>它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p><p><strong>分区容错 Partition tolerance</strong></p><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p><p><img src="/images/image-20210808154756029.png" alt="image-20210808154756029"></p><p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><p><strong>可用性 Availability</strong></p><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p><p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p><p><img src="/images/image-20210808155159592.png" alt="image-20210808155159592"></p><p><strong>一致性 Consistency</strong></p><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。</p><p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p><p><img src="/images/image-20210808155400246.png" alt="image-20210808155400246"></p><p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p><p><img src="/images/image-20210808155459722.png" alt="image-20210808155459722"></p><p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p><p><img src="/images/image-20210808155553113.png" alt="image-20210808155553113"></p><p><strong>一致性和可用性的矛盾</strong></p><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。</p><p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><h4 id="1-2-2-BASE理论"><a href="#1-2-2-BASE理论" class="headerlink" title="1.2.2 BASE理论"></a>1.2.2 BASE理论</h4><p>BASE全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：</p><ul><li>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</li></ul><p><strong>Basically Available(基本可用)</strong></p><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><ol><li>响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而<strong>基本可用</strong>的搜索引擎可以在 1 秒作用返回结果。</li><li>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ol><p><strong>Soft state(软状态)</strong></p><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><p><strong>Eventually consistent(最终一致性)</strong></p><p>系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值</p><h3 id="1-3-分布式事务解决方案"><a href="#1-3-分布式事务解决方案" class="headerlink" title="1.3 分布式事务解决方案"></a>1.3 分布式事务解决方案</h3><p>下面介绍了三种：</p><ol><li>基于XA协议的两阶段提交 2PC</li><li>TCC补偿机制</li><li>消息最终一致性（比较常用）</li></ol><h4 id="1-3-1-基于XA协议的两阶段提交-2PC"><a href="#1-3-1-基于XA协议的两阶段提交-2PC" class="headerlink" title="1.3.1 基于XA协议的两阶段提交 2PC"></a>1.3.1 基于XA协议的两阶段提交 2PC</h4><p>首先我们来简要看下分布式事务处理的XA规范 ：</p><p><img src="/images/image-20210808162019064.png" alt="image-20210808162019064"></p><p>可知XA规范中分布式事务有AP，RM，TM组成：</p><ul><li>其中应用程序(Application Program ，简称AP)：AP定义事务边界（定义事务开始和结束）并访问事务边界内的资源。</li><li>资源管理器(Resource Manager，简称RM)：Rm管理计算机共享的资源，许多软件都可以去访问这些资源，资源包含比如数据库、文件系统、打印机服务器等。</li><li>事务管理器(Transaction Manager ，简称TM)：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li></ul><p><strong>二阶段协议</strong></p><p><strong>第一阶段</strong>TM要求所有的RM准备提交对应的事务分支，询问RM是否有能力保证成功的提交事务分支，RM根据自己的情况，如果判断自己进行的工作可以被提交，那就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NO。RM在发送了否定答复并回滚了已经完成的工作后，就可以丢弃这个事务分支信息了。</p><p><strong>第二阶段</strong>TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare回执NO的话，则TM通知所有RM回滚自己的事务分支。</p><p><strong>优点：</strong> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</p><p><strong>缺点：</strong> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p><h4 id="1-3-2-TCC补偿机制"><a href="#1-3-2-TCC补偿机制" class="headerlink" title="1.3.2 TCC补偿机制"></a>1.3.2 TCC补偿机制</h4><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ol><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p><p><img src="/images/image-20210808163206446.png" alt="image-20210808163206446"></p></li></ol><p>例如： A要向 B 转账，思路大概是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">我们有一个本地方法，里面依次调用 <br><span class="hljs-selector-tag">1</span>、首先在 <span class="hljs-selector-tag">Try</span> 阶段，要先调用远程接口把 <span class="hljs-selector-tag">B</span>和 <span class="hljs-selector-tag">A</span>的钱给冻结起来。 <br><span class="hljs-selector-tag">2</span>、在 <span class="hljs-selector-tag">Confirm</span> 阶段，执行远程调用的转账的操作，转账成功进行解冻。 <br><span class="hljs-selector-tag">3</span>、如果第<span class="hljs-selector-tag">2</span>步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。<br></code></pre></td></tr></table></figure><p><strong>优点：</strong> 相比两阶段提交，可用性比较强</p><p><strong>缺点：</strong> 数据的一致性要差一些。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h4 id="1-3-3-消息最终一致性"><a href="#1-3-3-消息最终一致性" class="headerlink" title="1.3.3 消息最终一致性"></a>1.3.3 消息最终一致性</h4><p>消息最终一致性应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：</p><p><img src="/images/image-20210808163618176.png" alt="image-20210808163618176"></p><p>基本思路就是：</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h2 id="2-基于Seata实现分布式事务"><a href="#2-基于Seata实现分布式事务" class="headerlink" title="2. 基于Seata实现分布式事务"></a>2. 基于Seata实现分布式事务</h2><h3 id="2-1-Seata简介"><a href="#2-1-Seata简介" class="headerlink" title="2.1 Seata简介"></a>2.1 Seata简介</h3><p>Seata（原名Fescar） 是阿里18年开源的分布式事务的框架。Fescar的开源对分布式事务框架领域影响很大。作为开源大户，Fescar来自阿里的GTS，经历了好几次双十一的考验，一经开源便颇受关注。后来Fescar改名为Seata。</p><p>Fescar虽然是二阶段提交协议的分布式事务，但是其解决了XA的一些缺点:</p><ul><li>单点问题</li><li>同步阻塞:Fescar的二阶段，其再第一阶段的时候本地事务就已经提交释放资源了，不会像XA会再两个prepare和commit阶段资源都锁住，并且Fescar,commit是异步操作，也是提升性能的一大关键。</li><li>数据不一致:如果出现部分commit失败，那么fescar-server会根据当前的事务模式和分支事务的返回状态的结果来进行不同的重试策略。并且fescar的本地事务会在一阶段的时候进行提交，其实单看数据库来说在commit的时候数据库已经是一致的了。</li><li>只能用于单一数据库: Fescar提供了两种模式，AT和MT。在AT模式下事务资源可以是任何支持ACID的数据库，在MT模式下事务资源没有限制，可以是缓存，可以是文件，可以是其他的等等。当然这两个模式也可以混用。</li></ul><p>同时Fescar也保留了接近0业务入侵的优点，只需要简单的配置Fescar的数据代理和加个注解，加一个Undolog表，就可以达到我们想要的目的。</p><h3 id="2-2-实现原理"><a href="#2-2-实现原理" class="headerlink" title="2.2 实现原理"></a>2.2 实现原理</h3><p>Fescar将一个本地事务做为一个分布式事务分支，所以若干个分布在不同微服务中的本地事务共同组成了一个全局事务，结构如下。</p><p><img src="/images/image-20210808170047659.png" alt="image-20210808170047659"></p><p><strong>Transaction Coordinator (TC)：</strong> 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</p><p><strong>Transaction Manager (TM)：</strong>事务管理器， 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</p><p><strong>Resource Manager (RM)：</strong>资源管理器， 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</p><p>一个典型的分布式事务过程：</p><ol><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID</li><li>XID 在微服务调用链路的上下文中传播</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求</li></ol><h3 id="2-3-Fescar模式"><a href="#2-3-Fescar模式" class="headerlink" title="2.3 Fescar模式"></a>2.3 Fescar模式</h3><p>Fescar对分布式事务的实现提供了3种模式，AT模式、MT模式和混合模式：</p><h4 id="2-3-1-AT模式"><a href="#2-3-1-AT模式" class="headerlink" title="2.3.1 AT模式"></a>2.3.1 AT模式</h4><p>业务逻辑不需要关注事务机制，分支与全局事务的交互过程自动进行。</p><p><strong>AT模式</strong>：主要关注多 DB 访问的数据一致性，实现起来比较简单，对业务的侵入较小。</p><p>AT模式部分代码如下：不需要关注执行状态，对业务代码侵入较小。类似代码如下，只需要为方法添加<code>@GlobalTransactional</code>注解即可。</p><p>AT模式的核心是对业务无侵入，是一种改进后的两阶段提交，其设计思路如图：</p><p><strong>第一阶段：</strong></p><p><img src="/images/image-20210808171613070.png" alt="image-20210808171613070"></p><p>核心在于对业务sql进行解析，转换成undolog，两阶段提交往往对资源的锁定需要持续到第二阶段实际的提交或者回滚操作，而有了回滚日志之后，可以在第一阶段释放对资源的锁定，降低了锁范围，提高效率，即使第二阶段发生异常需要回滚，只需找对undolog中对应数据并反解析成sql来达到回滚目的。Seata通过代理数据源将业务sql的执行解析成undolog来与业务数据的更新同时入库，达到了对业务无侵入的效果。</p><p><strong>第二阶段：</strong></p><p>如果决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），Phase2 可以非常快速地完成。</p><p><img src="/images/image-20210808172343299.png" alt="image-20210808172343299"></p><p>如果决议是全局回滚，RM 收到协调器发来的回滚请求，通过 XID 和 Branch ID 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p><p><img src="/images/image-20210808172427714.png" alt="image-20210808172427714"></p><h4 id="2-3-2-MT模式"><a href="#2-3-2-MT模式" class="headerlink" title="2.3.2 MT模式"></a>2.3.2 MT模式</h4><p>业务逻辑需要被分解为 Prepare/Commit/Rollback 3 部分，形成一个 MT 分支，加入全局事务。</p><p><img src="/images/image-20210808172713861.png" alt="image-20210808172713861"></p><p>MT 模式一方面是 AT 模式的补充。另外，更重要的价值在于，通过 MT 模式可以把众多非事务性资源纳入全局事务的管理中</p><h4 id="2-3-3-混合模式"><a href="#2-3-3-混合模式" class="headerlink" title="2.3.3 混合模式"></a>2.3.3 混合模式</h4><p>因为 AT 和 MT 模式的分支从根本上行为模式是一致的，所以可以完全兼容，即，一个全局事务中，可以同时存在 AT 和 MT 的分支。这样就可以达到全面覆盖业务场景的目的：AT 模式可以支持的，使用 AT 模式；AT 模式暂时支持不了的，用 MT 模式来替代。另外，自然的，MT 模式管理的非事务性资源也可以和支持事务的关系型数据库资源一起，纳入同一个分布式事务的管理中。</p><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><h4 id="2-4-1-分布式事务公共模块"><a href="#2-4-1-分布式事务公共模块" class="headerlink" title="2.4.1 分布式事务公共模块"></a>2.4.1 分布式事务公共模块</h4><ol><li><p>创建工程 changgou_common_fescar（不是在changgou_common这个工程下创建的，是在changgou_parent下创建的），引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fescar.version</span>&gt;</span>0.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">fescar.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fescar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fescar-tm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fescar.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fescar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fescar-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fescar.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>将<code>fescar配置文件</code>文件夹中的所有配置文件拷贝到resources工程下，如下图：</p><p><img src="/images/image-20210808194328959.png" alt="image-20210808194328959"></p><p>注意file.conf的2个配置。service.vgroup_mapping.my_test_tx_group 映射到相应的 Fescar-Server 集群名称，然后再根据集群名称.grouplist 获取到可用服务列表。</p><p><img src="/images/image-20210808194511402.png" alt="image-20210808194511402"></p></li><li><p>创建FescarRMRequestFilter，给每个线程绑定一个XID （资源提供）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarRMRequestFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = org.slf4j.LoggerFactory.getLogger( FescarRMRequestFilter.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给每次线程请求绑定一个XID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filterChain</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        String currentXID = request.getHeader( FescarAutoConfiguration.FESCAR_XID);<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(currentXID))&#123;<br>            RootContext.bind(currentXID);<br>            LOGGER.info(<span class="hljs-string">&quot;当前线程绑定的XID :&quot;</span> + currentXID);<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            filterChain.doFilter(request, response);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            String unbindXID = RootContext.unbind();<br>            <span class="hljs-keyword">if</span>(unbindXID != <span class="hljs-keyword">null</span>)&#123;<br>                LOGGER.info(<span class="hljs-string">&quot;当前线程从指定XID中解绑 XID :&quot;</span> + unbindXID);<br>                <span class="hljs-keyword">if</span>(!currentXID.equals(unbindXID))&#123;<br>                    LOGGER.info(<span class="hljs-string">&quot;当前线程的XID发生变更&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(currentXID != <span class="hljs-keyword">null</span>)&#123;<br>                LOGGER.info(<span class="hljs-string">&quot;当前线程的XID发生变更&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建FescarRestInterceptor过滤器，每次请求其他微服务的时候，都将XID携带过去。(Feign拦截器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarRestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span>, <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;<br>        String xid = RootContext.getXID();<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(xid))&#123;<br>            requestTemplate.header( FescarAutoConfiguration.FESCAR_XID, xid);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String xid = RootContext.getXID();<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(xid))&#123;<br>            HttpHeaders headers = request.getHeaders();<br>            headers.put( FescarAutoConfiguration.FESCAR_XID, Collections.singletonList(xid));<br>        &#125;<br>        <span class="hljs-keyword">return</span> execution.execute(request, body);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建FescarAutoConfiguration类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FESCAR_XID = <span class="hljs-string">&quot;fescarXID&quot;</span>;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 创建代理数据库</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> environment</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(Environment environment)</span></span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUrl(environment.getProperty(<span class="hljs-string">&quot;spring.datasource.url&quot;</span>));<br>        <span class="hljs-keyword">try</span> &#123;<br>            dataSource.setDriver(DriverManager.getDriver(environment.getProperty(<span class="hljs-string">&quot;spring.datasource.url&quot;</span>)));<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;can&#x27;t recognize dataSource Driver&quot;</span>);<br>        &#125;<br>        dataSource.setUsername(environment.getProperty(<span class="hljs-string">&quot;spring.datasource.username&quot;</span>));<br>        dataSource.setPassword(environment.getProperty(<span class="hljs-string">&quot;spring.datasource.password&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 全局事务扫描器</span><br><span class="hljs-comment">     * 用来解析带有<span class="hljs-doctag">@GlobalTransactional</span>注解的方法，然后采用AOP的机制控制事务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> environment</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> GlobalTransactionScanner <span class="hljs-title">globalTransactionScanner</span><span class="hljs-params">(Environment environment)</span></span>&#123;<br>        String applicationName = environment.getProperty(<span class="hljs-string">&quot;spring.application.name&quot;</span>);<br>        String groupName = environment.getProperty(<span class="hljs-string">&quot;fescar.group.name&quot;</span>);<br>        <span class="hljs-keyword">if</span>(applicationName == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GlobalTransactionScanner(groupName == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;my_test_tx_group&quot;</span> : groupName);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GlobalTransactionScanner(applicationName, groupName == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;my_test_tx_group&quot;</span> : groupName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 每次微服务和微服务之间相互调用</span><br><span class="hljs-comment">     * 要想控制全局事务，每次TM都会请求TC生成一个XID，每次执行下一个事务，也就是调用其他微服务的时候都需要将该XID传递过去</span><br><span class="hljs-comment">     * 所以我们可以每次请求的时候，都获取头中的XID，并将XID传递到下一个微服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> restTemplates</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ConditionalOnBean(&#123;RestTemplate.class&#125;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">addFescarInterceptor</span><span class="hljs-params">(Collection&lt;RestTemplate&gt; restTemplates)</span></span>&#123;<br>        restTemplates.stream()<br>                .forEach(restTemplate -&gt; &#123;<br>                    List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();<br>                    <span class="hljs-keyword">if</span>(interceptors != <span class="hljs-keyword">null</span>)&#123;<br>                        interceptors.add(fescarRestInterceptor());<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FescarRMRequestFilter <span class="hljs-title">fescarRMRequestFilter</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FescarRMRequestFilter();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FescarRestInterceptor <span class="hljs-title">fescarRestInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FescarRestInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-4-2-分布式事物的实现"><a href="#2-4-2-分布式事物的实现" class="headerlink" title="2.4.2 分布式事物的实现"></a>2.4.2 分布式事物的实现</h4><ol><li><p>涉及到分布式事务的数据库添加表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `undo_log` (<br>  `id` bigint(20) NOT NULL AUTO_INCREMENT,<br>  `branch_id` bigint(20) NOT NULL,<br>  `xid` varchar(100) NOT NULL,<br>  `rollback_info` longblob NOT NULL,<br>  `log_status` int(11) NOT NULL,<br>  `log_created` datetime NOT NULL,<br>  `log_modified` datetime NOT NULL,<br>  `ext` varchar(100) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_unionkey` (`xid`,`branch_id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=200 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>核心在于对业务sql进行解析，转换成undolog, 所以只要支持Fescar分布式事务的微服务数据都需要导入该表结构</p></li><li><p>需要添加分布式事务的微服务（<strong>商品微服务、订单微服务</strong>）添加对 changgou_transaction_fescar的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--fescar依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common_fescar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在订单微服务的OrderServiceImpl的add方法上增加@GlobalTransactional(name = “order_add”)注解</p><p><code>@GlobalTransactional(name = &quot;order_add&quot;)</code>表明这个全局注解的名称是order_add</p></li><li><p>启动Fescar-server</p><p><img src="/images/image-20210808195409252.png" alt="image-20210808195409252"></p></li><li><p>测试</p><ol><li>功能测试，看功能能否正常执行。</li><li>异常测试，我们在方法中添加<code>int x=1/0</code> ，看库存信息是否能够回滚。</li></ol></li></ol><h2 id="3-基于消息队列实现分布式事务"><a href="#3-基于消息队列实现分布式事务" class="headerlink" title="3. 基于消息队列实现分布式事务"></a>3. 基于消息队列实现分布式事务</h2><p><img src="/images/image-20210808195747681.png" alt="image-20210808195747681"></p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><ol><li><p>changgou_order库新增数据表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS `tb_task`;<br>CREATE TABLE `tb_task` (<br>  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#x27;任务id&#x27;,<br>  `create_time` datetime DEFAULT NULL,<br>  `update_time` datetime DEFAULT NULL,<br>  `delete_time` datetime DEFAULT NULL,<br>  `task_type` varchar(32) DEFAULT NULL COMMENT &#x27;任务类型&#x27;,<br>  `mq_exchange` varchar(64) DEFAULT NULL COMMENT &#x27;交换机名称&#x27;,<br>  `mq_routingkey` varchar(64) DEFAULT NULL COMMENT &#x27;routingkey&#x27;,<br>  `request_body` varchar(512) DEFAULT NULL COMMENT &#x27;任务请求的内容&#x27;,<br>  `status` varchar(32) DEFAULT NULL COMMENT &#x27;任务状态&#x27;,<br>  `errormsg` varchar(512) DEFAULT NULL COMMENT &#x27;任务错误信息&#x27;,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS `tb_task_his`;<br>CREATE TABLE `tb_task_his` (<br>  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &#x27;任务id&#x27;,<br>  `create_time` datetime DEFAULT NULL,<br>  `update_time` datetime DEFAULT NULL,<br>  `delete_time` datetime DEFAULT NULL,<br>  `task_type` varchar(32) DEFAULT NULL COMMENT &#x27;任务类型&#x27;,<br>  `mq_exchange` varchar(64) DEFAULT NULL COMMENT &#x27;交换机名称&#x27;,<br>  `mq_routingkey` varchar(64) DEFAULT NULL COMMENT &#x27;routingkey&#x27;,<br>  `request_body` varchar(512) DEFAULT NULL COMMENT &#x27;任务请求的内容&#x27;,<br>  `status` varchar(32) DEFAULT NULL COMMENT &#x27;任务状态&#x27;,<br>  `errormsg` varchar(512) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_order_api添加相关实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Table(name = &quot;tb_task&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@Column(name = &quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;delete_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date deleteTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;task_type&quot;)</span><br>    <span class="hljs-keyword">private</span> String taskType;<br><br>    <span class="hljs-meta">@Column(name = &quot;mq_exchange&quot;)</span><br>    <span class="hljs-keyword">private</span> String mqExchange;<br><br>    <span class="hljs-meta">@Column(name = &quot;mq_routingkey&quot;)</span><br>    <span class="hljs-keyword">private</span> String mqRoutingkey;<br><br>    <span class="hljs-meta">@Column(name = &quot;request_body&quot;)</span><br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-meta">@Column(name = &quot;status&quot;)</span><br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-meta">@Column(name = &quot;errormsg&quot;)</span><br>    <span class="hljs-keyword">private</span> String errormsg;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.createTime = createTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getUpdateTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> updateTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpdateTime</span><span class="hljs-params">(Date updateTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.updateTime = updateTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDeleteTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> deleteTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDeleteTime</span><span class="hljs-params">(Date deleteTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.deleteTime = deleteTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTaskType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> taskType;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTaskType</span><span class="hljs-params">(String taskType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskType = taskType;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMqExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mqExchange;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMqExchange</span><span class="hljs-params">(String mqExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mqExchange = mqExchange;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMqRoutingkey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mqRoutingkey;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMqRoutingkey</span><span class="hljs-params">(String mqRoutingkey)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mqRoutingkey = mqRoutingkey;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRequestBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> requestBody;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequestBody</span><span class="hljs-params">(String requestBody)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.requestBody = requestBody;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErrormsg</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> errormsg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setErrormsg</span><span class="hljs-params">(String errormsg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.errormsg = errormsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Table(name = &quot;tb_task_his&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskHis</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@Column(name = &quot;create_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;update_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;delete_time&quot;)</span><br>    <span class="hljs-keyword">private</span> Date deleteTime;<br><br>    <span class="hljs-meta">@Column(name = &quot;task_type&quot;)</span><br>    <span class="hljs-keyword">private</span> String taskType;<br><br>    <span class="hljs-meta">@Column(name = &quot;mq_exchange&quot;)</span><br>    <span class="hljs-keyword">private</span> String mqExchange;<br><br>    <span class="hljs-meta">@Column(name = &quot;mq_routingkey&quot;)</span><br>    <span class="hljs-keyword">private</span> String mqRoutingkey;<br><br>    <span class="hljs-meta">@Column(name = &quot;request_body&quot;)</span><br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-meta">@Column(name = &quot;status&quot;)</span><br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-meta">@Column(name = &quot;errormsg&quot;)</span><br>    <span class="hljs-keyword">private</span> String errormsg;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getCreateTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateTime</span><span class="hljs-params">(Date createTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.createTime = createTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getUpdateTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> updateTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUpdateTime</span><span class="hljs-params">(Date updateTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.updateTime = updateTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getDeleteTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> deleteTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDeleteTime</span><span class="hljs-params">(Date deleteTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.deleteTime = deleteTime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTaskType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> taskType;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTaskType</span><span class="hljs-params">(String taskType)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskType = taskType;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMqExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mqExchange;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMqExchange</span><span class="hljs-params">(String mqExchange)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mqExchange = mqExchange;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMqRoutingkey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mqRoutingkey;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMqRoutingkey</span><span class="hljs-params">(String mqRoutingkey)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mqRoutingkey = mqRoutingkey;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRequestBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> requestBody;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequestBody</span><span class="hljs-params">(String requestBody)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.requestBody = requestBody;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getErrormsg</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> errormsg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setErrormsg</span><span class="hljs-params">(String errormsg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.errormsg = errormsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_user新增积分日志表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS `tb_point_log`;<br>CREATE TABLE `tb_point_log` (<br>  `order_id` varchar(200) NOT NULL,<br>  `user_id` varchar(200) NOT NULL,<br>  `point` int(11) NOT NULL,<br>  PRIMARY KEY (`order_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_user_api添加实体类 PointLog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Table(name = &quot;tb_point_log&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointLog</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String orderId;<br>    <span class="hljs-keyword">private</span> String userId;<br>    <span class="hljs-keyword">private</span> Integer point;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrderId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderId</span><span class="hljs-params">(String orderId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.orderId = orderId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserId</span><span class="hljs-params">(String userId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userId = userId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPoint</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> point;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPoint</span><span class="hljs-params">(Integer point)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.point = point;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_order添加rabbitMQ配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//添加积分任务交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_BUYING_ADDPOINTUSER = <span class="hljs-string">&quot;ex_buying_addpointuser&quot;</span>;<br><br>    <span class="hljs-comment">//添加积分消息队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT = <span class="hljs-string">&quot;cg_buying_addpoint&quot;</span>;<br><br>    <span class="hljs-comment">//完成添加积分消息队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT = <span class="hljs-string">&quot;cg_buying_finishaddpoint&quot;</span>;<br><br>    <span class="hljs-comment">//添加积分路由key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT_KEY = <span class="hljs-string">&quot;addpoint&quot;</span>;<br><br>    <span class="hljs-comment">//完成添加积分路由key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT_KEY = <span class="hljs-string">&quot;finishaddpoint&quot;</span>;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(EX_BUYING_ADDPOINTUSER)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_BUYING_ADDPOINTUSER</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_BUYING_ADDPOINTUSER).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean(CG_BUYING_ADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">CG_BUYING_ADDPOINT</span><span class="hljs-params">()</span></span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_ADDPOINT);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>    <span class="hljs-meta">@Bean(CG_BUYING_FINISHADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">()</span></span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_FINISHADDPOINT);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br><br>    <span class="hljs-comment">//队列绑定交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_CG_BUYING_ADDPOINT</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(CG_BUYING_ADDPOINT)</span> Queue queue,<span class="hljs-meta">@Qualifier(EX_BUYING_ADDPOINTUSER)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_ADDPOINT_KEY).noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(CG_BUYING_FINISHADDPOINT)</span> Queue queue,<span class="hljs-meta">@Qualifier(EX_BUYING_ADDPOINTUSER)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_FINISHADDPOINT_KEY).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-订单服务添加任务并发送"><a href="#3-2-订单服务添加任务并发送" class="headerlink" title="3.2 订单服务添加任务并发送"></a>3.2 订单服务添加任务并发送</h3><h4 id="3-2-1-修改添加订单方法"><a href="#3-2-1-修改添加订单方法" class="headerlink" title="3.2.1 修改添加订单方法"></a>3.2.1 修改添加订单方法</h4><p>当添加订单的时候，添加任务表中相关数据, 局部代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增加任务表记录</span><br>Task task = <span class="hljs-keyword">new</span> Task();<br>task.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>task.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>task.setMqExchange(RabbitMQConfig.EX_BUYING_ADDPOINTURSE);<br>task.setMqRoutingkey(RabbitMQConfig.CG_BUYING_ADDPOINT_KEY);<br><br>Map map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-string">&quot;userName&quot;</span>,order.getUsername());<br>map.put(<span class="hljs-string">&quot;orderId&quot;</span>,order.getId());<br>map.put(<span class="hljs-string">&quot;point&quot;</span>,order.getPayMoney());<br>task.setRequestBody(JSON.toJSONString(map));<br>taskMapper.insertSelective(task);<br></code></pre></td></tr></table></figure><h4 id="3-2-2-定时扫描任务表最新数据"><a href="#3-2-2-定时扫描任务表最新数据" class="headerlink" title="3.2.2 定时扫描任务表最新数据"></a>3.2.2 定时扫描任务表最新数据</h4><p>订单服务新增定时任务类，获取小于系统当前时间的所有任务数据</p><ol><li><p>修改订单服务启动类，添加开启定时任务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableScheduling</span><br></code></pre></td></tr></table></figure></li><li><p>定义定时任务类</p><p>查询最新数据</p><p>更新taskMapper新增方法，查询所有小于系统当前时间的数据</p><p>注意：</p><ul><li><code>@Results</code>开启表和实体类的映射，column后面跟字段名，property后面跟属性名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TaskMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Task</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;SELECT * from tb_task WHERE update_time&lt;#&#123;currentTime&#125;&quot;)</span><br>    <span class="hljs-meta">@Results(&#123;@Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;update_time&quot;,property = &quot;updateTime&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;delete_time&quot;,property = &quot;deleteTime&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;task_type&quot;,property = &quot;taskType&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;mq_exchange&quot;,property = &quot;mqExchange&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;mq_routingkey&quot;,property = &quot;mqRoutingkey&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;request_body&quot;,property = &quot;requestBody&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;status&quot;,property = &quot;status&quot;),</span><br><span class="hljs-meta">            @Result(column = &quot;errormsg&quot;,property = &quot;errormsg&quot;)&#125;)</span><br>    <span class="hljs-function">List&lt;Task&gt; <span class="hljs-title">findTaskLessTanCurrentTime</span><span class="hljs-params">(Date currentTime)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>任务类实现</p><p>注意：</p><ul><li><code>cron = &quot;0 0/2 * * * ?&quot;</code>的语法有时间再去看看，这个表示每两秒检查一次</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPointTask</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TaskMapper taskMapper;<br><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0/2 * * * ?&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryTask</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//1.获取小于系统当前时间数据</span><br>        List&lt;Task&gt; taskList = taskMapper.findTaskLessTanCurrentTime(<span class="hljs-keyword">new</span> Date());<br><br>        <span class="hljs-keyword">if</span> (taskList!=<span class="hljs-keyword">null</span> &amp;&amp; taskList.size()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//将任务数据发送到消息队列</span><br>            <span class="hljs-keyword">for</span> (Task task : taskList) &#123;<br> rabbitTemplate.convertAndSend(RabbitMQConfig.EX_BUYING_ADDPOINTUSER,RabbitMQConfig.CG_BUYING_ADDPOINT_KEY, JSON.toJSONString(task));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-3-用户服务更改积分"><a href="#3-3-用户服务更改积分" class="headerlink" title="3.3 用户服务更改积分"></a>3.3 用户服务更改积分</h3><ol><li><p>添加rabbitmq配置类(与订单服务相同)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//添加积分任务交换机</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_BUYING_ADDPOINTUSER = <span class="hljs-string">&quot;ex_buying_addpointuser&quot;</span>;<br><br>    <span class="hljs-comment">//添加积分消息队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT = <span class="hljs-string">&quot;cg_buying_addpoint&quot;</span>;<br><br>    <span class="hljs-comment">//完成添加积分消息队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT = <span class="hljs-string">&quot;cg_buying_finishaddpoint&quot;</span>;<br><br>    <span class="hljs-comment">//添加积分路由key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT_KEY = <span class="hljs-string">&quot;addpoint&quot;</span>;<br><br>    <span class="hljs-comment">//完成添加积分路由key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT_KEY = <span class="hljs-string">&quot;finishaddpoint&quot;</span>;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(EX_BUYING_ADDPOINTUSER)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_BUYING_ADDPOINTUSER</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_BUYING_ADDPOINTUSER).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean(CG_BUYING_ADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">CG_BUYING_ADDPOINT</span><span class="hljs-params">()</span></span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_ADDPOINT);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>    <span class="hljs-meta">@Bean(CG_BUYING_FINISHADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">()</span></span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_FINISHADDPOINT);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br><br>    <span class="hljs-comment">//队列绑定交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_CG_BUYING_ADDPOINT</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(CG_BUYING_ADDPOINT)</span> Queue queue,<span class="hljs-meta">@Qualifier(EX_BUYING_ADDPOINTUSER)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_ADDPOINT_KEY).noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(CG_BUYING_FINISHADDPOINT)</span> Queue queue,<span class="hljs-meta">@Qualifier(EX_BUYING_ADDPOINTUSER)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_FINISHADDPOINT_KEY).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义消息监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPointListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.CG_BUYING_ADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveAddPointMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;用户服务接收到了任务消息&quot;</span>);<br><br>        <span class="hljs-comment">//转换消息</span><br>        Task task = JSON.parseObject(message, Task.class);<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(task.getRequestBody()))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//判断redis中当前的任务是否存在</span><br>        Object value = redisTemplate.boundValueOps(task.getId()).get();<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//更新用户积分</span><br>        <span class="hljs-keyword">int</span> result = userService.updateUserPoint(task);<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//向订单服务返回通知消息</span><br>        rabbitTemplate.convertAndSend(RabbitMQConfig.EX_BUYING_ADDPOINTUSER,RabbitMQConfig.CG_BUYING_FINISHADDPOINT_KEY,JSON.toJSONString(task));<br>        System.out.println(<span class="hljs-string">&quot;用户服务向完成添加积分队列发送了一条消息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义PointLogMapper，实现根据订单id查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PointLogMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">PointLog</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from tb_point_log where order_id=#&#123;orderId&#125;&quot;)</span><br>    <span class="hljs-function">PointLog <span class="hljs-title">findLogInfoByOrderId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;orderId&quot;)</span> String orderId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义修改用户积分实现</p><p>实现思路(操作的是UserServiceImpl实现类)：</p><ol><li>判断当前订单是否操作过</li><li>将任务存入redis</li><li>修改用户积分</li><li>添加积分日志表记录</li><li>删除redis中记录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> PointLogMapper pointLogMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改用户积分</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateUserPoints</span><span class="hljs-params">(Task task)</span> </span>&#123;<br>        Map info = JSON.parseObject(task.getRequestBody(), Map.class);<br>        String userName = info.get(<span class="hljs-string">&quot;userName&quot;</span>).toString();<br>        String orderId = info.get(<span class="hljs-string">&quot;orderId&quot;</span>).toString();<br>        <span class="hljs-keyword">int</span> point = (<span class="hljs-keyword">int</span>) info.get(<span class="hljs-string">&quot;point&quot;</span>);<br><br>        <span class="hljs-comment">//判断当前订单是否操作过</span><br>        PointLog pointLog = pointLogMapper.findLogInfoByOrderId(orderId);<br>        <span class="hljs-keyword">if</span> (pointLog != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//将任务存入redis</span><br>        redisTemplate.boundValueOps(task.getId()).set(<span class="hljs-string">&quot;exist&quot;</span>,<span class="hljs-number">1</span>,TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">//修改用户积分</span><br>        <span class="hljs-keyword">int</span> result = userMapper.updateUserPoint(userName, point);<br>        <span class="hljs-keyword">if</span> (result&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">//添加积分日志表记录</span><br>        pointLog = <span class="hljs-keyword">new</span> PointLog();<br>        pointLog.setOrderId(orderId);<br>        pointLog.setPoint(point);<br>        pointLog.setUserId(userName);<br>        result = pointLogMapper.insertSelective(pointLog);<br>        <span class="hljs-keyword">if</span> (result&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-comment">//删除redis中的记录</span><br>        redisTemplate.delete(task.getId());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-订单服务删除原任务"><a href="#3-4-订单服务删除原任务" class="headerlink" title="3.4 订单服务删除原任务"></a>3.4 订单服务删除原任务</h3><h4 id="3-4-1-定义监听类"><a href="#3-4-1-定义监听类" class="headerlink" title="3.4.1 定义监听类"></a>3.4.1 定义监听类</h4><p>在订单服务中定义监听类，用于监听队列，如果队列中有消息，则删除原任务防止消息重复发送，并对任务信息进行记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelTaskListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TaskService taskService;<br><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.CG_BUYING_FINISHADDPOINT)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br><br>        Task task = JSON.parseObject(message, Task.class);<br><br>        taskService.delTask(task);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-2-定义任务service"><a href="#3-4-2-定义任务service" class="headerlink" title="3.4.2 定义任务service"></a>3.4.2 定义任务service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TaskService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTask</span><span class="hljs-params">(Task task)</span></span>;<br>&#125;<br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TaskMapper taskMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TaskHisMapper taskHisMapper;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delTask</span><span class="hljs-params">(Task task)</span> </span>&#123;<br>        <span class="hljs-comment">//1. 设置删除时间</span><br>        task.setDeleteTime(<span class="hljs-keyword">new</span> Date());<br>        Long id = task.getId();<br>        task.setId(<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//bean复制</span><br>        TaskHis taskHis = <span class="hljs-keyword">new</span> TaskHis();<br>        BeanUtils.copyProperties(task,taskHis);<br><br>       <span class="hljs-comment">//记录任务信息</span><br>        taskHisMapper.insertSelective(taskHis);<br><br>        <span class="hljs-comment">//删除原任务</span><br>        task.setId(id);<br>        taskMapper.deleteByPrimaryKey(task);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第五部分</title>
    <link href="/2021/07/29/1.5%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/29/1.5%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part10-购物车"><a href="#Part10-购物车" class="headerlink" title="Part10 购物车"></a>Part10 购物车</h1><h2 id="1-SpringSecurity权限控制"><a href="#1-SpringSecurity权限控制" class="headerlink" title="1. SpringSecurity权限控制"></a>1. SpringSecurity权限控制</h2><p><img src="/images/image-20210807190309378.png" alt="image-20210807190309378"></p><p>用户每次访问微服务的时候，先去oauth2.0服务登录，登录后再访问微服务网关，微服务网关将请求转发给其他微服务处理。</p><p>由于我们项目使用了微服务，任何用户都有可能使用任意微服务，此时我们需要控制相关权限，例如：普通用户角色不能使用用户的删除操作，只有管理员才可以使用,那么这个时候就需要使用到SpringSecurity的权限控制功能了。</p><h3 id="1-1-角色权限加载"><a href="#1-1-角色权限加载" class="headerlink" title="1.1 角色权限加载"></a>1.1 角色权限加载</h3><p>在changgou-user-oauth服务中，com.changgou.oauth.config.UserDetailsServiceImpl该类实现了加载用户相关信息，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//根据用户名查询用户信息</span><br><span class="hljs-comment">//        String pwd = new BCryptPasswordEncoder().encode(&quot;itheima&quot;);</span><br>        com.changgou.user.pojo.User userInfo = userFeign.findUserInfo(username);<br>        <span class="hljs-comment">//创建User对象</span><br>        String permissions = <span class="hljs-string">&quot;salesman, accountant, user&quot;</span>;<br>        UserJwt userDetails = <span class="hljs-keyword">new</span> UserJwt(username,userInfo.getPassword(),AuthorityUtils.commaSeparatedStringToAuthorityList(permissions));<br>        <span class="hljs-keyword">return</span> userDetails;<br></code></pre></td></tr></table></figure><p>上述代码给登录用户定义了两个个角色，分别为goods_list,seckill_list，这一块我们目前使用的是硬编码方式将角色写死了。</p><p>在这里我们先进行一次登录操作，输入地址：<a href="http://localhost:8001/api/oauth/login">http://localhost:8001/api/oauth/login</a></p><p>登录成功</p><p><img src="/images/image-20210807193630600.png" alt="image-20210807193630600"></p><p>此时我们去redis里面看有没有data部分的jti和相应的token值, 发现是存在的</p><p><img src="/images/image-20210807193740222.png" alt="image-20210807193740222"></p><p>我么可以用之前编写好的解析令牌的测试类来解析令牌里面的内容</p><p>解析类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseJwtTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJwt</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//基于公钥去解析jwt</span><br>        String jwt =<span class="hljs-string">&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzY29wZSI6WyJhcHAiXSwibmFtZSI6bnVsbCwiaWQiOm51bGwsImV4cCI6MTYyODM3OTE0OCwiYXV0aG9yaXRpZXMiOlsic2Vja2lsbF9saXN0IiwiZ29vZHNfbGlzdCJdLCJqdGkiOiI3YjIwYTBkNS04NzI5LTRkMWMtYTY4YS0xM2IyM2MwYmUyNzMiLCJjbGllbnRfaWQiOiJjaGFuZ2dvdSIsInVzZXJuYW1lIjoiaGVpbWEifQ.XjAafeLs2QrMJH3BkBpqLknmdUe4Tumi7gv3Yxh5Vpt5mj1KizFWnfjYwHZHuLKZkHkNcDRH933D472HK95bFX4Ag_1bDjFrj2X5CzV6-fb7L3ncl_rZxoOAoES2J0GEquQGdx04KqB0uIlUFI-jMQ0wL0Lufz9LIDCF_2F1dXJQvV6sWQVkFQeVvE11_z5_Cn8Z7FMPIwYPmsidSDeE7aPldJpG4cNnY4YDyZQVhVJjdANP02Vx83ysDd5dDpmtNCNcGqVR3c2qBp49bewH0QjUmlfhhm_EbR9C_8NPk7XTlrZEPYzapSU27qIGhNaNHLjqZP9jOkRowHqoi2dUuw&quot;</span>;<br><br>        String publicKey =<span class="hljs-string">&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvFsEiaLvij9C1Mz+oyAmt47whAaRkRu/8kePM+X8760UGU0RMwGti6Z9y3LQ0RvK6I0brXmbGB/RsN38PVnhcP8ZfxGUH26kX0RK+tlrxcrG+HkPYOH4XPAL8Q1lu1n9x3tLcIPxq8ZZtuIyKYEmoLKyMsvTviG5flTpDprT25unWgE4md1kthRWXOnfWHATVY7Y/r4obiOL1mS5bEa/iNKotQNnvIAKtjBM4RlIDWMa6dmz+lHtLtqDD2LF1qwoiSIHI75LQZ/CNYaHCfZSxtOydpNKq8eb1/PGiLNolD4La2zf0/1dlcr5mkesV570NxRmU1tFm8Zd3MZlZmyv9QIDAQAB-----END PUBLIC KEY-----&quot;</span>;<br><br>        Jwt token = JwtHelper.decodeAndVerify(jwt, <span class="hljs-keyword">new</span> RsaVerifier(publicKey));<br><br>        String claims = token.getClaims();<br>        System.out.println(claims);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到里面的三个权限是之前定义好的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;scope&quot;</span>:[<span class="hljs-string">&quot;app&quot;</span>],<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-attr">&quot;exp&quot;</span>:<span class="hljs-number">1628379737</span>,<span class="hljs-attr">&quot;authorities&quot;</span>:[<span class="hljs-string">&quot;accountant&quot;</span>,<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;salesman&quot;</span>],<span class="hljs-attr">&quot;jti&quot;</span>:<span class="hljs-string">&quot;2c87dd69-7a16-469a-9033-f7fb158b2317&quot;</span>,<span class="hljs-attr">&quot;client_id&quot;</span>:<span class="hljs-string">&quot;changgou&quot;</span>,<span class="hljs-attr">&quot;username&quot;</span>:<span class="hljs-string">&quot;heima&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-角色权限控制"><a href="#1-2-角色权限控制" class="headerlink" title="1.2 角色权限控制"></a>1.2 角色权限控制</h3><p>在每个微服务中，需要获取用户的角色，然后根据角色识别是否允许操作指定的方法，Spring Security中定义了四个支持权限控制的表达式注解，分别是<code>@PreAuthorize</code>、<code>@PostAuthorize</code>、<code>@PreFilter</code>和<code>@PostFilter</code>。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。在需要控制权限的方法上，我们可以添加<code>@PreAuthorize</code>注解，用于方法执行前进行权限检查，校验用户当前角色是否能访问该方法。</p><ol><li><p>开启@PreAuthorize</p><p>在<code>changgou-service-user</code>的<code>ResourceServerConfig</code>类上添加<code>@EnableGlobalMethodSecurity</code>注解，用于开启@PreAuthorize的支持，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableResourceServer</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span><span class="hljs-comment">//激活方法上的PreAuthorize注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法权限控制</p><p>在<code>changgou-service-user</code>微服务的<code>com.changgou.user.controller.UserController</code>类的delete()方法上添加权限控制注解<code>@PreAuthorize</code>，代码如下：</p><p>注意：</p><ul><li><code>@PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;)&quot;)</code>表示只有admin角色才能访问该方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;)&quot;)</span><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;<br>    List&lt;User&gt; userList = userService.findAll();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;查询成功&quot;</span>,userList) ;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>我们使用Postman测试，先创建令牌，然后将令牌数存放到头文件中访问微服务网关来调用user微服务的search方法，效果如下：</p><p>提交方式：GET，地址：<a href="http://localhost:8001/api/user">http://localhost:8001/api/user</a> </p><p>发现上面无法访问，因为用户登录的时候，角色不包含admin角色，而findAll方法需要admin角色，所以被拦截了。</p><p>我们再测试其他方法，其他方法没有配置拦截，所以用户登录后就会放行。</p></li></ol><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>如果希望一个方法能被多个角色访问，配置:<code>@PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;user&#39;)&quot;)</code></p><p>如果希望一个类都能被多个角色访问，在类上配置:<code>@PreAuthorize(&quot;hasAnyAuthority(&#39;admin&#39;,&#39;user&#39;)&quot;)</code></p><h2 id="2-购物车"><a href="#2-购物车" class="headerlink" title="2. 购物车"></a>2. 购物车</h2><p>购物车分为用户登录购物车和未登录购物车操作，国内知名电商京东用户登录和不登录都可以操作购物车，如果用户不登录，操作购物车可以将数据存储到Cookie，用户登录后购物车数据可以存储到Redis中，再将之前未登录加入的购物车合并到Redis中即可。</p><p>淘宝天猫则采用了另外一种实现方案，用户要想将商品加入购物车，必须先登录才能操作购物车。</p><p>我们今天实现的购物车是天猫解决方案，即用户必须先登录才能使用购物车功能。</p><h3 id="2-1-购物车业务分析"><a href="#2-1-购物车业务分析" class="headerlink" title="2.1 购物车业务分析"></a>2.1 购物车业务分析</h3><ol><li><p>需求分析</p><p>用户在商品详细页点击加入购物车，提交商品SKU编号和购买数量，添加到购物车。购物车展示页面如下：</p><p><img src="/images/image-20210807195831748.png" alt="image-20210807195831748"></p></li><li><p>购物车实现思路</p><p><img src="/images/image-20210807195957757.png" alt="image-20210807195957757"></p><p>我们实现的是用户登录后的购物车，用户将商品加入购物车的时候，直接将要加入购物车的详情存入到Redis即可。每次查看购物车的时候直接从Redis中获取。</p></li><li><p>表结构分析</p><p>用户登录后将商品加入购物车，需要存储商品详情以及购买数量，购物车详情表如下：</p><p>changgou_order数据中tb_order_item表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_order_item` (<br>  `id` varchar(20) COLLATE utf8_bin NOT NULL COMMENT &#x27;ID&#x27;,<br>  `category_id1` int(11) DEFAULT NULL COMMENT &#x27;1级分类&#x27;,<br>  `category_id2` int(11) DEFAULT NULL COMMENT &#x27;2级分类&#x27;,<br>  `category_id3` int(11) DEFAULT NULL COMMENT &#x27;3级分类&#x27;,<br>  `spu_id` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;SPU_ID&#x27;,<br>  `sku_id` bigint(20) NOT NULL COMMENT &#x27;SKU_ID&#x27;,<br>  `order_id` bigint(20) NOT NULL COMMENT &#x27;订单ID&#x27;,<br>  `name` varchar(200) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;商品名称&#x27;,<br>  `price` int(20) DEFAULT NULL COMMENT &#x27;单价&#x27;,<br>  `num` int(10) DEFAULT NULL COMMENT &#x27;数量&#x27;,<br>  `money` int(20) DEFAULT NULL COMMENT &#x27;总金额&#x27;,<br>  `pay_money` int(11) DEFAULT NULL COMMENT &#x27;实付金额&#x27;,<br>  `image` varchar(200) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;图片地址&#x27;,<br>  `weight` int(11) DEFAULT NULL COMMENT &#x27;重量&#x27;,<br>  `post_fee` int(11) DEFAULT NULL COMMENT &#x27;运费&#x27;,<br>  `is_return` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;是否退货&#x27;,<br>  PRIMARY KEY (`id`),<br>  KEY `item_id` (`sku_id`),<br>  KEY `order_id` (`order_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-添加购物车"><a href="#2-2-添加购物车" class="headerlink" title="2.2 添加购物车"></a>2.2 添加购物车</h3><p><img src="/images/image-20210807200521515.png" alt="image-20210807200521515"></p><h4 id="2-2-1-获取sku数据"><a href="#2-2-1-获取sku数据" class="headerlink" title="2.2.1 获取sku数据"></a>2.2.1 获取sku数据</h4><p>goods服务中定义根据id查询sku对象实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Sku&gt; <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    Sku sku = skuService.findById(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;查询成功&quot;</span>,sku);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-定义feign接口"><a href="#2-2-2-定义feign接口" class="headerlink" title="2.2.2 定义feign接口"></a>2.2.2 定义feign接口</h4><p>goods.api工程中定义skuFeign接口,并定义查询方法</p><p>注意：</p><ul><li><code>@FeignClient(name=&quot;goods&quot;)</code>和<code>@FeignClient(value=&quot;goods&quot;)</code>表示的是一个意思：指定服务的提供方为goods(这个就是服务的名字，在他的配置文件里定义了的)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;goods&quot;)</span>  <span class="hljs-comment">//表示goods是服务提供方，必须为客户端指定服务提供方，name和value是一个意思</span><br><span class="hljs-meta">@RequestMapping(&quot;/sku&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SkuFeign</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Sku&gt; <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-订单服务添加依赖"><a href="#2-2-3-订单服务添加依赖" class="headerlink" title="2.2.3 订单服务添加依赖"></a>2.2.3 订单服务添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_goods_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-4-订单服务启动类添加feign接口扫描"><a href="#2-2-4-订单服务启动类添加feign接口扫描" class="headerlink" title="2.2.4 订单服务启动类添加feign接口扫描"></a>2.2.4 订单服务启动类添加feign接口扫描</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.changgou.goods.feign&quot;)</span><br></code></pre></td></tr></table></figure><h4 id="2-2-5-订单服务添加cartService及其实现类"><a href="#2-2-5-订单服务添加cartService及其实现类" class="headerlink" title="2.2.5 订单服务添加cartService及其实现类"></a>2.2.5 订单服务添加cartService及其实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CartService</span> </span>&#123;<br><br>    <span class="hljs-comment">//添加购物车</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCart</span><span class="hljs-params">(String skuId, Integer num, String username)</span></span>;<br><br>    <span class="hljs-comment">//查询购物车数据</span><br>    <span class="hljs-function">Map <span class="hljs-title">list</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CartService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CART=<span class="hljs-string">&quot;cart_&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SkuFeign skuFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SpuFeign spuFeign;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCart</span><span class="hljs-params">(String skuId, Integer num, String username)</span> </span>&#123;<br>        <span class="hljs-comment">//1.查询redis中相对应的商品信息</span><br>        OrderItem orderItem = (OrderItem) redisTemplate.boundHashOps(CART+username).get(skuId);<br>        <span class="hljs-keyword">if</span> (orderItem != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//2.如果当前商品在redis中的存在,则更新商品的数量与价钱</span><br>            orderItem.setNum(orderItem.getNum()+num);<br>            <span class="hljs-keyword">if</span> (orderItem.getNum()&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//删除该商品</span><br>                redisTemplate.boundHashOps(CART+username).delete(skuId);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            orderItem.setMoney(orderItem.getNum()*orderItem.getPrice());<br>            orderItem.setPayMoney(orderItem.getNum()*orderItem.getPrice());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//3.如果当前商品在redis中不存在,将商品添加到redis中</span><br>            Sku sku = skuFeign.findById(skuId).getData();<br>            Spu spu = spuFeign.findSpuById(sku.getSpuId()).getData();<br><br>            <span class="hljs-comment">//封装orderItem</span><br>           orderItem = <span class="hljs-keyword">this</span>.sku2OrderItem(sku,spu,num);<br>        &#125;<br><br>        <span class="hljs-comment">//3.将orderitem添加到redis中</span><br>        redisTemplate.boundHashOps(CART+username).put(skuId,orderItem);<br>    &#125;<br><br>    <span class="hljs-comment">//查询购物车列表数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        Map map = <span class="hljs-keyword">new</span> HashMap();<br><br>        List&lt;OrderItem&gt; orderItemList = redisTemplate.boundHashOps(CART + username).values();<br>        map.put(<span class="hljs-string">&quot;orderItemList&quot;</span>,orderItemList);<br><br>        <span class="hljs-comment">//商品的总数量与总价格</span><br>        Integer totalNum = <span class="hljs-number">0</span>;<br>        Integer totalMoney = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (OrderItem orderItem : orderItemList) &#123;<br>            totalNum+=orderItem.getNum();<br>            totalMoney+=orderItem.getMoney();<br>        &#125;<br><br>        map.put(<span class="hljs-string">&quot;totalNum&quot;</span>,totalNum);<br>        map.put(<span class="hljs-string">&quot;totalMoney&quot;</span>,totalMoney);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> OrderItem <span class="hljs-title">sku2OrderItem</span><span class="hljs-params">(Sku sku, Spu spu, Integer num)</span> </span>&#123;<br>        OrderItem orderItem = <span class="hljs-keyword">new</span> OrderItem();<br>        orderItem.setSpuId(sku.getSpuId());<br>        orderItem.setSkuId(sku.getId());<br>        orderItem.setName(sku.getName());<br>        orderItem.setPrice(sku.getPrice());<br>        orderItem.setNum(num);<br>        orderItem.setMoney(orderItem.getPrice()*num);<br>        orderItem.setPayMoney(orderItem.getPrice()*num);<br>        orderItem.setImage(sku.getImage());<br>        orderItem.setWeight(sku.getWeight()*num);<br>        <span class="hljs-comment">//分类信息</span><br>        orderItem.setCategoryId1(spu.getCategory1Id());<br>        orderItem.setCategoryId2(spu.getCategory2Id());<br>        orderItem.setCategoryId3(spu.getCategory3Id());<br>        <span class="hljs-keyword">return</span> orderItem;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-6-订单服务新建CartController"><a href="#2-2-6-订单服务新建CartController" class="headerlink" title="2.2.6 订单服务新建CartController"></a>2.2.6 订单服务新建CartController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/cart&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CartService cartService;<br><br>    <span class="hljs-comment">/*@Autowired</span><br><span class="hljs-comment">    private TokenDecode tokenDecode;*/</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/addCart&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addCart</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;skuId&quot;)</span> String skuId, <span class="hljs-meta">@RequestParam(&quot;num&quot;)</span> Integer num)</span></span>&#123;<br><br>        <span class="hljs-comment">//动态获取当前人信息,暂时静态</span><br>        String username = <span class="hljs-string">&quot;itcast&quot;</span>;<br><span class="hljs-comment">//        String username = tokenDecode.getUserInfo().get(&quot;username&quot;);</span><br>        cartService.addCart(skuId,num,username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;加入购物车成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//动态获取当前人信息,暂时静态</span><br>        String username = <span class="hljs-string">&quot;itcast&quot;</span>;<br><span class="hljs-comment">//        String username = tokenDecode.getUserInfo().get(&quot;username&quot;);</span><br>        Map map = cartService.list(username);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后测试添加购物车，请求地址：localhost:9002/cart/addCart?skuId=100000003145&amp;num=1</p><p>效果如下：</p><p><img src="/images/image-20210807205116509.png" alt="image-20210807205116509"></p><p>可以发现redis缓存中已经有商品了</p><p><img src="/images/image-20210807205216459.png" alt="image-20210807205216459"></p><h3 id="2-3-购物车列表"><a href="#2-3-购物车列表" class="headerlink" title="2.3 购物车列表"></a>2.3 购物车列表</h3><h4 id="2-3-1-思路分析"><a href="#2-3-1-思路分析" class="headerlink" title="2.3.1 思路分析"></a>2.3.1 思路分析</h4><p><img src="/images/image-20210807205435727.png" alt="image-20210807205435727"></p><p>接着我们实现一次购物车列表操作。因为存的时候是根据用户名往Redis中存储用户的购物车数据的，所以我们这里可以将用户的名字作为key去Redis中查询对应的数据。##</p><h4 id="2-3-2-代码实现"><a href="#2-3-2-代码实现" class="headerlink" title="2.3.2 代码实现"></a>2.3.2 代码实现</h4><ol><li><p>业务层</p><p>com.changgou.order.service.CartService接口，添加购物车列表方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询购物车数据</span><br><span class="hljs-function">Map <span class="hljs-title">list</span><span class="hljs-params">(String username)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>业务层接口实现类</p><p>com.changgou.order.service.impl.CartServiceImpl类，添加购物车列表实现方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询购物车列表数据</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">(String username)</span> </span>&#123;<br>    Map map = <span class="hljs-keyword">new</span> HashMap();<br>   <br>    List&lt;OrderItem&gt; orderItemList = redisTemplate.boundHashOps(CART + username).values();<br>    map.put(<span class="hljs-string">&quot;orderItemList&quot;</span>,orderItemList);<br>   <br>    <span class="hljs-comment">//商品的总数量与总价格</span><br>    Integer totalNum = <span class="hljs-number">0</span>;<br>    Integer totalMoney = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-keyword">for</span> (OrderItem orderItem : orderItemList) &#123;<br>        totalNum+=orderItem.getNum();<br>        totalMoney+=orderItem.getMoney();<br>    &#125;<br>   <br>    map.put(<span class="hljs-string">&quot;totalNum&quot;</span>,totalNum);<br>    map.put(<span class="hljs-string">&quot;totalMoney&quot;</span>,totalMoney);<br>   <br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 查询用户购物车列表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//暂时静态，后续修改</span><br>    String username = <span class="hljs-string">&quot;itcast&quot;</span>;<br>    <span class="hljs-keyword">return</span> cartService.list(username);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>使用Postman访问 GET <a href="http://localhost:9002/cart/list">http://localhost:9002/cart/list</a></p><p>效果如下</p><p><img src="/images/image-20210807210847527.png" alt="image-20210807210847527"></p></li></ol><h2 id="3-购物车渲染"><a href="#3-购物车渲染" class="headerlink" title="3. 购物车渲染"></a>3. 购物车渲染</h2><h3 id="3-1-购物车渲染服务搭建"><a href="#3-1-购物车渲染服务搭建" class="headerlink" title="3.1 购物车渲染服务搭建"></a>3.1 购物车渲染服务搭建</h3><p>在changgou_web中搭建订单购物车微服务工程<code>changgou_web_order</code>，该工程主要实现购物车和订单的渲染操作。</p><ol><li><p>导入pom文件依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_order_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>application.yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9011</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-web</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment">#当遇到同样名字的时候，是否允许覆盖注册</span><br>  <span class="hljs-attr">thymeleaf:</span><br>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span>   <span class="hljs-comment">#配置全局的feign的调用超时时间  如果 有指定的服务配置 默认的配置不会生效</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">60000</span> <span class="hljs-comment"># 指定的是 消费者 连接服务提供者的连接超时时间 是否能连接  单位是毫秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">80000</span>  <span class="hljs-comment"># 指定的是调用服务提供者的 服务 的超时时间（）  单位是毫秒</span><br><span class="hljs-comment">#hystrix 配置</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">timeout:</span><br>          <span class="hljs-comment">#如果enabled设置为false，则请求超时交给ribbon控制</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">strategy:</span> <span class="hljs-string">SEMAPHORE</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-comment"># 熔断器超时时间，默认：1000/毫秒</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">80000</span><br><span class="hljs-comment">#请求处理的超时时间</span><br><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">4000</span><br>  <span class="hljs-comment">#请求连接的超时时间</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure></li><li><p>创建启动类</p><p>创建com.changgou.OrderWebApplication启动类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderWebApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(OrderWebApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>静态资源拷贝</p><p>资源\成品页面\cart.html页面拷贝到工程中，如下图：</p><p><img src="/images/image-20210807225516860.png" alt="image-20210807225516860"></p></li></ol><h3 id="3-2-购物车列表渲染"><a href="#3-2-购物车列表渲染" class="headerlink" title="3.2 购物车列表渲染"></a>3.2 购物车列表渲染</h3><ol><li><p>Feign创建</p><p>在changgou_service_order_api中添加CartFeign接口，并在接口中创建添加购物车和查询购物车列表，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CartFeign</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/cart/addCart&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addCart</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;skuId&quot;)</span> String skuId, <span class="hljs-meta">@RequestParam(&quot;num&quot;)</span> Integer num)</span></span>;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/cart/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后台代码</p><p>在changgou_web_order中创建com.changgou.order.controller.CartController,并添加查询购物车集合方法和添加购物车方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/wcart&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CartFeign cartFeign;<br><br>    <span class="hljs-comment">//查询</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        Map map = cartFeign.list();<br>        model.addAttribute(<span class="hljs-string">&quot;items&quot;</span>,map);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cart&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">//添加</span><br>    <span class="hljs-meta">@GetMapping(&quot;/add&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Map&gt; <span class="hljs-title">add</span><span class="hljs-params">(String id,Integer num)</span></span>&#123;<br>        cartFeign.addCart(id,num);<br>        Map map = cartFeign.list();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;添加购物车成功&quot;</span>,map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>前端页面</p><ul><li>加载列表数据</li><li>购物车渲染服务</li></ul><p>这里暂时不细学，后面系统学期前端再深入</p></li><li><p>订单服务对接网关</p><p>修改微服务网关<code>changgou-gateway-web</code>的application.yml配置文件，添加order的路由过滤配置，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-comment">#认证微服务</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_oauth_user</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-auth</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/oauth/**</span><br>  <span class="hljs-attr">filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_order_route</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/cart/**,/api/categoryReport/**,/api/orderConfig/**,/api/order/**,/api/orderItem/**,/api/orderLog/**,/api/preferential/**,/api/returnCause/**,/api/returnOrder/**,/api/returnOrderItem/**</span><br>  <span class="hljs-attr">filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>  <span class="hljs-comment">#购物车订单渲染微服务</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_order_web_route</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-web</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/wcart/**,/api/worder/**</span><br>  <span class="hljs-attr">filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>由于开启了网关，要先登录才能访问</p><p>登录路径：<a href="http://192.168.114.1:8001/api/oauth/toLogin">http://192.168.114.1:8001/api/oauth/toLogin</a></p><p>访问购物车路径（我的登录界面的权限好像存在问题，登录没上，显示未授权）：<a href="http://localhost:8001/api/wcart/list">http://localhost:8001/api/wcart/list</a></p></li></ol><h3 id="3-3-商品数量变更"><a href="#3-3-商品数量变更" class="headerlink" title="3.3 商品数量变更"></a>3.3 商品数量变更</h3><p>用户可以点击+号或者-号，或者手动输入一个数字，然后更新购物车列表，我们可以给-+号一个点击事件，给数字框一个失去焦点事件，然后调用后台，实现购物车的更新。</p><p>请求后台方法：</p><p>在js里面创建一个请求后台的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,<br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">items</span>:[[$&#123;items&#125;]]<br>&#125;,<br><span class="hljs-attr">methods</span>:&#123;<br><span class="hljs-attr">add</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">skuId,num</span>) </span>&#123;<br>axios.get(<span class="hljs-string">&quot;/api/wcart/add?id=&quot;</span>+skuId+<span class="hljs-string">&quot;&amp;num=&quot;</span>+num).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (response.data.flag)&#123;<br>app.items=response.data.data;<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>添加事件：</p><p>在+-号和数字框那里添加点击事件和失去焦点事件，然后调用上面的add方法，代码如下：</p><p><img src="/images/image-20210807223449940.png" alt="image-20210807223449940"></p><h3 id="3-4-删除商品购物车"><a href="#3-4-删除商品购物车" class="headerlink" title="3.4 删除商品购物车"></a>3.4 删除商品购物车</h3><p>我们发现个问题，就是用户将商品加入购物车，无论数量是正负，都会执行添加购物车，如果数量如果&lt;=0，应该移除该商品的。</p><p>修改changgou-service-order的com.changgou.order.service.impl.CartServiceImpl的add方法，添加如下代码：</p><p><img src="/images/image-20210807223724709.png" alt="image-20210807223724709"></p><h3 id="3-5-订单服务对接oauth"><a href="#3-5-订单服务对接oauth" class="headerlink" title="3.5 订单服务对接oauth"></a>3.5 订单服务对接oauth</h3><p>在订单微服务里进行的</p><ol><li><p>配置公钥</p></li><li><p>在pom文件中导入oauth依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableResourceServer</span><br><span class="hljs-comment">//开启方法上的PreAuthorize注解</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">//公钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PUBLIC_KEY = <span class="hljs-string">&quot;public.key&quot;</span>;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 定义JwtTokenStore</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jwtAccessTokenConverter</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">(JwtAccessTokenConverter jwtAccessTokenConverter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 定义JJwtAccessTokenConverter</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;<br>        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();<br>        converter.setVerifierKey(getPubKey());<br>        <span class="hljs-keyword">return</span> converter;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取非对称加密公钥 Key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 公钥 Key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPubKey</span><span class="hljs-params">()</span> </span>&#123;<br>        Resource resource = <span class="hljs-keyword">new</span> ClassPathResource(PUBLIC_KEY);<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(resource.getInputStream());<br>            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);<br>            <span class="hljs-keyword">return</span> br.lines().collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * Http安全配置，对每个到达系统的http请求链接进行校验</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> http</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//所有请求必须认证通过</span><br>        http.authorizeRequests()<br>                .anyRequest().<br>                authenticated();    <span class="hljs-comment">//其他地址需要认证授权</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-6-微服务间认证"><a href="#3-6-微服务间认证" class="headerlink" title="3.6 微服务间认证"></a>3.6 微服务间认证</h3><p><img src="/images/image-20210807224437427.png" alt="image-20210807224437427"></p><p>如上图：因为微服务之间并没有传递头文件，所以我们可以定义一个拦截器，每次微服务调用之前都先检查下头文件，将请求的头文件中的令牌数据再放入到header中，再调用其他微服务即可。</p><p><strong>feign拦截器实现微服务间认证</strong></p><ol><li><p>创建拦截器</p><p>在changgou_common服务中创建一个com.changgou.interceptor.FeignInterceptor拦截器，并将所有头文件数据再次加入到Feign请求的微服务头文件中，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;<br>        <span class="hljs-comment">//传递令牌</span><br>        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>)&#123;<br>            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();<br>            <span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>)&#123;<br>                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();<br>                <span class="hljs-keyword">while</span> (headerNames.hasMoreElements())&#123;<br>                    String headerName = headerNames.nextElement();<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;authorization&quot;</span>.equals(headerName))&#123;<br>                        String headerValue = request.getHeader(headerName); <span class="hljs-comment">// Bearer jwt</span><br><br>                        <span class="hljs-comment">//传递令牌</span><br>                        requestTemplate.header(headerName,headerValue);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改changgou_order_web启动类，添加拦截器声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FeignInterceptor <span class="hljs-title">feignInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignInterceptor();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-7-动态获取当前登录人"><a href="#3-7-动态获取当前登录人" class="headerlink" title="3.7 动态获取当前登录人"></a>3.7 动态获取当前登录人</h3><h4 id="3-7-1-数据分析"><a href="#3-7-1-数据分析" class="headerlink" title="3.7.1 数据分析"></a>3.7.1 数据分析</h4><p>用户登录后，数据会封装到<code>SecurityContextHolder.getContext().getAuthentication()</code>里面，我们可以将数据从这里面取出，然后转换成<code>OAuth2AuthenticationDetails</code>,在这里面可以获取到令牌信息、令牌类型等，代码如下（这里的代码不是自己编写的）：</p><p><img src="/images/image-20210807230417232.png" alt="image-20210807230417232"></p><p>这里的tokenValue是加密之后的令牌数据，remoteAddress是用户的IP信息，tokenType是令牌类型。</p><p>我们可以获取令牌加密数据后，使用公钥对它进行解密，如果能解密说明数据无误，如果不能解密用户也没法执行到这一步。解密后可以从明文中获取用户信息。</p><h4 id="3-7-2-代码实现"><a href="#3-7-2-代码实现" class="headerlink" title="3.7.2 代码实现"></a>3.7.2 代码实现</h4><p>因为该类在很多微服务中都会被使用到，所以需要将该类添加到common工程中</p><ol><li><p>在changgou-common工程中引入鉴权包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--鉴权--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加资源中的TokenDecode工具类到changgou-service-order微服务config包下，用于解密令牌信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenDecode</span> </span>&#123;<br>    <span class="hljs-comment">//公钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PUBLIC_KEY = <span class="hljs-string">&quot;public.key&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String publickey=<span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取用户信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,String&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//获取授权信息</span><br>        OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) SecurityContextHolder.getContext().getAuthentication().getDetails();<br>        <span class="hljs-comment">//令牌解码</span><br>        <span class="hljs-keyword">return</span> dcodeToken(details.getTokenValue());<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 读取令牌数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,String&gt; <span class="hljs-title">dcodeToken</span><span class="hljs-params">(String token)</span></span>&#123;<br>        <span class="hljs-comment">//校验Jwt</span><br>        Jwt jwt = JwtHelper.decodeAndVerify(token, <span class="hljs-keyword">new</span> RsaVerifier(getPubKey()));<br><br>        <span class="hljs-comment">//获取Jwt原始内容</span><br>        String claims = jwt.getClaims();<br>        <span class="hljs-keyword">return</span> JSON.parseObject(claims,Map.class);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取非对称加密公钥 Key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 公钥 Key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPubKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(publickey))&#123;<br>            <span class="hljs-keyword">return</span> publickey;<br>        &#125;<br>        Resource resource = <span class="hljs-keyword">new</span> ClassPathResource(PUBLIC_KEY);<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(resource.getInputStream());<br>            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);<br>            publickey = br.lines().collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));<br>            <span class="hljs-keyword">return</span> publickey;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将该工具类以bean的形式声明到order服务中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.changgou.goods.feign&quot;)</span><br><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.changgou.order.dao&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run( OrderApplication.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenDecode <span class="hljs-title">tokenDecode</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TokenDecode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层获取用户数据</p><p>在CartController中注入TokenDecode，并调用TokenDecode的getUserInfo方法获取用户信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/cart&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CartService cartService;<br><br>    <span class="hljs-comment">//===================</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TokenDecode tokenDecode;<br>    <span class="hljs-comment">//===================</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/addCart&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addCart</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;skuId&quot;)</span> String skuId, <span class="hljs-meta">@RequestParam(&quot;num&quot;)</span> Integer num)</span></span>&#123;<br><br>        <span class="hljs-comment">//===================</span><br>        <span class="hljs-comment">//动态获取当前人信息,暂时静态</span><br>        <span class="hljs-comment">//String username = &quot;itcast&quot;;</span><br>        String username = tokenDecode.getUserInfo().get(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">//===================</span><br>        <br>        cartService.addCart(skuId,num,username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;加入购物车成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 查询用户购物车列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">list</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-comment">//===================</span><br>        <span class="hljs-comment">//暂时静态，后续修改</span><br><span class="hljs-comment">//        String username = &quot;itcast&quot;;</span><br>        String username = tokenDecode.getUserInfo().get(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">//===================</span><br>        <br>        <span class="hljs-keyword">return</span> cartService.list(username);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-8-页面跳转"><a href="#3-8-页面跳转" class="headerlink" title="3.8 页面跳转"></a>3.8 页面跳转</h3><h4 id="3-9-1-未登录时登录跳转"><a href="#3-9-1-未登录时登录跳转" class="headerlink" title="3.9.1 未登录时登录跳转"></a>3.9.1 未登录时登录跳转</h4><p>在用户没有登录的情况下，直接访问购物车页面会报401(未授权错误)。</p><p>我们可以发现，返回的只是个错误状态码，这个毫无意义，我们应该重定向到登录页面，让用户登录，我们可以修改网关的头文件，让用户每次没登录的时候，都跳转到登录页面。</p><p>修改changgou-gateway-web的<code>com.changgou.filter.AuthorizeFilter</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOGIN_URL=<span class="hljs-string">&quot;http://localhost:8001/api/oauth/toLogin&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthService authService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        ServerHttpRequest request = exchange.getRequest();<br>        ServerHttpResponse response = exchange.getResponse();<br><br>        <span class="hljs-comment">//1.判断当前请求路径是否为登录请求,如果是,则直接放行</span><br>        String path = request.getURI().getPath();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/api/oauth/login&quot;</span>.equals(path) || !UrlFilter.hasAuthorize(path))&#123;<br>            <span class="hljs-comment">//直接放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>        <span class="hljs-comment">//2.从cookie中获取jti的值,如果该值不存在,拒绝本次访问</span><br>        String jti = authService.getJtiFromCookie(request);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(jti))&#123;<br>            <span class="hljs-comment">//拒绝访问</span><br>            <span class="hljs-comment">/*response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="hljs-comment">            return response.setComplete();*/</span><br>            <span class="hljs-comment">//跳转登录页面</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toLoginPage(LOGIN_URL+<span class="hljs-string">&quot;?FROM=&quot;</span>+request.getURI().getPath(),exchange);<br>        &#125;<br><br>        <span class="hljs-comment">//3.从redis中获取jwt的值,如果该值不存在,拒绝本次访问</span><br>        String jwt = authService.getJwtFromRedis(jti);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(jwt))&#123;<br>            <span class="hljs-comment">//拒绝访问</span><br>            <span class="hljs-comment">/*response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="hljs-comment">            return response.setComplete();*/</span><br>            <span class="hljs-keyword">return</span>  <span class="hljs-keyword">this</span>.toLoginPage(LOGIN_URL,exchange);<br>        &#125;<br><br>        <span class="hljs-comment">//4.对当前的请求对象进行增强,让它会携带令牌的信息</span><br>        request.mutate().header(<span class="hljs-string">&quot;Authorization&quot;</span>,<span class="hljs-string">&quot;Bearer &quot;</span>+jwt);<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">//跳转登录页面</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title">toLoginPage</span><span class="hljs-params">(String loginUrl, ServerWebExchange exchange)</span> </span>&#123;<br>        ServerHttpResponse response = exchange.getResponse();<br>        response.setStatusCode(HttpStatus.SEE_OTHER);<br>        response.getHeaders().set(<span class="hljs-string">&quot;Location&quot;</span>,loginUrl);<br>        <span class="hljs-keyword">return</span> response.setComplete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时再测试，就可以跳转到登录页面了。</p><p>访问：<a href="http://localhost:8001/api/wcart/list">http://localhost:8001/api/wcart/list</a></p><h4 id="3-8-2-登录成功跳转原地址"><a href="#3-8-2-登录成功跳转原地址" class="headerlink" title="3.8.2 登录成功跳转原地址"></a>3.8.2 登录成功跳转原地址</h4><p>刚才已经实现了未登录时跳转登录页，但是当登录成功后，并没有跳转到用户本来要访问的页面。(这个功能在3.8.1已经实现了，这里熟悉下流程)</p><p>要实现这个功能的话，可以将用户要访问的页面作为参数传递到登录控制器，由登录控制器根据参数完成路径跳转.</p><ol><li><p>修改网关携带当前访问URI</p><p>修改changgou-gateway-web的<code>com.changgou.filter.AuthorizeFilter</code>，在之前的URL后面添加FROM参数以及FROM参数的值为<code>request.getURI()</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2.从cookie中获取jti的值,如果该值不存在,拒绝本次访问</span><br>String jti = authService.getJtiFromCookie(request);<br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(jti))&#123;<br>    <span class="hljs-comment">//拒绝访问</span><br>    <span class="hljs-comment">/*response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="hljs-comment">    return response.setComplete();*/</span><br>    <span class="hljs-comment">//跳转登录页面</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toLoginPage(LOGIN_URL+<span class="hljs-string">&quot;?FROM=&quot;</span>+request.getURI().getPath(),exchange);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>登录控制器获取参数</p><p>修改changgou-user-oauth的<code>com.changgou.oauth.controller.LoginRedirect</code>记录访问来源页，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/toLogin&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;FROM&quot;,required = false,defaultValue = &quot;&quot;)</span> String from, Model model)</span></span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;from&quot;</span>,from);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改页面，获取来源页信息，并存到from变量中，登录成功后跳转到该地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,<br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">username</span>:<span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">password</span>:<span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;&quot;</span><br>&#125;,<br><span class="hljs-attr">methods</span>:&#123;<br><span class="hljs-attr">login</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>app.msg=<span class="hljs-string">&quot;正在登录&quot;</span>;<br>axios.post(<span class="hljs-string">&quot;/api/oauth/login?username=&quot;</span>+app.username+<span class="hljs-string">&quot;&amp;password=&quot;</span>+app.password).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (response.data.flag)&#123;<br>app.msg=<span class="hljs-string">&quot;登录成功&quot;</span>;<br>location.href-app.from<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>app.msg=<span class="hljs-string">&quot;登录失败&quot;</span>;<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>此时再测试，就可以识别未登录用户，跳转到登录页，然后根据登录状态，如果登录成功，则跳转到来源页。</p></li></ol><h1 id="Part11-订单"><a href="#Part11-订单" class="headerlink" title="Part11 订单"></a>Part11 订单</h1><h2 id="1-订单结算页"><a href="#1-订单结算页" class="headerlink" title="1. 订单结算页"></a>1. 订单结算页</h2><h3 id="1-1-收件地址分析"><a href="#1-1-收件地址分析" class="headerlink" title="1.1 收件地址分析"></a>1.1 收件地址分析</h3><p>用户从购物车页面点击结算，跳转到订单结算页，结算页需要加载用户对应的收件地址，如下图：</p><p><img src="/images/image-20210808120723726.png" alt="image-20210808120723726"></p><p>表结构分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_address` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `username` varchar(50) DEFAULT NULL COMMENT &#x27;用户名&#x27;,<br>  `provinceid` varchar(20) DEFAULT NULL COMMENT &#x27;省&#x27;,<br>  `cityid` varchar(20) DEFAULT NULL COMMENT &#x27;市&#x27;,<br>  `areaid` varchar(20) DEFAULT NULL COMMENT &#x27;县/区&#x27;,<br>  `phone` varchar(20) DEFAULT NULL COMMENT &#x27;电话&#x27;,<br>  `address` varchar(200) DEFAULT NULL COMMENT &#x27;详细地址&#x27;,<br>  `contact` varchar(50) DEFAULT NULL COMMENT &#x27;联系人&#x27;,<br>  `is_default` varchar(1) DEFAULT NULL COMMENT &#x27;是否是默认 1默认 0否&#x27;,<br>  `alias` varchar(50) DEFAULT NULL COMMENT &#x27;别名&#x27;,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>我们可以根据用户登录名去tb_address表中查询对应的数据。</p><h3 id="1-2-实现用户收件地址查询"><a href="#1-2-实现用户收件地址查询" class="headerlink" title="1.2 实现用户收件地址查询"></a>1.2 实现用户收件地址查询</h3><h4 id="1-2-1-代码实现"><a href="#1-2-1-代码实现" class="headerlink" title="1.2.1 代码实现"></a>1.2.1 代码实现</h4><ol><li><p>业务层接口</p><p>修改changgou-service-user微服务，需改com.changgou.user.service.AddressService接口，添加根据用户名字查询用户收件地址信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 收件地址查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;Address&gt; <span class="hljs-title">list</span><span class="hljs-params">(String username)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>业务层接口实现类</p><p>修改changgou-service-user微服务，修改impl.AddressServiceImpl类，添加根据用户查询用户收件地址信息实现方法，如下代码：</p><p>注意：</p><ul><li><p>不要忘了dao层的AddressMapper，是通过他才来操作数据库的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AddressMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Address</span>&gt; </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AddressService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AddressMapper addressMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Address&gt; <span class="hljs-title">list</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        Address address = <span class="hljs-keyword">new</span> Address();<br>        address.setUsername(username);<br>        List&lt;Address&gt; addressList = addressMapper.select(address);<br>        <span class="hljs-keyword">return</span> addressList;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层</p><p>修改changgou-service-user微服务，修改AddressController，添加根据用户名查询用户收件信息方法，代码如下：</p><p>注意：</p><ul><li><p><code>TokenDecode</code>要自己添加到spring容器。UserApplication中创建TokenDecode,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TokenDecode <span class="hljs-title">tokenDecode</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> TokenDecode();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> TokenDecode tokenDecode;<br><br><span class="hljs-comment">/****</span><br><span class="hljs-comment"> * 用户收件地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;List&lt;Address&gt;&gt; list()&#123;<br>    <span class="hljs-comment">//获取用户登录信息</span><br>    Map&lt;String, String&gt; userMap = tokenDecode.getUserInfo();<br>    String username = userMap.get(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-comment">//查询用户收件地址</span><br>    List&lt;Address&gt; addressList = addressService.list(username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;查询成功！&quot;</span>,addressList);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>首先进行登录：<a href="http://localhost:8001/api/oauth/login">http://localhost:8001/api/oauth/login</a></p><p><img src="/images/image-20210808123905648.png" alt="image-20210808123905648"></p><p>然后再进行访问 <a href="http://localhost:8001/api/address/list">http://localhost:8001/api/address/list</a></p></li></ol><h3 id="1-3-页面模板渲染"><a href="#1-3-页面模板渲染" class="headerlink" title="1.3 页面模板渲染"></a>1.3 页面模板渲染</h3><p><img src="/images/image-20210808124121419.png" alt="image-20210808124121419"></p><p>购物车这块也使用的是模板渲染，用户先请求经过微服务网关，微服务网关转发到订单购物车模板渲染服务，模板渲染服务调用用户微服务和订单购物车微服务查询用户收件地址和购物车清单，然后到页面显示。</p><h4 id="1-3-1-准备工作"><a href="#1-3-1-准备工作" class="headerlink" title="1.3.1 准备工作"></a>1.3.1 准备工作</h4><ol><li><p>静态资源导入</p><p>将资料中的<code>order.html</code>拷贝到<code>changgou-web-order</code>工程的templates中</p><p><img src="/images/image-20210808124632321.png" alt="image-20210808124632321"></p></li><li><p>页面跳转实现</p><p>在changgou-web-order中创建<code>com.changgou.order.controller.OrderController</code>实现页面跳转，代码如下：</p><p><img src="/images/image-20210808130134240.png" alt="image-20210808130134240"></p></li><li><p>网关配置</p><p>修改changgou-gateway-web的application.yml文件，将订单的路由过滤地址添加上去，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-comment">#购物车订单渲染微服务</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_order_web_route</span><br>  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order-web</span><br>  <span class="hljs-attr">predicates:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/wcart/**,/api/worder/**</span><br>  <span class="hljs-attr">filters:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>同时不要忘了把该地址添加到登录过滤地址中，修改<code>com.changgou.filter.URLFilter</code>，在orderFilterPath里添加<code>/api/worder/**</code>过滤</p></li></ol><h4 id="1-3-2-信息查询"><a href="#1-3-2-信息查询" class="headerlink" title="1.3.2 信息查询"></a>1.3.2 信息查询</h4><p>因为一会儿要调用changgou-service-user查询用户的收件地址信息，调用changgou-service-order查询购物车清单信息，所以我们需要创建Feign。购物车的Feign之前已经创建过了，所以只需要创建用户地址相关的即可。</p><ol><li><p>用户地址查询</p><p>在changgou-service-user-api中创建AddressFeign，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;user&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/address&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AddressFeign</span> </span>&#123;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 查询用户的收件地址信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span><br>    Result&lt;List&lt;Address&gt;&gt; list();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查询购物车和用户收件地址信息</p><p>修改changgou-web-order中的<code>com.changgou.order.controller.OrderController</code>的readyOrder方法，在该方法中，使用feign调用查询收件地址信息和用户购物车信息，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/worder&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AddressFeign addressFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CartFeign cartFeign;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/ready/order&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readyOrder</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        <span class="hljs-comment">//收件人的地址信息</span><br>        List&lt;Address&gt; addressList = addressFeign.list().getData();<br>        model.addAttribute(<span class="hljs-string">&quot;address&quot;</span>,addressList);<br><br>        <span class="hljs-comment">//购物车信息</span><br>        Map map = cartFeign.list();<br>        List&lt;OrderItem&gt; orderItemList = (List&lt;OrderItem&gt;) map.get(<span class="hljs-string">&quot;orderItemList&quot;</span>);<br>        Integer totalMoney = (Integer) map.get(<span class="hljs-string">&quot;totalMoney&quot;</span>);<br>        Integer totalNum = (Integer) map.get(<span class="hljs-string">&quot;totalNum&quot;</span>);<br><br>        model.addAttribute(<span class="hljs-string">&quot;carts&quot;</span>,orderItemList);<br>        model.addAttribute(<span class="hljs-string">&quot;totalMoney&quot;</span>,totalMoney);<br>        model.addAttribute(<span class="hljs-string">&quot;totalNum&quot;</span>,totalNum);<br><br>        <span class="hljs-comment">//默认收件人信息</span><br>        <span class="hljs-keyword">for</span> (Address address : addressList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;1&quot;</span>.equals(address.getIsDefault()))&#123;<br>                <span class="hljs-comment">//默认收件人</span><br>                model.addAttribute(<span class="hljs-string">&quot;deAddr&quot;</span>,address);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;order&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数据回显</p><p>修改order.html，回显收件地址信息和购物车信息，代码如下：</p><p>收件地址信息：</p><p><img src="/images/image-20210808131410819.png" alt="image-20210808131410819"></p><p>购物车清单：</p><p><img src="/images/image-20210808131443336.png" alt="image-20210808131443336"></p><p>测试效果：</p><p>基于登录过的前提下</p><p><img src="/images/image-20210808132559714.png" alt="image-20210808132559714"></p></li><li><p>默认收件地址选中</p><p>上面所有数据都查询出来了，但是用户的收件地址全部选中了(我这里提供的是完整的代码，所以上面只选中一个)，这里应该只有默认收件地址选中。修改order.html代码如下：</p><p><img src="/images/image-20210808132814643.png" alt="image-20210808132814643"></p><p>效果如下</p><p><img src="/images/image-20210808132730293.png" alt="image-20210808132730293"></p></li></ol><h4 id="1-3-3-记录选中收件人"><a href="#1-3-3-记录选中收件人" class="headerlink" title="1.3.3 记录选中收件人"></a>1.3.3 记录选中收件人</h4><p>用户每次点击收件人的时候，我们需要记录收件人信息。我们可以使用Vue，定义一个订单变量，并且每次点击的时候，将该收件人信息传给Vue的一个方法在订单变量中记录选中的用户信息即可。</p><ol><li><p>引入vue</p><p>我们要先引入Vue,在order.html中引入vue，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/axios.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时在72行左右添加一个id=”app”作为Vue入口标签</p><p><img src="/images/image-20210808133130110.png" alt="image-20210808133130110"></p></li><li><p>定义记录用户信息方法</p><p><img src="/images/image-20210808133255575.png" alt="image-20210808133255575"></p><p>修改地址列表，每次点击的时候调用上面的方法，代码如下：</p><p><img src="/images/image-20210808133355885.png" alt="image-20210808133355885"></p><p>将选中的地址收件人信息回显到页面输出，代码如下：</p><p><img src="/images/image-20210808133432751.png" alt="image-20210808133432751"></p><p>测试效果如下：</p><p><img src="/images/image-20210808133512274.png" alt="image-20210808133512274"></p></li><li><p>默认收件人加载</p><p>用户没有手动选择收件人信息的时候，收件人信息没有初始化。</p><p><img src="/images/image-20210808133559222.png" alt="image-20210808133559222"></p><p>我们可以在后台加载找出默认的收件人信息，前台通过Vue直接绑定给变量即可。</p><p>修改<code>com.changgou.order.controller.OrderController</code>,添加默认收件人信息判断，代码如下：</p><p><img src="/images/image-20210808133826109.png" alt="image-20210808133826109"></p><p>修改order.html，代码如下：</p><p><img src="/images/image-20210808133906590.png" alt="image-20210808133906590"></p><p>此时页面可以正常显示用户信息了。</p></li></ol><h4 id="1-3-4-支付方式选中"><a href="#1-3-4-支付方式选中" class="headerlink" title="1.3.4 支付方式选中"></a>1.3.4 支付方式选中</h4><p>支付方式为线上支付和货到付款，我们可以在order变量中定义一个属性<code>payType</code>,点击线上支付让他的值为1，点击货到付款，让他的值为0即可。</p><p>定义变量</p><p><img src="/images/image-20210808134036160.png" alt="image-20210808134036160"></p><p>修改页面，添加点击事件</p><p><img src="/images/image-20210808134118198.png" alt="image-20210808134118198"></p><h2 id="2-下单"><a href="#2-下单" class="headerlink" title="2. 下单"></a>2. 下单</h2><h3 id="2-1-业务分析"><a href="#2-1-业务分析" class="headerlink" title="2.1 业务分析"></a>2.1 业务分析</h3><p>点击提交订单的时候，会立即创建订单数据，创建订单数据会将数据存入到2张表中，分别是订单表和订单明细表，此处还需要修改商品对应的库存数量。</p><p><img src="/images/image-20210808141232601.png" alt="image-20210808141232601"></p><p>订单表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_order` (<br>  `id` varchar(50) COLLATE utf8_bin NOT NULL COMMENT &#x27;订单id&#x27;,<br>  `total_num` int(11) DEFAULT NULL COMMENT &#x27;数量合计&#x27;,<br>  `total_money` int(11) DEFAULT NULL COMMENT &#x27;金额合计&#x27;,<br>  `pre_money` int(11) DEFAULT NULL COMMENT &#x27;优惠金额&#x27;,<br>  `post_fee` int(11) DEFAULT NULL COMMENT &#x27;邮费&#x27;,<br>  `pay_money` int(11) DEFAULT NULL COMMENT &#x27;实付金额&#x27;,<br>  `pay_type` varchar(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;支付类型，1、在线支付、0 货到付款&#x27;,<br>  `create_time` datetime DEFAULT NULL COMMENT &#x27;订单创建时间&#x27;,<br>  `update_time` datetime DEFAULT NULL COMMENT &#x27;订单更新时间&#x27;,<br>  `pay_time` datetime DEFAULT NULL COMMENT &#x27;付款时间&#x27;,<br>  `consign_time` datetime DEFAULT NULL COMMENT &#x27;发货时间&#x27;,<br>  `end_time` datetime DEFAULT NULL COMMENT &#x27;交易完成时间&#x27;,<br>  `close_time` datetime DEFAULT NULL COMMENT &#x27;交易关闭时间&#x27;,<br>  `shipping_name` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;物流名称&#x27;,<br>  `shipping_code` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;物流单号&#x27;,<br>  `username` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;用户名称&#x27;,<br>  `buyer_message` varchar(1000) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;买家留言&#x27;,<br>  `buyer_rate` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;是否评价&#x27;,<br>  `receiver_contact` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;收货人&#x27;,<br>  `receiver_mobile` varchar(12) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;收货人手机&#x27;,<br>  `receiver_address` varchar(200) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;收货人地址&#x27;,<br>  `source_type` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;订单来源：1:web，2：app，3：微信公众号，4：微信小程序  5 H5手机页面&#x27;,<br>  `transaction_id` varchar(30) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;交易流水号&#x27;,<br>  `order_status` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;订单状态,0:未完成,1:已完成，2：已退货&#x27;,<br>  `pay_status` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;支付状态,0:未支付，1：已支付，2：支付失败&#x27;,<br>  `consign_status` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;发货状态,0:未发货，1：已发货，2：已收货&#x27;,<br>  `is_delete` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;是否删除&#x27;,<br>  PRIMARY KEY (`id`),<br>  KEY `create_time` (`create_time`),<br>  KEY `status` (`order_status`),<br>  KEY `payment_type` (`pay_type`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;<br></code></pre></td></tr></table></figure><p>订单明细表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_order_item` (<br>  `id` varchar(50) COLLATE utf8_bin NOT NULL COMMENT &#x27;ID&#x27;,<br>  `category_id1` int(11) DEFAULT NULL COMMENT &#x27;1级分类&#x27;,<br>  `category_id2` int(11) DEFAULT NULL COMMENT &#x27;2级分类&#x27;,<br>  `category_id3` int(11) DEFAULT NULL COMMENT &#x27;3级分类&#x27;,<br>  `spu_id` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;SPU_ID&#x27;,<br>  `sku_id` bigint(20) NOT NULL COMMENT &#x27;SKU_ID&#x27;,<br>  `order_id` bigint(20) NOT NULL COMMENT &#x27;订单ID&#x27;,<br>  `name` varchar(200) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;商品名称&#x27;,<br>  `price` int(20) DEFAULT NULL COMMENT &#x27;单价&#x27;,<br>  `num` int(10) DEFAULT NULL COMMENT &#x27;数量&#x27;,<br>  `money` int(20) DEFAULT NULL COMMENT &#x27;总金额&#x27;,<br>  `pay_money` int(11) DEFAULT NULL COMMENT &#x27;实付金额&#x27;,<br>  `image` varchar(200) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;图片地址&#x27;,<br>  `weight` int(11) DEFAULT NULL COMMENT &#x27;重量&#x27;,<br>  `post_fee` int(11) DEFAULT NULL COMMENT &#x27;运费&#x27;,<br>  `is_return` char(1) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;是否退货,0:未退货，1：已退货&#x27;,<br>  PRIMARY KEY (`id`),<br>  KEY `item_id` (`sku_id`),<br>  KEY `order_id` (`order_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;<br></code></pre></td></tr></table></figure><h3 id="2-2-下单实现"><a href="#2-2-下单实现" class="headerlink" title="2.2 下单实现"></a>2.2 下单实现</h3><p>下单的时候，先往tb_order表中增加数据，再往tb_order_item表中增加数据。</p><h4 id="2-2-1-代码实现"><a href="#2-2-1-代码实现" class="headerlink" title="2.2.1 代码实现"></a>2.2.1 代码实现</h4><p>这里先修改changgou-service-order微服务，实现下单操作，这里会生成订单号，我们首先需要在启动类中创建一个IdWorker对象。</p><p>在<code>com.changgou.OrderApplication</code>中创建IdWorker，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IdWorker <span class="hljs-title">idWorker</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IdWorker(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>业务层实现类</p><p>实现逻辑：</p><ol><li>获取所有购物项</li><li>统计计算：总金额，总数量</li><li>填充订单数据并保存</li><li>获取每一个购物项保存到orderItem</li><li>删除购物车中数据</li></ol><p>修改订单微服务添加com.changgou.order.service.impl.OrderServiceImpl,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Order order)</span></span>&#123;<br>    <span class="hljs-comment">//1)获取所有购物项</span><br>    Map cartMap = cartService.list(order.getUsername());<br>    List&lt;OrderItem&gt; orderItemList = (List&lt;OrderItem&gt;) cartMap.get(<span class="hljs-string">&quot;orderItemList&quot;</span>);<br>    <span class="hljs-comment">//3）填充订单数据并保存</span><br>    order.setTotalNum((Integer) cartMap.get(<span class="hljs-string">&quot;totalNum&quot;</span>));<br>    order.setTotalMoney((Integer) cartMap.get(<span class="hljs-string">&quot;totalMoney&quot;</span>));<br>    order.setPayMoney((Integer) cartMap.get(<span class="hljs-string">&quot;totalMoney&quot;</span>));<br>    order.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>    order.setUpdateTime(order.getCreateTime());<br>    order.setBuyerRate(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-comment">//0:未评价，1：已评价</span><br>    order.setSourceType(<span class="hljs-string">&quot;1&quot;</span>);       <span class="hljs-comment">//来源，1：WEB</span><br>    order.setOrderStatus(<span class="hljs-string">&quot;0&quot;</span>);      <span class="hljs-comment">//0:未完成,1:已完成，2：已退货</span><br>    order.setPayStatus(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-comment">//0:未支付，1：已支付，2：支付失败</span><br>    order.setConsignStatus(<span class="hljs-string">&quot;0&quot;</span>);    <span class="hljs-comment">//0:未发货，1：已发货，2：已收货</span><br>    order.setId(idWorker.nextId()+<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">int</span> count = orderMapper.insertSelective(order);<br>   <br>    <span class="hljs-comment">//添加订单明细</span><br>    <span class="hljs-keyword">for</span> (OrderItem orderItem : orderItemList) &#123;<br>        orderItem.setId(idWorker.nextId()+<span class="hljs-string">&quot;&quot;</span>);<br>        orderItem.setIsReturn(<span class="hljs-string">&quot;0&quot;</span>);<br>        orderItem.setOrderId(order.getId());<br>        orderItemMapper.insertSelective(orderItem);<br>    &#125;<br>   <br>    <span class="hljs-comment">//清除Redis缓存购物车数据</span><br>    redisTemplate.delete(<span class="hljs-string">&quot;Cart_&quot;</span>+order.getUsername());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层</p><p>修改changgou-service-order微服务，修改com.changgou.order.controller.OrderController类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 新增Order数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Order order)</span></span>&#123;<br>    <span class="hljs-comment">//获取用户名</span><br>    Map&lt;String, String&gt; userMap = tokenDecode.getUserInfo();<br>    String username = userMap.get(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-comment">//设置购买用户</span><br>    order.setUsername(username);<br>    orderService.add(order);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;添加成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-2-渲染服务对接"><a href="#2-2-2-渲染服务对接" class="headerlink" title="2.2.2 渲染服务对接"></a>2.2.2 渲染服务对接</h4><p><img src="/images/image-20210808140007275-1628403167768.png" alt="image-20210808140007275"></p><p>我们需要在模板渲染端调用订单微服务实现下单操作,下单操作需要调用订单微服务，所以需要创建对应的Feign。(前面我已经创建好了，这里再来过一遍流程)</p><ol><li><p>Feign创建</p><p>修改changgou-service-order-api，添加OrderFeign，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderFeign</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/order&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Order order)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下单调用</p><p>修改changgou-web-order的<code>com.changgou.order.controller.OrderController</code>添加下单方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> OrderFeign orderFeign;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 添加订单数据到购物车中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(value = &quot;/add&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Order order)</span></span>&#123;<br>   Result result = orderFeign.add(order);<br>   <span class="hljs-keyword">return</span>  result;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>页面调用</p><p>修改order.html，增加下单js方法，并且在页面点击下单调用，代码如下：</p><p><img src="/images/image-20210808141545746.png" alt="image-20210808141545746"></p><p>点击提交订单调用</p><p><img src="/images/image-20210808141647120.png" alt="image-20210808141647120"></p><p>保存订单测试，注意观察tb_order表数据以及tb_order_item表数据的变化</p></li></ol><h3 id="2-3-库存变更"><a href="#2-3-库存变更" class="headerlink" title="2.3 库存变更"></a>2.3 库存变更</h3><h4 id="2-3-1-业务分析"><a href="#2-3-1-业务分析" class="headerlink" title="2.3.1 业务分析"></a>2.3.1 业务分析</h4><p>上面操作只实现了下单操作，但对应的库存还没跟着一起减少，我们在下单之后，应该调用商品微服务，将下单的商品库存减少，销量增加。每次订单微服务只需要将用户名传到商品微服务，商品微服务通过用户名到Redis中查询对应的购物车数据，然后执行库存减少，库存减少需要控制当前商品库存&gt;=销售数量。</p><p><img src="/images/image-20210808141928494.png" alt="image-20210808141928494"></p><p>如何控制库存数量&gt;=购买数量呢？其实可以通过SQL语句实现，每次减少数量之前，加个条件判断。</p><p><code>where num&gt;=#&#123;num&#125;</code>即可。</p><p>商品服务需要查询购物车数据，所以需要引入订单的api，在pom.xml中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--order api 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_order_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-代码实现-1"><a href="#2-3-2-代码实现-1" class="headerlink" title="2.3.2 代码实现"></a>2.3.2 代码实现</h3><p>要调用其他微服务，需要将头文件中的令牌数据携带到其他微服务中取，所以我们不能使用hystrix的多线程模式，修改changgou-service-order的applicatin.yml配置，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#hystrix 配置</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">10000</span><br>          <span class="hljs-attr">strategy:</span> <span class="hljs-string">SEMAPHORE</span><br></code></pre></td></tr></table></figure><p>每次还需要使用拦截器添加头文件信息，修改配置类com.changgou.OrderApplication添加拦截器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FeignInterceptor <span class="hljs-title">feignInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignInterceptor();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>dao层</p><p>修改changgou-service-goods微服务的<code>com.changgou.goods.dao.SkuMapper</code>接口，增加库存递减方法,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递减库存</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> orderItem</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Update(&quot;UPDATE tb_sku SET num=num-#&#123;num&#125;,sale_num=sale_num+#&#123;num&#125; WHERE id=#&#123;skuId&#125; AND num&gt;=#&#123;num&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decrCount</span><span class="hljs-params">(OrderItem orderItem)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>业务层</p><p>修改changgou-service-goods微服务的<code>com.changgou.goods.service.SkuService</code>接口，添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 库存递减</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrCount</span><span class="hljs-params">(String username)</span></span>;<br></code></pre></td></tr></table></figure><p>修改changgou-service-order微服务的<code>com.changgou.goods.service.impl.SkuServiceImpl</code>实现类，添加一个实现方法，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 库存递减</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrCount</span><span class="hljs-params">(String username)</span> </span>&#123;<br>    <span class="hljs-comment">//获取购物车数据</span><br>    List&lt;OrderItem&gt; orderItems = redisTemplate.boundHashOps(<span class="hljs-string">&quot;Cart_&quot;</span> + username).values();<br><br>    <span class="hljs-comment">//循环递减</span><br>    <span class="hljs-keyword">for</span> (OrderItem orderItem : orderItems) &#123;<br>        <span class="hljs-comment">//递减库存</span><br>        <span class="hljs-keyword">int</span> count = skuMapper.decrCount(orderItem);<br>        <span class="hljs-keyword">if</span>(count&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;库存不足，递减失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层</p><p>修改changgou-service-goods的<code>com.changgou.goods.controller.SkuController</code>类，添加库存递减方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 库存递减</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(value = &quot;/decr/count&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">decrCount</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username)</span></span>&#123;<br>    <span class="hljs-comment">//库存递减</span><br>    skuService.decrCount(username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;库存递减成功！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建Feign</p><p>同时在changgou-service-goods-api工程添加<code>com.changgou.goods.feign.SkuFeign</code>的实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 库存递减</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(value = &quot;/decr/count&quot;)</span><br><span class="hljs-function">Result <span class="hljs-title">decrCount</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;username&quot;)</span> String username)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-3-调用库存递减"><a href="#2-3-3-调用库存递减" class="headerlink" title="2.3.3 调用库存递减"></a>2.3.3 调用库存递减</h4><p>修改changgou-service-order微服务的com.changgou.order.service.impl.OrderServiceImpl类的add方法，增加库存递减的调用。</p><p>先注入SkuFeign</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SkuFeign skuFeign;<br></code></pre></td></tr></table></figure><p>再在调用库存递减方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 增加</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Order order)</span></span>&#123;<br>    <span class="hljs-comment">//1)获取所有购物项</span><br>    Map cartMap = cartService.list(order.getUsername());<br>    List&lt;OrderItem&gt; orderItemList = (List&lt;OrderItem&gt;) cartMap.get(<span class="hljs-string">&quot;orderItemList&quot;</span>);<br>    <span class="hljs-comment">//3）填充订单数据并保存</span><br>    order.setTotalNum((Integer) cartMap.get(<span class="hljs-string">&quot;totalNum&quot;</span>));<br>    order.setTotalMoney((Integer) cartMap.get(<span class="hljs-string">&quot;totalMoney&quot;</span>));<br>    order.setPayMoney((Integer) cartMap.get(<span class="hljs-string">&quot;totalMoney&quot;</span>));<br>    order.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>    order.setUpdateTime(order.getCreateTime());<br>    order.setBuyerRate(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-comment">//0:未评价，1：已评价</span><br>    order.setSourceType(<span class="hljs-string">&quot;1&quot;</span>);       <span class="hljs-comment">//来源，1：WEB</span><br>    order.setOrderStatus(<span class="hljs-string">&quot;0&quot;</span>);      <span class="hljs-comment">//0:未完成,1:已完成，2：已退货</span><br>    order.setPayStatus(<span class="hljs-string">&quot;0&quot;</span>);        <span class="hljs-comment">//0:未支付，1：已支付，2：支付失败</span><br>    order.setConsignStatus(<span class="hljs-string">&quot;0&quot;</span>);    <span class="hljs-comment">//0:未发货，1：已发货，2：已收货</span><br>    order.setId(idWorker.nextId()+<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">int</span> count = orderMapper.insertSelective(order);<br><br>    <span class="hljs-comment">//添加订单明细</span><br>    <span class="hljs-keyword">for</span> (OrderItem orderItem : orderItemList) &#123;<br>        orderItem.setId(idWorker.nextId()+<span class="hljs-string">&quot;&quot;</span>);<br>        orderItem.setIsReturn(<span class="hljs-string">&quot;0&quot;</span>);<br>        orderItem.setOrderId(order.getId());<br>        orderItemMapper.insertSelective(orderItem);<br>    &#125;<br><br>    <span class="hljs-comment">//==================</span><br>    <span class="hljs-comment">//库存减库存</span><br>    skuFeign.decrCount(order.getUsername());<br>    <span class="hljs-comment">//==================</span><br><br>    <span class="hljs-comment">//清除Redis缓存购物车数据</span><br>    redisTemplate.delete(<span class="hljs-string">&quot;Cart_&quot;</span>+order.getUsername());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-4-测试"><a href="#2-3-4-测试" class="headerlink" title="2.3.4 测试"></a>2.3.4 测试</h4><p>库存减少前，查询数据库Sku数据如下：个数98，销量0</p><p>使用Postman执行 <a href="http://localhost:8001/api/order/add">http://localhost:8001/api/order/add</a></p><p>执行测试后，剩余库存97，销量1</p><h3 id="2-4-增加积分"><a href="#2-4-增加积分" class="headerlink" title="2.4 增加积分"></a>2.4 增加积分</h3><p>比如每次下单完成之后，给用户增加10个积分，支付完成后赠送优惠券，优惠券可用于支付时再次抵扣。我们先完成增加积分功能。如下表：points表示用户积分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `tb_user` (<br>  `username` varchar(50) NOT NULL COMMENT &#x27;用户名&#x27;,<br>  `password` varchar(100) NOT NULL COMMENT &#x27;密码，加密存储&#x27;,<br>  `phone` varchar(20) DEFAULT NULL COMMENT &#x27;注册手机号&#x27;,<br>  `email` varchar(50) DEFAULT NULL COMMENT &#x27;注册邮箱&#x27;,<br>  `created` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,<br>  `updated` datetime NOT NULL COMMENT &#x27;修改时间&#x27;,<br>  `source_type` varchar(1) DEFAULT NULL COMMENT &#x27;会员来源：1:PC，2：H5，3：Android，4：IOS&#x27;,<br>  `nick_name` varchar(50) DEFAULT NULL COMMENT &#x27;昵称&#x27;,<br>  `name` varchar(50) DEFAULT NULL COMMENT &#x27;真实姓名&#x27;,<br>  `status` varchar(1) DEFAULT NULL COMMENT &#x27;使用状态（1正常 0非正常）&#x27;,<br>  `head_pic` varchar(150) DEFAULT NULL COMMENT &#x27;头像地址&#x27;,<br>  `qq` varchar(20) DEFAULT NULL COMMENT &#x27;QQ号码&#x27;,<br>  `is_mobile_check` varchar(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;手机是否验证 （0否  1是）&#x27;,<br>  `is_email_check` varchar(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;邮箱是否检测（0否  1是）&#x27;,<br>  `sex` varchar(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;性别，1男，0女&#x27;,<br>  `user_level` int(11) DEFAULT NULL COMMENT &#x27;会员等级&#x27;,<br>  `points` int(11) DEFAULT NULL COMMENT &#x27;积分&#x27;,<br>  `experience_value` int(11) DEFAULT NULL COMMENT &#x27;经验值&#x27;,<br>  `birthday` datetime DEFAULT NULL COMMENT &#x27;出生年月日&#x27;,<br>  `last_login_time` datetime DEFAULT NULL COMMENT &#x27;最后登录时间&#x27;,<br>  PRIMARY KEY (`username`),<br>  UNIQUE KEY `username` (`username`) USING BTREE<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2-4-1-代码实现"><a href="#2-4-1-代码实现" class="headerlink" title="2.4.1 代码实现"></a>2.4.1 代码实现</h4><ol><li><p>dao层</p><p>修改changgou-service-user微服务的<code>com.changgou.user.dao.UserMapper</code>接口，增加用户积分方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 增加用户积分</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pint</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Update(&quot;UPDATE tb_user SET points=points+#&#123;point&#125; WHERE  username=#&#123;username&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUserPoints</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, <span class="hljs-meta">@Param(&quot;point&quot;)</span> Integer pint)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>业务层</p><p>修改changgou-service-user微服务的<code>com.changgou.user.service.UserService</code>接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 添加用户积分</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pint</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUserPoints</span><span class="hljs-params">(String username,Integer pint)</span></span>;<br></code></pre></td></tr></table></figure><p>修改changgou-service-user微服务的<code>com.changgou.user.service.impl.UserServiceImpl</code>，增加添加积分方法实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 修改用户积分</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pint</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addUserPoints</span><span class="hljs-params">(String username, Integer pint)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> userMapper.addUserPoints(username,pint);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层</p><p>修改changgou-service-user微服务的<code>com.changgou.user.controller.UserController</code>，添加增加用户积分方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> TokenDecode tokenDecode;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 增加用户积分</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> points:要添加的积分</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value = &quot;/points/add&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addPoints</span><span class="hljs-params">(Integer points)</span></span>&#123;<br>    <span class="hljs-comment">//获取用户名</span><br>    Map&lt;String, String&gt; userMap = tokenDecode.getUserInfo();<br>    String username = userMap.get(<span class="hljs-string">&quot;username&quot;</span>);<br><br>    <span class="hljs-comment">//添加积分</span><br>    userService.addUserPoints(username,points);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;添加积分成功！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Feign添加</p><p>修改changgou-service-user-api工程，修改<code>com.changgou.user.feign.UserFeign</code>，添加增加用户积分方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 添加用户积分</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> points</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value = &quot;/points/add&quot;)</span><br><span class="hljs-function">Result <span class="hljs-title">addPoints</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;points&quot;)</span>Integer points)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-4-2-增加积分调用"><a href="#2-4-2-增加积分调用" class="headerlink" title="2.4.2 增加积分调用"></a>2.4.2 增加积分调用</h4><p>修改changgou-service-order，添加changgou-service-user-api的依赖，修改pom.xml,添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--user api 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_user_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在增加订单的时候，同时添加用户积分，修改changgou-service-order微服务的<code>com.changgou.order.service.impl.OrderServiceImpl</code>下单方法，增加调用添加积分方法，代码如下：</p><p><img src="/images/image-20210808210321063.png" alt="image-20210808210321063"></p><p>修改changgou-service-order的启动类<code>com.changgou.OrderApplication</code>，添加feign的包路径：</p><p><img src="/images/image-20210808210556231.png" alt="image-20210808210556231"></p>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第四部分</title>
    <link href="/2021/07/28/1.4%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/28/1.4%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part09-用户认证"><a href="#Part09-用户认证" class="headerlink" title="Part09 用户认证"></a>Part09 用户认证</h1><h2 id="1-用户认证分析"><a href="#1-用户认证分析" class="headerlink" title="1. 用户认证分析"></a>1. 用户认证分析</h2><p><img src="/images/image-20210806165006789.png" alt="image-20210806165006789"></p><p>上面流程图描述了用户要操作的各个微服务，用户查看个人信息需要访问客户微服务，下单需要访问订单微服务，秒杀抢购商品需要访问秒杀微服务。每个服务都需要认证用户的身份，身份认证成功后，需要识别用户的角色然后授权访问对应的功能。</p><h3 id="1-1-单点登录"><a href="#1-1-单点登录" class="headerlink" title="1.1 单点登录"></a>1.1 单点登录</h3><p>用户访问的项目中，至少有3个微服务需要识别用户身份，如果用户访问每个微服务都登录一次就太麻烦了，为了提高用户的体验，我们需要实现让用户在一个系统中登录，其他任意受信任的系统都可以访问，这个功能就叫单点登录。</p><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。 SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><h3 id="1-2-第三方账号登陆"><a href="#1-2-第三方账号登陆" class="headerlink" title="1.2 第三方账号登陆"></a>1.2 第三方账号登陆</h3><p>随着国内及国外巨头们的平台开放战略以及移动互联网的发展，第三方登录已经不是一个陌生的产品设计概念了。 所谓的第三方登录，是说基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如Facebook，Twitter等，国内的比如微博、微信、QQ等。</p><p><img src="/images/image-20210806165406268.png" alt="image-20210806165406268"></p><h2 id="2-认证解决方案"><a href="#2-认证解决方案" class="headerlink" title="2. 认证解决方案"></a>2. 认证解决方案</h2><h3 id="2-1-单点登录技术方案"><a href="#2-1-单点登录技术方案" class="headerlink" title="2.1 单点登录技术方案"></a>2.1 单点登录技术方案</h3><p>分布式系统要实现单点登录，通常将认证系统独立抽取出来，并且将用户身份信息存储在单独的存储介质，比如： MySQL、Redis，考虑性能要求，通常存储在Redis中，如下图：</p><p><img src="/images/image-20210806165638050.png" alt="image-20210806165638050"></p><p>Java中有很多用户认证的框架都可以实现单点登录：</p><ul><li>Apache Shiro</li><li>CAS</li><li>Spring security  </li></ul><h3 id="第三方登录技术方案"><a href="#第三方登录技术方案" class="headerlink" title="第三方登录技术方案"></a>第三方登录技术方案</h3><h4 id="2-2-1-Oauth2认证流程"><a href="#2-2-1-Oauth2认证流程" class="headerlink" title="2.2.1 Oauth2认证流程"></a>2.2.1 Oauth2认证流程</h4><p>第三方认证技术方案最主要是解决认证协议的通用标准问题，因为要实现跨系统认证，各系统之间要遵循一定的 接口协议。 OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认 证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。 Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。 参考：<a href="https://baike.baidu.com/item/oAuth/7153134?fr=aladdin">https://baike.baidu.com/item/oAuth/7153134?fr=aladdin</a> Oauth协议：<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a> 下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证的过程</p><p><img src="/images/image-20210806170159857.png" alt="image-20210806170159857"></p><ol><li><p>客户端请求第三方授权</p><p>用户进入黑马程序员的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。</p><p><img src="/images/image-20210806171203045.png" alt="image-20210806171203045"></p><p>点击“用QQ账号登录”出现一个二维码，此时用户扫描二维码，开始给黑马程序员授权。</p><p><img src="/images/image-20210806171233254.png" alt="image-20210806171233254"></p></li><li><p>资源拥有者同意给客户端授权</p><p>资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证， 验证通过后，QQ会询问用户是否给授权黑马程序员访问自己的QQ数据，用户点击“确认登录”表示同意授权，QQ认证服务器会 颁发一个授权码，并重定向到黑马程序员的网站</p><p><img src="/images/image-20210806171257120.png" alt="image-20210806171257120"></p></li><li><p>客户端获取到授权码，请求认证服务器申请令牌 此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。</p></li><li><p>认证服务器向客户端响应令牌 认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。 此交互过程用户看不到，当客户端拿到令牌后，用户在黑马程序员看到已经登录成功。</p></li><li><p>客户端请求资源服务器的资源 客户端携带令牌访问资源服务器的资源。 黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。</p></li><li><p>资源服务器返回受保护资源 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。 注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务, 资源服务器通常要请求认证服务器来校验令牌的合法性。</p></li></ol><p>Oauth2.0认证流程如下： 引自Oauth2.0协议rfc6749 <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></p><p><img src="/images/image-20210806171345750.png" alt="image-20210806171345750"></p><p>Oauth2包括以下角色：</p><ol><li>客户端本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：畅购Android客户端、畅购Web客户端（浏览器端）、微信客户端等。</li><li>资源拥有者 通常为用户，也可以是应用程序，即该资源的拥有者。</li><li>授权服务器（也称认证服务器） 用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。</li><li>资源服务器 存储资源的服务器，比如，畅购用户管理服务器存储了畅购的用户信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。</li></ol><h4 id="2-2-2-Oauth2在项目的应用"><a href="#2-2-2-Oauth2在项目的应用" class="headerlink" title="2.2.2 Oauth2在项目的应用"></a>2.2.2 Oauth2在项目的应用</h4><p>Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用Oauth2，项目中使用Oauth2可以实现实现如下功能：</p><ol><li>本系统访问第三方系统的资源</li><li>外部系统访问本系统的资源</li><li>本系统前端（客户端） 访问本系统后端微服务的资源</li><li>本系统微服务之间访问资源，例如：微服务A访问微服务B的资源，B访问A的资源</li></ol><h3 id="2-3-Spring-security-Oauth2认证解决方案"><a href="#2-3-Spring-security-Oauth2认证解决方案" class="headerlink" title="2.3 Spring security + Oauth2认证解决方案"></a>2.3 Spring security + Oauth2认证解决方案</h3><p>本项目采用 Spring security + Oauth2+JWT完成用户认证及用户授权，Spring security 是一个强大的和高度可定制的身份验证和访问控制框架，Spring security 框架集成了Oauth2协议，下图是项目认证架构图：</p><p><img src="/images/image-20210806172024614.png" alt="image-20210806172024614"></p><ol><li>用户请求认证服务完成认证</li><li>认证服务下发用户身份令牌，拥有身份令牌表示身份合法</li><li>用户携带令牌请求资源服务，请求资源服务必先经过网关</li><li>网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问</li><li>资源服务获取令牌，根据令牌完成授权</li><li>资源服务完成授权则响应资源信息</li></ol><h2 id="3-Jwt令牌回顾"><a href="#3-Jwt令牌回顾" class="headerlink" title="3. Jwt令牌回顾"></a>3. Jwt令牌回顾</h2><p>JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于 在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公 钥/私钥对来签名，防止被篡改。</p><p>官网：<a href="https://jwt.io/">https://jwt.io/</a></p><p>标准：<a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p><p>JWT令牌的优点：</p><ol><li>jwt基于json，非常方便解析</li><li>可以在令牌中自定义丰富的内容，易扩展</li><li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高</li><li>资源服务使用JWT可不依赖认证服务即可完成授权</li></ol><p>缺点：</p><ul><li>JWT令牌较长，占存储空间比较大</li></ul><h3 id="3-1-令牌结构"><a href="#3-1-令牌结构" class="headerlink" title="3.1 令牌结构"></a>3.1 令牌结构</h3><p>JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz</p><p><strong>Header</strong></p><p>头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）</p><p>一个例子如下：</p><p>下边是Header部分的内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>    <span class="hljs-attr">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分</p><p><strong>Payload</strong></p><p>第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比 如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。</p><p>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</p><p>最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。</p><p>一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;456&quot;</span>,<br>    <span class="hljs-attr">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Signature</strong></p><p>第三部分是签名，此部分用于防止jwt内容被篡改。</p><p>这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明 签名算法进行签名。</p><p>一个例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">HMACSHA256</span>(</span><br><span class="hljs-function">    <span class="hljs-title">base64UrlEncode</span>(<span class="hljs-variable">header</span>) + <span class="hljs-string">&quot;.&quot;</span> +</span><br><span class="hljs-function">    <span class="hljs-title">base64UrlEncode</span>(<span class="hljs-variable">payload</span>) + <span class="hljs-string">&quot;.&quot;</span> +</span><br><span class="hljs-function">    <span class="hljs-variable">secret</span>)</span><br></code></pre></td></tr></table></figure><p>base64UrlEncode(header)：jwt令牌的第一部分。</p><p>base64UrlEncode(payload)：jwt令牌的第二部分。</p><p>secret：签名所使用的密钥。</p><h3 id="3-2-生成私钥公钥"><a href="#3-2-生成私钥公钥" class="headerlink" title="3.2 生成私钥公钥"></a>3.2 生成私钥公钥</h3><p>私钥加密，公钥解析</p><p>私钥作为签名用于生成令牌，用公钥来校验。相应的公钥只能校验相应的私钥</p><p>JWT令牌生成采用非对称加密算法</p><ol><li><p>生成密钥证书 下边命令生成密钥证书，采用RSA 算法每个证书包含公钥和私钥</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">keytool -genkeypair -<span class="hljs-built_in">alias</span> changgou -keyalg RSA -keypass changgou -keystore changgou.jks -storepass changgou <br></code></pre></td></tr></table></figure><p>Keytool 是一个java提供的证书管理工具</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"><span class="hljs-keyword">alias</span>：密钥的别名 </span><br><span class="ruby"></span>-<span class="ruby">keyalg：使用的hash算法 </span><br><span class="ruby"></span>-<span class="ruby">keypass：密钥的访问密码 </span><br><span class="ruby"></span>-<span class="ruby">keystore：密钥库文件名，changgou.jks保存了生成的证书 </span><br><span class="ruby"></span>-<span class="ruby">storepass：密钥库的访问密码 </span><br></code></pre></td></tr></table></figure><p>查询证书信息：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">keytool -<span class="hljs-type">list</span> -keystore changgou.jks<br></code></pre></td></tr></table></figure></li><li><p>导出公钥</p><p>openssl是一个加解密工具包，这里使用openssl来导出公钥信息</p><p>安装 openssl：<a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a></p><p>安装资料目录下的Win64OpenSSL-1_1_1b.exe</p><p>配置openssl的path环境变量(有两种方式)</p><ol><li><p>方法一</p><p>先编辑一个系统变量</p><p><img src="/images/image-20210806194341094.png" alt="image-20210806194341094"></p><p>再双击Path配置环境变量。看高亮代码</p><p><img src="/images/image-20210806194443619.png" alt="image-20210806194443619"></p></li><li><p>方法二</p><p>直接在环境变量页面配置路径</p><p><img src="/images/image-20210806194546318.png" alt="image-20210806194546318"></p></li></ol><p>cmd进入changgou.jks文件所在目录(这里就是jwt目录)执行如下命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">keytool -list -rfc --keystore changgou.jks <span class="hljs-string">| openssl x509 -inform pem -pubkey</span><br></code></pre></td></tr></table></figure><p>下面段内容是公钥</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">-----<span class="hljs-keyword">BEGIN</span> PUBLIC KEY-----<br>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjhE4fgF8oIaY5ERSiigWJJ2OK2icj7XU<span class="hljs-regexp">/lyB3CKdEcLcGw6bStTR9FdSJWSFvSbYl/</span>q0QlsWQvEHrPkvGEXWK5fQmdY71<span class="hljs-regexp">/QbGR+eoIQiE0U0QAowI1MLy+XwMvU8DfFyNPmMevq0OOW/</span><span class="hljs-number">4</span>+mqlPyvzCqV1N5VjpUsvcYoso5kHOpiWqf0aSTcTyY3FBgtv3phSA69VO4OgVq9+ma13TerauY<span class="hljs-regexp">/BbzQAIMOYP8Brla3I+8HVVxGgc2O5ij4+SkLISPNK5G1e00JvN5H5JiKaaBd3rFFd+NHvUv5TTrPjNOQX4uSo7bbhJGqglf60Wr5rYa0wzqbRkS7enW4qfdg3I/</span>YKQIDAQAB<br>-----<span class="hljs-keyword">END</span> PUBLIC KEY-----<br></code></pre></td></tr></table></figure><p>将上边的公钥拷贝到文本public.key文件中，合并为一行,可以将它放到需要实现授权认证的工程中。</p></li></ol><h3 id="3-3-基于私钥生成jwt令牌（小案例）"><a href="#3-3-基于私钥生成jwt令牌（小案例）" class="headerlink" title="3.3 基于私钥生成jwt令牌（小案例）"></a>3.3 基于私钥生成jwt令牌（小案例）</h3><h4 id="3-3-1导入认证服务"><a href="#3-3-1导入认证服务" class="headerlink" title="3.3.1导入认证服务"></a>3.3.1导入认证服务</h4><ol><li><p>将课件中<code>changgou_user_auth</code>的工程导入到项目中去，如果导入后包名，pom文件显示格式不对，可以按照如下操作</p><p>点击加号</p><p><img src="/images/image-20210806201611292.png" alt="image-20210806201611292"></p><p>点击pom文件</p><p><img src="/images/image-20210806201718682.png" alt="image-20210806201718682"></p><p>最后点击ok，如果是个正常包这里点不了。</p><p><img src="/images/image-20210806201758851.png" alt="image-20210806201758851"></p></li><li><p>认证服务中创建测试类CreateJwtTest</p><p>注意：</p><ul><li><p>将需要用到的文件放到resources下</p><p><img src="/images/image-20210806202207124.png" alt="image-20210806202207124"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.changgou.oauth;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.Jwt;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.JwtHelper;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.crypto.sign.RsaSigner;<br><span class="hljs-keyword">import</span> org.springframework.security.rsa.crypto.KeyStoreKeyFactory;<br><br><span class="hljs-keyword">import</span> java.security.KeyPair;<br><span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateJwtTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createJWT</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//基于私钥生成jwt</span><br>        <span class="hljs-comment">//1. 创建一个秘钥工厂</span><br>        <span class="hljs-comment">//1: 指定私钥的位置  </span><br>        ClassPathResource classPathResource = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;changgou.jks&quot;</span>);<br>        <span class="hljs-comment">//2: 指定秘钥库的密码</span><br>        String keyPass = <span class="hljs-string">&quot;changgou&quot;</span>;<br>        KeyStoreKeyFactory keyStoreKeyFactory = <span class="hljs-keyword">new</span> KeyStoreKeyFactory(classPathResource,keyPass.toCharArray());<br><br>        <span class="hljs-comment">//2. 基于工厂获取私钥</span><br>        String alias = <span class="hljs-string">&quot;changgou&quot;</span>;<br>        String password = <span class="hljs-string">&quot;changgou&quot;</span>;<br>        KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias, password.toCharArray());<br>        <span class="hljs-comment">//将当前的私钥转换为rsa私钥</span><br>        RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();<br><br>        <span class="hljs-comment">//3.生成jwt</span><br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        map.put(<span class="hljs-string">&quot;company&quot;</span>,<span class="hljs-string">&quot;heima&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;beijing&quot;</span>);<br><br>        Jwt jwt = JwtHelper.encode(JSON.toJSONString(map), <span class="hljs-keyword">new</span> RsaSigner(rsaPrivateKey));<br>        String jwtEncoded = jwt.getEncoded();<br>        System.out.println(jwtEncoded);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>基于公钥解析jwt令牌</p><p>上面创建令牌后，我们可以对JWT令牌进行解析，这里解析需要用到公钥，我们可以将之前生成的公钥public.key拷贝出来用字符串变量token存储，然后通过公钥解密。</p><p>在changgou-user-oauth创建测试类com.changgou.token.ParseJwtTest实现解析校验令牌数据，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.Jwt;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.JwtHelper;<br><span class="hljs-keyword">import</span> org.springframework.security.jwt.crypto.sign.RsaVerifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseJwtTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJwt</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//基于公钥去解析jwt</span><br>        String jwt =<span class="hljs-string">&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZGRyZXNzIjoiYmVpamluZyIsImNvbXBhbnkiOiJoZWltYSJ9.cjZNz8G0m4noNYN2VM1SH3ujAtbHElW5Vtbadb0NDI0cjM1DaAXzMA53Qbj4pmVQPl_IfSKqUEXbLxowdRa5NHR43laFsR0kzGbJiTINfSVSroSslYpDdEVwCeAF_a7I-R819YTj4p6sjuYKXbzXpeZQErczFbWWWGR2_U44xH6u1ejRNv8PikFiuzNw-muL7zUJkvqeSJzbEMnQdZMbfvZp4LtSI6B4G_PqpdNXkv19-juxAh99VgJInH_ItF0y5IBOxofA7gRebCZmU8L57gO9ohf2L00D95kis_Ji8lmA1ptLIfXqO_qLVvLBUNH-VtgjGAF0-0pyB-5jlbHP7w&quot;</span>;<br><br>        String publicKey =<span class="hljs-string">&quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvFsEiaLvij9C1Mz+oyAmt47whAaRkRu/8kePM+X8760UGU0RMwGti6Z9y3LQ0RvK6I0brXmbGB/RsN38PVnhcP8ZfxGUH26kX0RK+tlrxcrG+HkPYOH4XPAL8Q1lu1n9x3tLcIPxq8ZZtuIyKYEmoLKyMsvTviG5flTpDprT25unWgE4md1kthRWXOnfWHATVY7Y/r4obiOL1mS5bEa/iNKotQNnvIAKtjBM4RlIDWMa6dmz+lHtLtqDD2LF1qwoiSIHI75LQZ/CNYaHCfZSxtOydpNKq8eb1/PGiLNolD4La2zf0/1dlcr5mkesV570NxRmU1tFm8Zd3MZlZmyv9QIDAQAB-----END PUBLIC KEY-----&quot;</span>;<br><br>        Jwt token = JwtHelper.decodeAndVerify(jwt, <span class="hljs-keyword">new</span> RsaVerifier(publicKey));<br><br>        String claims = token.getClaims();<br>        System.out.println(claims);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：（就是创建令牌时放入的数据）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;address&quot;</span>:<span class="hljs-string">&quot;beijing&quot;</span>,<span class="hljs-attr">&quot;company&quot;</span>:<span class="hljs-string">&quot;heima&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-Oauth2-0入门"><a href="#4-Oauth2-0入门" class="headerlink" title="4. Oauth2.0入门"></a>4. Oauth2.0入门</h2><h3 id="4-1-准备工作"><a href="#4-1-准备工作" class="headerlink" title="4.1 准备工作"></a>4.1 准备工作</h3><p>这里都准备好了，主要看下表结构就可以了</p><ol><li><p>搭建认证服务器之前，先在用户系统表结构中增加如下表结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `oauth_client_details` (<br>  `client_id` varchar(48) NOT NULL COMMENT &#x27;客户端ID，主要用于标识对应的应用&#x27;,<br>  `resource_ids` varchar(256) DEFAULT NULL,<br>  `client_secret` varchar(256) DEFAULT NULL COMMENT &#x27;客户端秘钥，BCryptPasswordEncoder加密&#x27;,<br>  `scope` varchar(256) DEFAULT NULL COMMENT &#x27;对应的范围&#x27;,<br>  `authorized_grant_types` varchar(256) DEFAULT NULL COMMENT &#x27;认证模式&#x27;,<br>  `web_server_redirect_uri` varchar(256) DEFAULT NULL COMMENT &#x27;认证后重定向地址&#x27;,<br>  `authorities` varchar(256) DEFAULT NULL,<br>  `access_token_validity` int(11) DEFAULT NULL COMMENT &#x27;令牌有效期&#x27;,<br>  `refresh_token_validity` int(11) DEFAULT NULL COMMENT &#x27;令牌刷新周期&#x27;,<br>  `additional_information` varchar(4096) DEFAULT NULL,<br>  `autoapprove` varchar(256) DEFAULT NULL,<br>  PRIMARY KEY (`client_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br></code></pre></td></tr></table></figure></li><li><p>导入1条初始化数据,其中加密字符明文为changgou：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO `oauth_client_details` VALUES (&#x27;changgou&#x27;, null, &#x27;$2a$10$Yvkp3xzDcri6MAsPIqnzzeGBHez1QZR3A079XDdmNU4R725KrkXi2&#x27;, &#x27;app&#x27;, &#x27;authorization_code,password,refresh_token,client_credentials&#x27;, &#x27;http://localhost&#x27;, null, &#x27;43200&#x27;, &#x27;43200&#x27;, null, null);<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-2-Oauth2授权模式介绍"><a href="#4-2-Oauth2授权模式介绍" class="headerlink" title="4.2 Oauth2授权模式介绍"></a>4.2 Oauth2授权模式介绍</h3><p>Oauth2有以下授权模式：</p><ol><li>授权码模式（Authorization Code）</li><li>隐式授权模式（Implicit）</li><li>密码模式（Resource Owner Password Credentials） </li><li>客户端模式（Client Credentials）</li></ol><p>其中授权码模式和密码模式应用较多，本小节介绍授权码模式。</p><h4 id="4-2-1-授权码模式"><a href="#4-2-1-授权码模式" class="headerlink" title="4.2.1 授权码模式"></a>4.2.1 授权码模式</h4><ol><li><p><strong>授权码授权流程</strong></p><ol><li>客户端（这个客户端不是用户，是客户端服务器）请求第三方授权</li><li>用户同意给客户端授权</li><li>客户端获取到授权码，请求认证服务器申请令牌</li><li>认证服务器向客户端响应令牌</li><li>客户端请求资源服务器的资源，资源服务校验令牌合法性，完成授权</li><li>资源服务器返回受保护资源</li></ol></li><li><p><strong>申请授权码</strong></p><p>请求认证服务获取授权码：</p><p>注意：</p><ul><li><p>9200是项目中设置好的用户认证微服务的端口号</p></li><li><p><code>/oauth/authorize</code>是oauth2.0内部已经规定好的获得授权码的路径</p></li><li><p><code>client_id=changgou</code>是服务器数据库中表的字段和对应的属性</p><p><img src="/images/image-20210806223116209.png" alt="image-20210806223116209"></p></li><li><p><code>response_type=code</code>表明用的是oauth2.0的授权码模式</p></li><li><p><code>scop=app</code>也是表中的字段和属性</p><p><img src="/images/image-20210806223447185.png" alt="image-20210806223447185"></p></li><li><p><code>redirect_uri</code>：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Get请求：<br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/oauth/</span>authorize?client_id=changgou&amp;response_type=code&amp;scop=app&amp;redirect_uri=http:<span class="hljs-regexp">//</span>localhost<br></code></pre></td></tr></table></figure><p>在浏览器输入上面的请求，发现跳转到了登陆页面</p><p><img src="/images/image-20210806223824348.png" alt="image-20210806223824348"></p><p>输入账号和密码，点击Login。 Spring Security接收到请求会调用UserDetailsService接口（这个接口它内部自己写好了，不用编写）的loadUserByUsername方法查询用户正确的密码。 当前导入的基础工程中客户端ID为changgou，秘钥也为changgou（这个客户端ID还有密钥的加密字符在最开始被插入数据库了，所以这里能够登录成功）即可认证通过。</p><p>接下来进入授权页面：</p><p><img src="/images/image-20210806224201321.png" alt="image-20210806224201321"></p><p>点击Authorize,接下来返回授权码： 认证服务携带授权码跳转redirect_uri,code=OicI5N就是返回的授权码, <strong>每一个授权码只能使用一次</strong></p><p><img src="/images/image-20210806224319499.png" alt="image-20210806224319499"></p></li><li><p><strong>申请令牌</strong></p><p>拿到授权码后，申请令牌</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Post请求：<br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/oauth/</span>token<br></code></pre></td></tr></table></figure><p>此链接需要使用 http Basic认证(下图Basic Auth就是这个认证)</p><p>以上测试使用postman完成：</p><p><img src="/images/image-20210806225752649.png" alt="image-20210806225752649"></p><p><img src="/images/image-20210806225820728.png" alt="image-20210806225820728"></p><p>客户端Id和客户端密码会匹配数据库oauth_client_details表中的客户端id及客户端密码。</p><p>点击发送： 申请令牌成功</p><p><img src="/images/image-20210806230037261.png" alt="image-20210806230037261"></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">access_token：访问令牌，携带此令牌访问资源 <br>token_type：有<span class="hljs-keyword">MAC</span> <span class="hljs-keyword">Token</span>与Bearer <span class="hljs-keyword">Token</span>两种类型，两种的校验算法不同，RFC 6750建议Oauth2采用 Bearer <span class="hljs-keyword">Token</span>（http:<span class="hljs-comment">//www.rfcreader.com/#rfc6750）。 </span><br>refresh_token：刷新令牌，使用此令牌可以延长访问令牌的过期时间。 <br>expires_in：过期时间，单位为秒。 <br>scope：范围，与定义的客户端范围一致。    <br>jti：当前<span class="hljs-keyword">token</span>的唯一标识<br></code></pre></td></tr></table></figure><p>关于access_token和jti的关系，需要多强调一点：</p><ul><li><p>jti与access_token成对出现，一 一对应。他俩是一个键值对。jti作为键存储在cookie中，access_token作为值存储在redis中（因为cookei存放的数据长度有限，不然不需要下面的</p><p>redis）</p></li></ul></li><li><p><strong>令牌校验</strong>  </p><p>Spring Security Oauth2提供校验令牌的端点，如下：</p><p>Get: <a href="http://localhost:9200/oauth/check_token?token=">http://localhost:9200/oauth/check_token?token=</a> [access_token]</p><p>（这里的[access_token]就是刚刚获得的令牌）</p><p>使用postman测试如下:</p><p><img src="/images/image-20210806231247708.png" alt="image-20210806231247708"></p><p>此时说明校验成功</p></li><li><p><strong>刷新令牌</strong></p><p>刷新令牌是当令牌快过期时重新生成一个令牌，它与授权码授权和密码授权生成令牌不同，刷新令牌不需要授权码 也不需要账号和密码，只需要一个刷新令牌、客户端id和客户端密码。</p><p>测试如下： Post：<a href="http://localhost:9200/oauth/token">http://localhost:9200/oauth/token</a></p><p>参数：</p><ul><li><p>grant_type： 固定为 refresh_token</p></li><li><p>refresh_token：刷新令牌（注意不是access_token，而是refresh_token）</p><p><img src="/images/image-20210806231738266.png" alt="image-20210806231738266"></p></li></ul></li></ol><h4 id="4-2-2-密码模式"><a href="#4-2-2-密码模式" class="headerlink" title="4.2.2 密码模式"></a>4.2.2 密码模式</h4><p>密码模式（Resource Owner Password Credentials）与授权码模式的区别是申请令牌不再使用授权码，而是直接 通过用户名和密码即可申请令牌。</p><ol><li><p><strong>申请令牌</strong></p><p>测试如下</p><p>注意：</p><ul><li>这里的用户名和密码就是真正的用户的账号和密码，和前面客户端的不是一个概念。</li><li>这里的用户名和密码需要去<code>tb_user</code>表中找，但是这里代码还没有完成，都用的<code>itheima</code>做密码</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">Post请求：<br>http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/oauth/</span>token<br><br>携带参数： <br>grant_type：密码模式授权填写password <br>username：账号  <br>password：密码<br></code></pre></td></tr></table></figure><p>此链接也需要使用 http Basic认证</p><p><img src="/images/image-20210806233653549.png" alt="image-20210806233653549"></p><p>测试结果如下</p><p><img src="/images/image-20210806233733190.png" alt="image-20210806233733190"></p></li></ol><h3 id="4-3-资源服务授权"><a href="#4-3-资源服务授权" class="headerlink" title="4.3 资源服务授权"></a>4.3 资源服务授权</h3><p>资源服务拥有要访问的受保护资源，客户端携带令牌访问资源服务，如果令牌合法则可成功访问资源服务中的资源，如下图:</p><p><img src="/images/image-20210806234229211.png" alt="image-20210806234229211"></p><p>上图的业务流程如下:</p><ol><li>客户端请求认证服务申请令牌</li><li>认证服务生成令牌认证服务采用非对称加密算法，使用私钥生成令牌</li><li>客户端携带令牌访问资源服务客户端在Http header 中添加： Authorization：Bearer令牌</li><li>资源服务请求认证服务校验令牌的有效性资源服务接收到令牌，使用公钥校验令牌的合法性</li><li>令牌有效，资源服务向客户端响应资源信息</li></ol><h4 id="4-3-1-用户服务对接Oauth2"><a href="#4-3-1-用户服务对接Oauth2" class="headerlink" title="4.3.1 用户服务对接Oauth2"></a>4.3.1 用户服务对接Oauth2</h4><ol><li><p>配置公钥 ，将 changggou_user_auth 项目中public.key复制到changgou_service_user中</p><p><img src="/images/image-20210806234937362.png" alt="image-20210806234937362"></p></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置每个系统的Http请求路径安全控制策略以及读取公钥信息识别令牌，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableResourceServer</span> <span class="hljs-comment">//声明当前的服务是一个资源服务器</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</span><span class="hljs-comment">//激活方法上的PreAuthorize注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">//公钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PUBLIC_KEY = <span class="hljs-string">&quot;public.key&quot;</span>;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 定义JwtTokenStore</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jwtAccessTokenConverter</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">(JwtAccessTokenConverter jwtAccessTokenConverter)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 定义JJwtAccessTokenConverter</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;<br>        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();<br>        converter.setVerifierKey(getPubKey());<br>        <span class="hljs-keyword">return</span> converter;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取非对称加密公钥 Key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 公钥 Key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getPubKey</span><span class="hljs-params">()</span> </span>&#123;<br>        Resource resource = <span class="hljs-keyword">new</span> ClassPathResource(PUBLIC_KEY);<br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStreamReader inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(resource.getInputStream());<br>            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);<br>            <span class="hljs-keyword">return</span> br.lines().collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * Http安全配置，对每个到达系统的http请求链接进行校验</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> http</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//所有请求必须认证通过</span><br>        http.authorizeRequests()<br>                <span class="hljs-comment">//下边的路径放行</span><br>                .antMatchers(<br>                        <span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;/user/load/**&quot;</span>). <span class="hljs-comment">//配置地址放行</span><br>                permitAll()<br>                .anyRequest().<br>                authenticated();    <span class="hljs-comment">//其他地址需要认证授权</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>资源服务授权测试</p><p>不携带令牌访问<a href="http://localhost:9005/user">http://localhost:9005/user</a></p><p>由于该地址受访问限制，需要授权，所以出现如下错误：</p><p><img src="/images/image-20210807000317476.png" alt="image-20210807000317476"></p><p>携带令牌访问<a href="http://localhost:9005/user">http://localhost:9005/user</a></p><p>在http header中添加 Authorization： Bearer 令牌</p><p>注意：</p><ul><li>Bearer 令牌之间有空格</li><li>令牌是前面生成的还没过期，所以这里可以直接用</li></ul><p><img src="/images/image-20210807000526789.png" alt="image-20210807000526789"></p><p><img src="/images/image-20210807000550001.png" alt="image-20210807000550001"></p></li></ol><h2 id="5-认证开发"><a href="#5-认证开发" class="headerlink" title="5 认证开发"></a>5 认证开发</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p><img src="/images/image-20210807125506369.png" alt="image-20210807125506369"></p><p>执行流程：</p><ol><li>用户登录，请求认证服务</li><li>认证服务认证通过，生成jwt令牌，将jwt令牌及相关信息写入Redis，并且将身份令牌写入cookie </li><li>用户访问资源页面，带着cookie到网关 </li><li>网关从cookie获取token，并查询Redis校验token,如果token不存在则拒绝访问，否则放行</li><li>用户退出，请求认证服务，清除redis中的token，并且删除cookie中的token </li></ol><p>使用redis存储用户的身份令牌有以下作用：</p><ol><li>实现用户退出注销功能，服务端清除令牌后，即使客户端请求携带token也是无效的</li><li>由于jwt令牌过长，不宜存储在cookie中，所以将jwt令牌存储在redis，由客户端请求服务端获取并在客户端存储 </li></ol><h3 id="5-2-Redis配置"><a href="#5-2-Redis配置" class="headerlink" title="5.2 Redis配置"></a>5.2 Redis配置</h3><p>增加认证服务changgou_user_auth中application.yml配置文件中的Redis配置</p><h3 id="5-3-认证服务"><a href="#5-3-认证服务" class="headerlink" title="5.3 认证服务"></a>5.3 认证服务</h3><h4 id="5-3-1-认证服务需求分析"><a href="#5-3-1-认证服务需求分析" class="headerlink" title="5.3.1 认证服务需求分析"></a>5.3.1 认证服务需求分析</h4><p>认证服务需要实现的功能如下：</p><ol><li><p>登录接口</p><p>前端post提交账号、密码等，用户身份校验通过，生成令牌，并将令牌存储到redis。 将令牌写入cookie。</p></li><li><p>退出接口 </p><p>校验当前用户的身份为合法并且为已登录状态。 将令牌从redis删除。 删除cookie中的令牌。</p><p><img src="/images/image-20210807132848712.png" alt="image-20210807132848712"></p></li></ol><h4 id="5-3-2-授权参数配置"><a href="#5-3-2-授权参数配置" class="headerlink" title="5.3.2 授权参数配置"></a>5.3.2 授权参数配置</h4><p>修改changgou_user_auth中application.yml配置文件，修改对应的授权配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">auth:</span><br>  <span class="hljs-attr">ttl:</span> <span class="hljs-number">1200</span>  <span class="hljs-comment">#token存储到redis的过期时间</span><br>  <span class="hljs-attr">clientId:</span> <span class="hljs-string">changgou</span>    <span class="hljs-comment">#客户端ID</span><br>  <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">changgou</span>    <span class="hljs-comment">#客户端秘钥</span><br>  <span class="hljs-attr">cookieDomain:</span> <span class="hljs-string">localhost</span>   <span class="hljs-comment">#Cookie保存对应的域名</span><br>  <span class="hljs-attr">cookieMaxAge:</span> <span class="hljs-number">-1</span>          <span class="hljs-comment">#Cookie过期时间，-1表示浏览器关闭则销毁</span><br></code></pre></td></tr></table></figure><h4 id="5-3-3-申请令牌测试"><a href="#5-3-3-申请令牌测试" class="headerlink" title="5.3.3 申请令牌测试"></a>5.3.3 申请令牌测试</h4><p>这里和正常的业务代码无关，这里只是测试申请令牌有没有错</p><p>为了不破坏Spring Security的代码，我们在Service方法中通过RestTemplate请求Spring Security所暴露的申请令牌接口来申请令牌，下边是测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyTokenTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span>  <span class="hljs-comment">//这个bean需要自己声明，已经声明在启动类中了</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Autowired</span>  <span class="hljs-comment">//通过它可以在注册中心获取地址信息</span><br>    <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyToken</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//构建请求地址  http://localhost:9200/oauth/token</span><br>        <span class="hljs-comment">//user-auth是这个微服务在注册中心的名字。返回的是这个服务的实例对象</span><br>        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">&quot;user-auth&quot;</span>);<br>        <span class="hljs-comment">// 通过这个实例对象，就可以获得他的路径信息  http://localhost:9200</span><br>        URI uri = serviceInstance.getUri();<br>        <span class="hljs-comment">// http://localhost:9200/oauth/token</span><br>        String url =uri+<span class="hljs-string">&quot;/oauth/token&quot;</span>;<br><br>        <span class="hljs-comment">// 封装请求参数 body , headers。这里的用户名和密码写死了，实际开发中不是这样</span><br>        MultiValueMap&lt;String, String&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>        body.add(<span class="hljs-string">&quot;grant_type&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>);<br>        body.add(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>        body.add(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br><br>        MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>        headers.add(<span class="hljs-string">&quot;Authorization&quot;</span>,<span class="hljs-keyword">this</span>.getHttpBasic(<span class="hljs-string">&quot;changgou&quot;</span>,<span class="hljs-string">&quot;changgou&quot;</span>));<br>        HttpEntity&lt;MultiValueMap&lt;String,String&gt;&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body,headers);    <span class="hljs-comment">//body, header就是封装在这个里面的</span><br><br>        <span class="hljs-comment">//当后端出现了401,400.后端不对着两个异常编码进行处理,而是直接返回给前端</span><br>        restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">if</span> (response.getRawStatusCode()!=<span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode() != <span class="hljs-number">401</span>)&#123;<br>                    <span class="hljs-keyword">super</span>.handleError(response);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//发送请求</span><br>        ResponseEntity&lt;Map&gt; responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, Map.class);<br>        Map map = responseEntity.getBody();<br>        System.out.println(map);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHttpBasic</span><span class="hljs-params">(String clientId, String clientSecret)</span> </span>&#123;<br>        String value =clientId+<span class="hljs-string">&quot;:&quot;</span>+clientSecret;<br>        <span class="hljs-keyword">byte</span>[] encode = Base64Utils.encode(value.getBytes());<br>        <span class="hljs-comment">//Basic Y2hhbmdnb3U6Y2hhbmdnb3U=</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Basic &quot;</span>+<span class="hljs-keyword">new</span> String(encode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-4-业务层"><a href="#5-3-4-业务层" class="headerlink" title="5.3.4 业务层"></a>5.3.4 业务层</h4><p>AuthService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthService</span> </span>&#123;<br>    <span class="hljs-function">AuthToken <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, String clientId, String clientSecret)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>AuthServiceImpl实现类：</p><p>基于刚才写的测试实现申请令牌的service方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;auth.ttl&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> ttl;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthToken <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, String clientId, String clientSecret)</span> </span>&#123;<br>        <span class="hljs-comment">//1.申请令牌</span><br>        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">&quot;user-auth&quot;</span>);<br>        URI uri = serviceInstance.getUri();<br>        String url=uri+<span class="hljs-string">&quot;/oauth/token&quot;</span>;<br><br>        MultiValueMap&lt;String, String&gt; body = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>        body.add(<span class="hljs-string">&quot;grant_type&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>);<br>        body.add(<span class="hljs-string">&quot;username&quot;</span>,username);<br>        body.add(<span class="hljs-string">&quot;password&quot;</span>,password);<br><br>        MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();<br>        headers.add(<span class="hljs-string">&quot;Authorization&quot;</span>,<span class="hljs-keyword">this</span>.getHttpBasic(clientId,clientSecret));<br>        HttpEntity&lt;MultiValueMap&lt;String,String&gt;&gt; requestEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(body,headers);<br><br>        restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> DefaultResponseErrorHandler()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(ClientHttpResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">if</span> (response.getRawStatusCode()!=<span class="hljs-number">400</span> &amp;&amp; response.getRawStatusCode()!=<span class="hljs-number">401</span>)&#123;<br>                    <span class="hljs-keyword">super</span>.handleError(response);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        ResponseEntity&lt;Map&gt; responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, Map.class);<br>        Map map = responseEntity.getBody();<br>        <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map.get(<span class="hljs-string">&quot;access_token&quot;</span>) == <span class="hljs-keyword">null</span> || map.get(<span class="hljs-string">&quot;refresh_token&quot;</span>) == <span class="hljs-keyword">null</span> || map.get(<span class="hljs-string">&quot;jti&quot;</span>) == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//申请令牌失败</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;申请令牌失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//2.封装结果数据</span><br>        AuthToken authToken = <span class="hljs-keyword">new</span> AuthToken();<br>        authToken.setAccessToken((String) map.get(<span class="hljs-string">&quot;access_token&quot;</span>));<br>        authToken.setRefreshToken((String) map.get(<span class="hljs-string">&quot;refresh_token&quot;</span>));<br>        authToken.setJti((String)map.get(<span class="hljs-string">&quot;jti&quot;</span>));<br><br>        <span class="hljs-comment">//3.将jti作为redis中的key,将jwt作为redis中的value进行数据的存放</span><br>        stringRedisTemplate.boundValueOps(authToken.getJti()).set(authToken.getAccessToken(),ttl, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> authToken;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHttpBasic</span><span class="hljs-params">(String clientId, String clientSecret)</span> </span>&#123;<br>        String value = clientId+<span class="hljs-string">&quot;:&quot;</span>+clientSecret;<br>        <span class="hljs-keyword">byte</span>[] encode = Base64Utils.encode(value.getBytes());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Basic &quot;</span>+<span class="hljs-keyword">new</span> String(encode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-5-控制层"><a href="#5-3-5-控制层" class="headerlink" title="5.3.5 控制层"></a>5.3.5 控制层</h4><p>AuthController编写用户登录授权方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/oauth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthService authService;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;auth.clientId&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String clientId;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;auth.clientSecret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String clientSecret;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;auth.cookieDomain&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String cookieDomain;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;auth.cookieMaxAge&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cookieMaxAge;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(username))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户名不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(password))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;密码不存在&quot;</span>);<br>        &#125;<br><br>        AuthToken authToken = authService.login(username,password,clientId,clientSecret);<br><br>        <span class="hljs-keyword">this</span>.saveJtiToCookie(authToken.getJti());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;登录成功&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveJtiToCookie</span><span class="hljs-params">(String jti)</span> </span>&#123;<br>        HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();<br>        CookieUtil.addCookie(response,cookieDomain,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;uid&quot;</span>,jti,cookieMaxAge,<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-6-登录请求放行"><a href="#5-3-6-登录请求放行" class="headerlink" title="5.3.6 登录请求放行"></a>5.3.6 登录请求放行</h4><p>修改认证服务WebSecurityConfig类中configure（），添加放行路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    web.ignoring().antMatchers(<br>            <span class="hljs-string">&quot;/oauth/login&quot;</span>,<br>            <span class="hljs-string">&quot;/oauth/logout&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-7-测试认证接口"><a href="#5-3-7-测试认证接口" class="headerlink" title="5.3.7 测试认证接口"></a>5.3.7 测试认证接口</h4><p>使用postman测试：<a href="http://localhost:9200/oauth/login">http://localhost:9200/oauth/login</a></p><p><img src="/images/image-20210807144203187.png" alt="image-20210807144203187"></p><h4 id="5-3-8-动态获取用户信息"><a href="#5-3-8-动态获取用户信息" class="headerlink" title="5.3.8 动态获取用户信息"></a>5.3.8 动态获取用户信息</h4><p>当前在认证服务中，用户密码是写死在用户认证类中。所以用户登录时，无论帐号输入什么，只要密码是itheima都可以访问。 因此需要动态获取用户帐号与密码</p><ol><li><p>定义被访问接口</p><p>用户微服务changgou_service_user对外暴露根据用户名获取用户信息接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/load/&#123;username&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> userService.findById(username);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>放行该接口，修改用户微服务下的ResourceServerConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//所有请求必须认证通过</span><br>    http.authorizeRequests()<br>            <span class="hljs-comment">//下边的路径放行</span><br>            .antMatchers(<br>                    <span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;/user/load/**&quot;</span>). <span class="hljs-comment">//配置地址放行</span><br>            permitAll()<br>            .anyRequest().<br>            authenticated();    <span class="hljs-comment">//其他地址需要认证授权</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义feign接口</p><p>changgou_service_user_api新增feign接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFeign</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/load/&#123;username&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>认证服务添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_user_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改认证服务启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.changgou.user.feign&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>修改用户认证类</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*****</span><br><span class="hljs-comment"> * 自定义授权认证类</span><br><span class="hljs-comment"> */</span><br>@Service<br>public <span class="hljs-keyword">class</span> UserDetailsServiceImpl implements UserDetailsService &#123;<br><br>    @Autowired<br>    ClientDetailsService clientDetailsService;<br><br>    @Autowired<br>    <span class="hljs-keyword">private</span> UserFeign userFeign;<br><br>    <span class="hljs-comment">/****</span><br><span class="hljs-comment">     * 自定义授权认证</span><br><span class="hljs-comment">     * @param username</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     * @throws UsernameNotFoundException</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public UserDetails load<span class="hljs-constructor">UserByUsername(String <span class="hljs-params">username</span>)</span> throws UsernameNotFoundException &#123;<br>        <span class="hljs-comment">//取出身份，如果身份为空说明没有认证</span><br>        Authentication authentication = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SecurityContextHolder</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Authentication()</span>;<br>        <span class="hljs-comment">//没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret，开始认证client_id和client_secret</span><br>        <span class="hljs-keyword">if</span>(authentication==null)&#123;<br>            ClientDetails clientDetails = clientDetailsService.load<span class="hljs-constructor">ClientByClientId(<span class="hljs-params">username</span>)</span>;<br>            <span class="hljs-keyword">if</span>(clientDetails!=null)&#123;<br>                <span class="hljs-comment">//秘钥</span><br>                String clientSecret = clientDetails.get<span class="hljs-constructor">ClientSecret()</span>;<br>                <span class="hljs-comment">//静态方式</span><br>                <span class="hljs-comment">//return new User(username,new BCryptPasswordEncoder().encode(clientSecret), AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;&quot;));</span><br>                <span class="hljs-comment">//数据库查找方式</span><br>                return <span class="hljs-keyword">new</span> <span class="hljs-constructor">User(<span class="hljs-params">username</span>,<span class="hljs-params">clientSecret</span>, AuthorityUtils.<span class="hljs-params">commaSeparatedStringToAuthorityList</span>(<span class="hljs-string">&quot;&quot;</span>)</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">username</span>)</span>) &#123;<br>            return null;<br>        &#125;<br><br>        <span class="hljs-comment">//根据用户名查询用户信息</span><br><span class="hljs-comment">//        String pwd = new BCryptPasswordEncoder().encode(&quot;itheima&quot;);</span><br>        com.changgou.user.pojo.User userInfo = userFeign.find<span class="hljs-constructor">UserInfo(<span class="hljs-params">username</span>)</span>;<br>        <span class="hljs-comment">//创建User对象</span><br>        String permissions = <span class="hljs-string">&quot;goods_list,seckill_list&quot;</span>;<br>        UserJwt userDetails = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UserJwt(<span class="hljs-params">username</span>,<span class="hljs-params">userInfo</span>.<span class="hljs-params">getPassword</span>()</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorityUtils</span>.</span></span>comma<span class="hljs-constructor">SeparatedStringToAuthorityList(<span class="hljs-params">permissions</span>)</span>);<br>        return userDetails;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>测试：localhost:9200/oauth/login</p><p>这次输入真正的用户名和密码（这里我测试失败了，感觉是密码有问题）</p><h2 id="6-认证服务对接网关"><a href="#6-认证服务对接网关" class="headerlink" title="6 认证服务对接网关"></a>6 认证服务对接网关</h2><h3 id="6-1-新建网关工程changgou-gateway-web"><a href="#6-1-新建网关工程changgou-gateway-web" class="headerlink" title="6.1 新建网关工程changgou_gateway_web"></a>6.1 新建网关工程changgou_gateway_web</h3><ol><li><p>changgou_gateway(网关的父工程)的pom文件添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--redis--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>新建工程changgou_gateway_web,并创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebGatewayApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(WebGatewayApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建application.yml (网管这里的路径配置还不熟，有时间加强)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway-web</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span><br>        <span class="hljs-attr">cors-configurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span> <span class="hljs-comment"># 匹配所有请求</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment">#跨域处理 允许所有的域</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 支持的方法</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">GET</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">POST</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">PUT</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">DELETE</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_goods_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://goods</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/album/**,/api/brand/**,/api/cache/**,/api/categoryBrand/**,/api/category/**,/api/para/**,/api/pref/**,/api/sku/**,/api/spec/**,/api/spu/**,/api/stockBack/**,/api/template/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-comment">#- PrefixPath=/brand</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>          <span class="hljs-comment">#用户微服务</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_user_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**,/api/address/**,/api/areas/**,/api/cities/**,/api/provinces/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>          <span class="hljs-comment">#认证微服务</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">changgou_oauth_user</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-auth</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/oauth/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-2-网关全局过滤器"><a href="#6-2-网关全局过滤器" class="headerlink" title="6.2 网关全局过滤器"></a>6.2 网关全局过滤器</h3><p><img src="/images/image-20210807164927008.png" alt="image-20210807164927008"></p><p>新建过滤器类AuthorizeFilter,对请求进行过滤</p><p>业务逻辑：</p><ol><li>判断当前请求是否为登录请求，是的话，则放行</li><li>判断cookie中是否存在信息, 没有的话，拒绝访问</li><li>判断redis中令牌是否存在，没有的话，拒绝访问</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthService authService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        ServerHttpRequest request = exchange.getRequest();<br>        ServerHttpResponse response = exchange.getResponse();<br><br>        <span class="hljs-comment">//1.判断当前请求路径是否为登录请求,如果是,则直接放行</span><br>        String path = request.getURI().getPath();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/api/oauth/login&quot;</span>.equals(path) || !UrlFilter.hasAuthorize(path) )&#123;<br>            <span class="hljs-comment">//直接放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br><br>        <span class="hljs-comment">//2.从cookie中获取jti的值,如果该值不存在,拒绝本次访问</span><br>        String jti = authService.getJtiFromCookie(request);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(jti))&#123;<br>            <span class="hljs-comment">//拒绝访问</span><br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br><br>        <span class="hljs-comment">//3.从redis中获取jwt的值,如果该值不存在,拒绝本次访问</span><br>        String jwt = authService.getJwtFromRedis(jti);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(jwt))&#123;<br>            <span class="hljs-comment">//拒绝访问</span><br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br><br>        <span class="hljs-comment">//4.对当前的请求对象进行增强,让它会携带令牌的信息</span><br>        request.mutate().header(<span class="hljs-string">&quot;Authorization&quot;</span>,<span class="hljs-string">&quot;Bearer &quot;</span>+jwt);<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建业务逻辑类AuthService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-comment">//从cookie中获取jti的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJtiFromCookie</span><span class="hljs-params">(ServerHttpRequest request)</span> </span>&#123;<br>        HttpCookie httpCookie = request.getCookies().getFirst(<span class="hljs-string">&quot;uid&quot;</span>);<br>        <span class="hljs-keyword">if</span> (httpCookie != <span class="hljs-keyword">null</span>)&#123;<br>            String jti = httpCookie.getValue();<br>            <span class="hljs-keyword">return</span> jti;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//从redis中获取jwt</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getJwtFromRedis</span><span class="hljs-params">(String jti)</span> </span>&#123;<br>        String jwt = stringRedisTemplate.boundValueOps(jti).get();<br>        <span class="hljs-keyword">return</span> jwt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><p>访问：<a href="http://localhost:8001/api/oauth/login%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87%EF%BC%8C%E6%8B%BF%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%95%B0%E6%8D%AE">http://localhost:8001/api/oauth/login，可以发现测试通过，拿到返回结果数据</a></p><p><img src="/images/image-20210807165333771.png" alt="image-20210807165333771"></p><h2 id="7-自定义登录页面"><a href="#7-自定义登录页面" class="headerlink" title="7 自定义登录页面"></a>7 自定义登录页面</h2><ol><li><p>认证服务添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>把静态资源和页面放到changgou_user_auth微服务中</p><p><img src="/images/image-20210807172105423.png" alt="image-20210807172105423"></p></li><li><p>静态资源放行，修改WebSecurityConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 忽略安全拦截的URL</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> web</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    web.ignoring().antMatchers(<br>            <span class="hljs-string">&quot;/oauth/login&quot;</span>,<br>            <span class="hljs-string">&quot;/oauth/logout&quot;</span>,<br>            <span class="hljs-string">&quot;/oauth/toLogin&quot;</span>,<span class="hljs-string">&quot;/login.html&quot;</span>,<span class="hljs-string">&quot;/css/**&quot;</span>,<span class="hljs-string">&quot;/data/**&quot;</span>,<span class="hljs-string">&quot;/fonts/**&quot;</span>,<span class="hljs-string">&quot;/img/**&quot;</span>,<span class="hljs-string">&quot;/js/**&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>开启表单登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    http.csrf().disable()<br>            .httpBasic()        <span class="hljs-comment">//启用Http基本身份验证</span><br>            .and()<br>            .formLogin()       <span class="hljs-comment">//启用表单身份验证</span><br>            .and()<br>            .authorizeRequests()    <span class="hljs-comment">//限制基于Request请求访问</span><br>            .anyRequest()<br>            .authenticated();       <span class="hljs-comment">//其他请求都需要经过验证</span><br>   <br>    http.formLogin().loginPage(<span class="hljs-string">&quot;/oauth/toLogin&quot;</span>)  <span class="hljs-comment">//设置访问登录页面的路径</span><br>            .loginProcessingUrl(<span class="hljs-string">&quot;/oauth/login&quot;</span>);  <span class="hljs-comment">//设置执行登录操作的路径</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在changgou_user_auth微服务中的AuthController类上怎加下面的访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/toLogin&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改login.html的登录页面, 并定义前端的login方法</p><p>100行开始</p><p><img src="/images/image-20210807173951504.png" alt="image-20210807173951504"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--script样式的修改放最后面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="javascript"><span class="hljs-attr">username</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript"><span class="hljs-attr">password</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript"><span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="javascript">&#125;,</span><br><span class="javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="javascript"><span class="hljs-attr">login</span>:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">app.msg=<span class="hljs-string">&quot;正在登录&quot;</span>;</span><br><span class="javascript">axios.post(<span class="hljs-string">&quot;/api/oauth/login?username=&quot;</span>+app.username+<span class="hljs-string">&quot;&amp;password=&quot;</span>+app.password).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span> (response.data.flag)&#123;</span><br><span class="javascript">app.msg=<span class="hljs-string">&quot;登录成功&quot;</span>;</span><br><span class="javascript">&#125; <span class="hljs-keyword">else</span>&#123;</span><br><span class="javascript">app.msg=<span class="hljs-string">&quot;登录失败&quot;</span>;</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;)</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>定义路经过滤，方便统一授权资源</p><p><img src="/images/image-20210807174204477.png" alt="image-20210807174204477"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UrlFilter</span> </span>&#123;<br><br>    <span class="hljs-comment">//所有需要传递令牌的地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String filterPath=<span class="hljs-string">&quot;/api/wseckillorder,/api/seckill,/api/wxpay,/api/wxpay/**,/api/worder/**,/api/user/**,/api/address/**,/api/wcart/**,/api/cart/**,/api/categoryReport/**,/api/orderConfig/**,/api/order/**,/api/orderItem/**,/api/orderLog/**,/api/preferential/**,/api/returnCause/**,/api/returnOrder/**,/api/returnOrderItem/**&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAuthorize</span><span class="hljs-params">(String url)</span></span>&#123;<br><br>        String[] split = filterPath.replace(<span class="hljs-string">&quot;**&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String value : split) &#123;<br><br>            <span class="hljs-keyword">if</span> (url.startsWith(value))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">//代表当前的访问地址是需要传递令牌的</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//代表当前的访问地址是不需要传递令牌的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后进行测试</p><p>访问：<a href="http://localhost:9200/oauth/toLogin">http://localhost:9200/oauth/toLogin</a></p><p><img src="/images/image-20210807174443284.png" alt="image-20210807174443284"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第三部分</title>
    <link href="/2021/07/27/1.3%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/27/1.3%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part07-商品搜索"><a href="#Part07-商品搜索" class="headerlink" title="Part07 商品搜索"></a>Part07 商品搜索</h1><h2 id="1-根据关键字查询"><a href="#1-根据关键字查询" class="headerlink" title="1. 根据关键字查询"></a>1. 根据关键字查询</h2><ol><li><p>changgou_service_search项目创建SearchService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SearchService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 全文检索</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> searchMap</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//他的实现类会抛异常，所以接口里也需要抛出异常</span><br>    <span class="hljs-function">Map <span class="hljs-title">search</span><span class="hljs-params">(Map&lt;String, String&gt; searchMap)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_search项目创建SearchService接口实现类SearchServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SearchService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ElasticsearchTemplate esTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">search</span><span class="hljs-params">(Map&lt;String, String&gt; searchMap)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Map&lt;String, Object&gt; resultMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">//有条件才查询Es</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != searchMap) &#123;<br>            <span class="hljs-comment">//组合条件对象</span><br>            BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();<br>            <span class="hljs-comment">//0:关键词</span><br>            <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(searchMap.get(<span class="hljs-string">&quot;keywords&quot;</span>))) &#123;<br>                boolQuery.must(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, searchMap.get(<span class="hljs-string">&quot;keywords&quot;</span>)).operator(Operator.AND));<br><br>            &#125;<br><br>            <span class="hljs-comment">//4. 原生搜索实现类</span><br>            NativeSearchQueryBuilder nativeSearchQueryBuilder = <span class="hljs-keyword">new</span> NativeSearchQueryBuilder();<br>            nativeSearchQueryBuilder.withQuery(boolQuery);<br><br>            <span class="hljs-comment">//10: 执行查询, 返回结果对象</span><br>            AggregatedPage&lt;SkuInfo&gt; aggregatedPage = esTemplate.queryForPage(nativeSearchQueryBuilder.build(), SkuInfo.class, <span class="hljs-keyword">new</span> SearchResultMapper() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">AggregatedPage&lt;T&gt; <span class="hljs-title">mapResults</span><span class="hljs-params">(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;<br><br>                    List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>                    SearchHits hits = searchResponse.getHits();<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != hits) &#123;<br>                        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>                            SkuInfo skuInfo = JSON.parseObject(hit.getSourceAsString(), SkuInfo.class);<br><br>                            list.add((T) skuInfo);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AggregatedPageImpl&lt;T&gt;(list, pageable, hits.getTotalHits(), searchResponse.getAggregations());<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//11. 总条数</span><br>            resultMap.put(<span class="hljs-string">&quot;total&quot;</span>, aggregatedPage.getTotalElements());<br>            <span class="hljs-comment">//12. 总页数</span><br>            resultMap.put(<span class="hljs-string">&quot;totalPages&quot;</span>, aggregatedPage.getTotalPages());<br>            <span class="hljs-comment">//13. 查询结果集合</span><br>            resultMap.put(<span class="hljs-string">&quot;rows&quot;</span>, aggregatedPage.getContent());<br><br>            <span class="hljs-keyword">return</span> resultMap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_search项目创建SearchController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/sku_search&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ESManagerService esManagerService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SearchService searchService;<br><br>    <span class="hljs-comment">//对搜索入参带有特殊符号进行处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerSearchMap</span><span class="hljs-params">(Map&lt;String,String&gt; searchMap)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != searchMap)&#123;<br>            Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = searchMap.entrySet();<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;<br>                <span class="hljs-keyword">if</span>(entry.getKey().startsWith(<span class="hljs-string">&quot;spec_&quot;</span>))&#123;<br>                    searchMap.put(entry.getKey(),entry.getValue().replace(<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;%2B&quot;</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 全文检索</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; paramMap)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//特殊符号处理</span><br>        handlerSearchMap(paramMap);<br>        Map resultMap = searchService.search(paramMap);<br>        <span class="hljs-keyword">return</span> resultMap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>使用postmain访问 <a href="http://localhost:9009/sku_search?keywords=%E6%89%8B%E6%9C%BA">http://localhost:9009/sku_search?keywords=手机</a></p><p>虽然查询出9000多条结果，但是默认只显示10条数据</p><p><img src="/images/image-20210804195339008.png" alt="image-20210804195339008"></p></li></ol><h2 id="2-条件筛选"><a href="#2-条件筛选" class="headerlink" title="2 条件筛选"></a>2 条件筛选</h2><p><img src="/images/image-20210804195611466.png" alt="image-20210804195611466"></p><p>用户有可能会根据分类搜索、品牌搜索，还有可能根据规格搜索，以及价格搜索和排序操作。根据分类和品牌搜索的时候，可以直接根据指定域搜索，而规格搜索的域数据是不确定的，价格是一个区间搜索，所以我们可以分为三段实现，先实现分类、品牌搜素，再实现规格搜索，然后实现价格区间搜索。</p><h3 id="2-1-品牌筛选"><a href="#2-1-品牌筛选" class="headerlink" title="2.1 品牌筛选"></a>2.1 品牌筛选</h3><h4 id="2-1-1-需求分析"><a href="#2-1-1-需求分析" class="headerlink" title="2.1.1 需求分析"></a>2.1.1 需求分析</h4><p>页面每次向后台传入对应的分类和品牌，后台据分类和品牌进行条件过滤即可。</p><h4 id="2-1-2-代码实现"><a href="#2-1-2-代码实现" class="headerlink" title="2.1.2 代码实现"></a>2.1.2 代码实现</h4><p>修改搜索微服务com.changgou.service.SearchServiceImpl的搜索方法，添加品牌过滤</p><p>增加品牌筛选部分 (后面增加部分也都用序号来表示先后顺序) 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1:条件 品牌</span><br><span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(searchMap.get(<span class="hljs-string">&quot;brand&quot;</span>))) &#123;<br>    <span class="hljs-comment">//按照品牌进行过滤查询。这里的brandName是索引库中的一个域值，不是随便写的名字</span><br>    boolQuery.filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;brandName&quot;</span>, searchMap.get(<span class="hljs-string">&quot;brand&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-3-测试"><a href="#2-1-3-测试" class="headerlink" title="2.1.3 测试"></a>2.1.3 测试</h4><p>访问地址：<a href="http://localhost:9009/sku_search?keywords=%E6%89%8B%E6%9C%BA&amp;brand=%E5%8D%8E%E4%B8%BA">http://localhost:9009/sku_search?keywords=手机&amp;brand=华为</a></p><p>结果如下：</p><p>可以看到比第一次的数据少了几千条</p><p><img src="/images/image-20210804201208277.png" alt="image-20210804201208277"></p><h3 id="2-2-规格过滤"><a href="#2-2-规格过滤" class="headerlink" title="2.2 规格过滤"></a>2.2 规格过滤</h3><h4 id="2-2-1-需求分析"><a href="#2-2-1-需求分析" class="headerlink" title="2.2.1 需求分析"></a>2.2.1 需求分析</h4><p><img src="/images/image-20210804195611466-1628079276433.png" alt="image-20210804195611466"></p><p>规格这一部分，需要向后台发送规格名字以及规格值，我们可以按照一定要求来发送数据，例如规格名字以特殊前缀提交到后台：<code>spec_网络制式：电信4G、spec_显示屏尺寸：4.0-4.9英寸</code></p><p>后台接到数据后，可以根据前缀spec_来区分是否是规格，如果以<code>spec_xxx</code>开始的数据则为规格数据，需要根据指定规格找信息。</p><p><img src="/images/image-20210804201759706.png" alt="image-20210804201759706"></p><p>上图是规格的索引存储格式，真实数据在spechMap.规格名字.keyword（这个是规格的域）中，所以找数据也是按照如下格式去找：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">spechMap.规格名字.<span class="hljs-keyword">keyword</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h4><p>修改com.changgou.service.SearchServiceImpl的搜索方法，增加规格查询操作</p><p>增加部分的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2:条件 规格</span><br><span class="hljs-keyword">for</span> (String key : searchMap.keySet()) &#123;<br>    <span class="hljs-keyword">if</span> (key.startsWith(<span class="hljs-string">&quot;spec_&quot;</span>)) &#123;<br>        <span class="hljs-comment">//发送请求的路径会涉及到编码和解码，如果不设置下面这一步，传递过来的路径就是错误的</span><br>        String value = searchMap.get(key).replace(<span class="hljs-string">&quot;%2B&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>);<br>        boolQuery.filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;specMap.&quot;</span> + key.substring(<span class="hljs-number">5</span>) + <span class="hljs-string">&quot;.keyword&quot;</span>,value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h4><p>访问地址：<a href="http://localhost:9009/sku_search?keywords=%E7%94%B5%E8%A7%86&amp;spec_%E5%B0%BA%E5%AF%B8=%E9%87%91%E8%89%B2">http://localhost:9009/sku_search?keywords=电视&amp;spec_尺寸=金色</a></p><p><img src="/images/image-20210804211201850.png" alt="image-20210804211201850"></p><h3 id="2-3-聚合（分组）查询"><a href="#2-3-聚合（分组）查询" class="headerlink" title="2.3 聚合（分组）查询"></a>2.3 聚合（分组）查询</h3><h4 id="2-3-1-需求分析"><a href="#2-3-1-需求分析" class="headerlink" title="2.3.1 需求分析"></a>2.3.1 需求分析</h4><p><img src="/images/image-20210804195611466-1628083462378.png" alt="image-20210804195611466"></p><p>根据查询的结果返回一个brandList给前端，用于更新品牌展示和规格展示</p><h4 id="2-3-2-代码实现"><a href="#2-3-2-代码实现" class="headerlink" title="2.3.2 代码实现"></a>2.3.2 代码实现</h4><p>1）品牌聚合</p><p>修改com.changgou.service.SearchServiceImpl的搜索方法，增加品牌聚合操作</p><p>增加的代码部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//6. 品牌聚合(分组)查询</span><br>String skuBrand = <span class="hljs-string">&quot;skuBrand&quot;</span>;<br><span class="hljs-comment">// terms(skuBrand)设置分组查询之后的列名为skuBrand， field(&quot;brandName&quot;)当前要来操作的分组域</span><br>nativeSearchQueryBuilder.addAggregation(AggregationBuilders.terms(skuBrand).field(<span class="hljs-string">&quot;brandName&quot;</span>));<br><br><span class="hljs-comment">//14. 获取品牌聚合结果</span><br>StringTerms brandTerms = (StringTerms) aggregatedPage.getAggregation(skuBrand);<br><span class="hljs-comment">//流运算，比原始for循环效率高很多</span><br>List&lt;String&gt; brandList = brandTerms.getBuckets().stream().map(bucket -&gt; bucket.getKeyAsString()).collect(Collectors.toList());<br>resultMap.put(<span class="hljs-string">&quot;brandList&quot;</span>, brandList);<br></code></pre></td></tr></table></figure><p>2）规格聚合</p><p>修改com.changgou.service.SearchServiceImpl的搜索方法，增加规格聚合操作</p><p>增加的代码部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//7. 规格聚合(分组)查询</span><br>String skuSpec = <span class="hljs-string">&quot;skuSpec&quot;</span>;<br>nativeSearchQueryBuilder.addAggregation(AggregationBuilders.terms(skuSpec).field(<span class="hljs-string">&quot;spec.keyword&quot;</span>));<br><br><span class="hljs-comment">//15. 获取规格聚合结果</span><br>StringTerms specTerms = (StringTerms) aggregatedPage.getAggregation(skuSpec);<br>List&lt;String&gt; specList = specTerms.getBuckets().stream().map(bucket -&gt; bucket.getKeyAsString()).collect(Collectors.toList());<br>resultMap.put(<span class="hljs-string">&quot;specList&quot;</span>, specList);<br><br><span class="hljs-keyword">return</span> resultMap;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-测试"><a href="#2-3-3-测试" class="headerlink" title="2.3.3 测试"></a>2.3.3 测试</h4><p>访问地址：<a href="http://localhost:9009/sku_search?keywords=%E7%94%B5%E8%A7%86">http://localhost:9009/sku_search?keywords=电视</a></p><p>可以看到结果多出来一个brandList</p><p><img src="/images/image-20210804212744912.png" alt="image-20210804212744912"></p><p>访问地址：<a href="http://localhost:9009/sku_search?spec_%E5%B0%BA%E5%AF%B8=%E9%87%91%E8%89%B2">http://localhost:9009/sku_search?spec_尺寸=金色</a></p><p>可以看到结果多出来一个specList</p><p><img src="/images/image-20210804213513056.png" alt="image-20210804213513056"></p><h3 id="2-4-价格区间查询"><a href="#2-4-价格区间查询" class="headerlink" title="2.4 价格区间查询"></a>2.4 价格区间查询</h3><h4 id="2-4-1-需求分析"><a href="#2-4-1-需求分析" class="headerlink" title="2.4.1 需求分析"></a>2.4.1 需求分析</h4><p><img src="/images/image-20210804195611466-1628083462378.png" alt="image-20210804195611466"></p><p>价格区间查询，每次需要将价格传入到后台，前端传入后台的价格大概是<code>price=0-500</code>或者<code>price=500-1000</code>依次类推，最后一个是<code>price=3000</code>,后台可以根据-分割，如果分割得到的结果最多有2个，第1个表示<code>x&lt;price</code>，第2个表示<code>price&lt;=y</code>。</p><h4 id="2-4-2-代码实现"><a href="#2-4-2-代码实现" class="headerlink" title="2.4.2 代码实现"></a>2.4.2 代码实现</h4><p>修改com.changgou.service.impl.SearchServiceImpl的搜索方法，增加价格区间查询操作</p><p>增加的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3:条件 价格</span><br><span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(searchMap.get(<span class="hljs-string">&quot;price&quot;</span>))) &#123;<br>    String[] p = searchMap.get(<span class="hljs-string">&quot;price&quot;</span>).split(<span class="hljs-string">&quot;-&quot;</span>);<br>    <span class="hljs-keyword">if</span> (p.length == <span class="hljs-number">2</span>) &#123;<br>        boolQuery.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(p[<span class="hljs-number">1</span>]));<br>    &#125;  boolQuery.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(p[<span class="hljs-number">0</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-3-测试"><a href="#2-4-3-测试" class="headerlink" title="2.4.3 测试"></a>2.4.3 测试</h4><p>访问地址：<a href="http://localhost:9009/sku_search?price=0-500">http://localhost:9009/sku_search?price=0-500</a></p><p>可以看到价格均在这个区间</p><p><img src="/images/image-20210804220238483.png" alt="image-20210804220238483"></p><h2 id="3-搜索分页"><a href="#3-搜索分页" class="headerlink" title="3. 搜索分页"></a>3. 搜索分页</h2><h3 id="3-1-分页分析"><a href="#3-1-分页分析" class="headerlink" title="3.1 分页分析"></a>3.1 分页分析</h3><p><img src="/images/image-20210804230948101.png" alt="image-20210804230948101"></p><p>页面需要实现分页搜索，所以我们后台每次查询的时候，需要实现分页。用户页面每次会传入当前页和每页查询多少条数据，当然如果不传入每页显示多少条数据，默认查询30条即可。</p><p>前端需要传递过来两个参数，分别是当前页数和每页传递多少条数据</p><h3 id="3-2-分页实现"><a href="#3-2-分页实现" class="headerlink" title="3.2 分页实现"></a>3.2 分页实现</h3><p>分页使用PageRequest.of( pageNo- 1, pageSize);实现，第1个参数表示第N页，从0开始，第2个参数表示每页显示多少条</p><p>增加的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//9: 分页</span><br>String pageNum = searchMap.get(<span class="hljs-string">&quot;pageNum&quot;</span>); <span class="hljs-comment">//当前页</span><br>String pageSize = searchMap.get(<span class="hljs-string">&quot;pageSize&quot;</span>); <span class="hljs-comment">//每页显示多少条</span><br><span class="hljs-comment">//如果前端没有传递，进行默认值设置</span><br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(pageNum)) &#123;<br>    pageNum = <span class="hljs-string">&quot;1&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(StringUtils.isEmpty(pageSize))&#123;<br>    pageSize = <span class="hljs-string">&quot;30&quot;</span>;<br>&#125;<br>nativeSearchQueryBuilder.withPageable(PageRequest.of(Integer.parseInt(pageNum) - <span class="hljs-number">1</span>, Integer.parseInt(pageSize)));<br><br><span class="hljs-comment">//16. 返回当前页</span><br>resultMap.put(<span class="hljs-string">&quot;pageNum&quot;</span>, pageNum);<br></code></pre></td></tr></table></figure><p>测试地址：<a href="http://localhost:9009/sku_search?pageNum=1&amp;pageSize=20">http://localhost:9009/sku_search?pageNum=1&amp;pageSize=20</a></p><p>可以看到总页数不再是1了，其实翻到最下面可以看到当前页为1，但是图片中就不放出来了</p><p><img src="/images/image-20210804232503168.png" alt="image-20210804232503168"></p><h2 id="4-搜索排序"><a href="#4-搜索排序" class="headerlink" title="4. 搜索排序"></a>4. 搜索排序</h2><h3 id="4-1-排序分析"><a href="#4-1-排序分析" class="headerlink" title="4.1 排序分析"></a>4.1 排序分析</h3><p><img src="/images/image-20210804232701584.png" alt="image-20210804232701584"></p><p>排序这里总共有根据价格排序、根据评价排序、根据新品排序、根据销量排序，排序要想实现非常简单，只需要告知排序的域以及排序方式即可实现。</p><p>价格排序：只需要根据价格高低排序即可，降序价格高-&gt;低，升序价格低-&gt;高</p><p>评价排序：评价分为好评、中评、差评，可以在数据库中设计3个列，用来记录好评、中评、差评的量，每次排序的时候，好评的比例来排序，当然还要有条数限制，评价条数需要超过N条。</p><p>新品排序：直接根据商品的发布时间或者更新时间排序。</p><p>销量排序：销量排序除了销售数量外，还应该要有时间段限制。</p><h3 id="4-2-排序实现"><a href="#4-2-排序实现" class="headerlink" title="4.2 排序实现"></a>4.2 排序实现</h3><p>这里我们不单独针对某个功能实现排序，我们只需要在后台接收2个参数，分别是排序域名字和排序方式</p><p>增加部分的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//8: 排序</span><br><span class="hljs-keyword">if</span> (!StringUtils.isEmpty(searchMap.get(<span class="hljs-string">&quot;sortField&quot;</span>))) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;ASC&quot;</span>.equals(searchMap.get(<span class="hljs-string">&quot;sortRule&quot;</span>))) &#123;<br>        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(searchMap.get(<span class="hljs-string">&quot;sortField&quot;</span>)).order(SortOrder.ASC));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(searchMap.get(<span class="hljs-string">&quot;sortField&quot;</span>)).order(SortOrder.DESC));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:9009/sku_search?pageNum=1&amp;pageSize=1000&amp;sortField=price&amp;sortOrder=DESC">http://localhost:9009/sku_search?pageNum=1&amp;pageSize=1000&amp;sortField=price&amp;sortOrder=DESC</a></p><p>按照价格降序排序，每页显示1000条数据</p><h2 id="5-高亮显示"><a href="#5-高亮显示" class="headerlink" title="5. 高亮显示"></a>5. 高亮显示</h2><h3 id="5-1-高亮分析"><a href="#5-1-高亮分析" class="headerlink" title="5.1 高亮分析"></a>5.1 高亮分析</h3><p><img src="/images/image-20210804233916692.png" alt="image-20210804233916692"></p><p>高亮显示是指根据商品关键字搜索商品的时候，显示的页面对关键字给定了特殊样式，让它显示更加突出，如上图商品搜索中，关键字编程了红色，其实就是给定了红色样式。</p><h3 id="5-2-高亮搜索实现步骤解析"><a href="#5-2-高亮搜索实现步骤解析" class="headerlink" title="5.2 高亮搜索实现步骤解析"></a>5.2 高亮搜索实现步骤解析</h3><p>将之前的搜索换掉，换成高亮搜索，我们需要做3个步骤：</p><ol><li>指定高亮域，也就是设置哪个域需要高亮显示。设置高亮域的时候，需要指定前缀和后缀，也就是关键词用什么html标签包裹，再给该标签</li><li>高亮搜索实现</li><li>将非高亮数据替换成高亮数据</li></ol><p>第1点，例如在百度中搜索数据的时候，会有2个地方高亮显示，分别是标题和描述，商城搜索的时候，只是商品名称高亮显示了。而高亮显示其实就是添加了样式，例如<code>&lt;span style=&quot;color:red;&quot;&gt;笔记本&lt;/span&gt;</code>,而其中span开始标签可以称为前缀，span结束标签可以称为后缀。</p><p>第2点，高亮搜索使用ElasticsearchTemplate实现。</p><p>第3点，高亮搜索后，会搜出非高亮数据和高亮数据，高亮数据会加上第1点中的高亮样式，此时我们需要将非高亮数据换成高亮数据即可。例如非高亮:<code>华为笔记本性能超强悍</code> 高亮数据：<code>华为&lt;span style=&quot;color:red;&quot;笔记本&lt;/span&gt;性能超强悍</code>,将非高亮的换成高亮的，到页面就能显示样式了。</p><h3 id="5-3-高亮代码实现"><a href="#5-3-高亮代码实现" class="headerlink" title="5.3 高亮代码实现"></a>5.3 高亮代码实现</h3><p>删掉之前com.changgou.service.impl.SearchServiceImpl的搜索方法搜索代码，用下面高亮搜索代码替换：</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//5:高亮</span><br>HighlightBuilder.Field field = <span class="hljs-keyword">new</span> HighlightBuilder<br>        .Field(<span class="hljs-string">&quot;name&quot;</span>)<br>        .preTags(<span class="hljs-string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>)<br>        .postTags(<span class="hljs-string">&quot;&lt;/span&gt;&quot;</span>);<br>nativeSearchQueryBuilder.withHighlightFields(field);<br><br><br><span class="hljs-comment">//10: 执行查询, 返回结果对象</span><br>AggregatedPage&lt;SkuInfo&gt; aggregatedPage = esTemplate.queryForPage(nativeSearchQueryBuilder.build(), SkuInfo.class, <span class="hljs-keyword">new</span> SearchResultMapper() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">AggregatedPage&lt;T&gt; <span class="hljs-title">mapResults</span><span class="hljs-params">(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;<br><br>        List&lt;T&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        SearchHits hits = searchResponse.getHits();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != hits) &#123;<br>            <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>                SkuInfo skuInfo = JSON.parseObject(hit.getSourceAsString(), SkuInfo.class);<br>                <span class="hljs-comment">//========设置高亮域==========</span><br>                Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != highlightFields &amp;&amp; highlightFields.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                    skuInfo.setName(highlightFields.get(<span class="hljs-string">&quot;name&quot;</span>).getFragments()[<span class="hljs-number">0</span>].toString());<br>                &#125;<br>                <span class="hljs-comment">//===========================</span><br>                list.add((T) skuInfo);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AggregatedPageImpl&lt;T&gt;(list, pageable, hits.getTotalHits(), searchResponse.getAggregations());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:9009/sku_search?pageNum=1&amp;pageSize=1000&amp;sortField=price&amp;sortOrder=DESC&amp;keywords=%E7%94%B5%E8%84%91">http://localhost:9009/sku_search?pageNum=1&amp;pageSize=1000&amp;sortField=price&amp;sortOrder=DESC&amp;keywords=电脑</a></p><p>会发现返回结果关键字电脑前后加上了标签，如果是在浏览器上，将会高亮</p><p><img src="/images/image-20210804235641430.png" alt="image-20210804235641430"></p><h1 id="Part08-Thymeleaf"><a href="#Part08-Thymeleaf" class="headerlink" title="Part08 Thymeleaf"></a>Part08 Thymeleaf</h1><h2 id="1-Thymeleaf介绍"><a href="#1-Thymeleaf介绍" class="headerlink" title="1. Thymeleaf介绍"></a>1. Thymeleaf介绍</h2><p>thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><p>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p><p>它的特点便是：开箱即用，Thymeleaf允许您处理六种模板，每种模板称为模板模式：</p><ul><li>XML</li><li>有效的XML</li><li>XHTML</li><li>有效的XHTML</li><li>HTML5</li><li>旧版HTML5</li></ul><p>所有这些模式都指的是格式良好的XML文件，但<em>Legacy HTML5</em>模式除外，它允许您处理HTML5文件，其中包含独立（非关闭）标记，没有值的标记属性或不在引号之间写入的标记属性。为了在这种特定模式下处理文件，Thymeleaf将首先执行转换，将您的文件转换为格式良好的XML文件，这些文件仍然是完全有效的HTML5（实际上是创建HTML5代码的推荐方法）<a href="https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html#fn1">1</a>。</p><p>另请注意，验证仅适用于XML和XHTML模板。</p><p>然而，这些并不是Thymeleaf可以处理的唯一模板类型，并且用户始终能够通过指定在此模式下<em>解析</em>模板的方法和<em>编写</em>结果的方式来定义他/她自己的模式。这样，任何可以建模为DOM树（无论是否为XML）的东西都可以被Thymeleaf有效地作为模板处理。</p><h2 id="2-Springboot整合thymeleaf"><a href="#2-Springboot整合thymeleaf" class="headerlink" title="2. Springboot整合thymeleaf"></a>2. Springboot整合thymeleaf</h2><p>使用springboot 来集成使用Thymeleaf可以大大减少单纯使用thymleaf的代码量，所以我们接下来使用springboot集成使用thymeleaf.</p><p>实现的步骤为：</p><ul><li>创建一个sprinboot项目</li><li>添加thymeleaf的起步依赖</li><li>添加spring web的起步依赖</li><li>编写html 使用thymleaf的语法获取变量对应后台传递的值</li><li>编写controller 设置变量的值到model中</li></ul><p>具体代码如下</p><ol><li><p>创建工程，添加pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--web起步依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>    <span class="hljs-comment">&lt;!--thymeleaf配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建启动类(我这里的名字起的比较随意)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(TestApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">thymeleaf:</span><br>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置thymeleaf的缓存为false</span><br></code></pre></td></tr></table></figure></li><li><p>创建controller用于测试后台 设置数据到model中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>  <span class="hljs-comment">// 这里是需要跳转到demo.html页面，不是返回数据，所以用的是@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hello thymeleaf&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建demo.html到resources.templates包下 （注意templates这个包名是固定的，不能乱写）</p><p>注意：</p><ul><li><code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>这句声明使用thymeleaf标签, 不能忘了</li><li><code>th:text=&quot;$&#123;hello&#125;</code>使用了EL表达式，通过“hello”这个键获取他的值，controller中已经设置了他的值为“hello thymeleaf”</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Thymeleaf快速入门<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><p>访问请求路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><p><img src="/images/image-20210805124816251.png" alt="image-20210805124816251"></p></li></ol><h2 id="3-Thymeleaf基本语法"><a href="#3-Thymeleaf基本语法" class="headerlink" title="3. Thymeleaf基本语法"></a>3. Thymeleaf基本语法</h2><h3 id="3-1-提交表单（th-action）"><a href="#3-1-提交表单（th-action）" class="headerlink" title="3.1 提交表单（th:action）"></a>3.1 提交表单（th:action）</h3><p>编写标签</p><p>注意：</p><ul><li><code>@&#123;/test/hello&#125;</code>定义了表单提交路径</li><li><code>th:type=&quot;text&quot;</code>表明这是一个文本框输入标签</li><li><code>th:name=&quot;id&quot;</code>表明文本框的键的名称为id, 记得传递到控制器方法的形参也要定义为id</li><li><code>&lt;button&gt;提交&lt;/button&gt;</code>定义按钮，名称叫提交</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/test/hello&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">th:type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:name</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写相应的控制类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model, String id)</span></span>&#123;<br>    System.out.println(id);<br>    model.addAttribute(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hello thymeleaf&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><h3 id="3-2-对象遍历（th-each）"><a href="#3-2-对象遍历（th-each）" class="headerlink" title="3.2 对象遍历（th:each）"></a>3.2 对象遍历（th:each）</h3><p>创建包pojo，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Controller中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model, String id)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hello thymeleaf&quot;</span>);<br><br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();<br>        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;深圳&quot;</span>));<br>        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>));<br>        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-string">&quot;武汉&quot;</span>));<br>        model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>,users);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写页面标签</p><p>注意：</p><ul><li><code>th:each=&quot;user, userStat:$&#123;users&#125;</code>, th:each表示开启遍历， user表示这个集合中的每一个对象，${users}表示从Model里面拿到的从控制器传递过来的集合，users表示给这个集合取一个集合变量名</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>下标<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>住址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user, users:$&#123;users&#125;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>            下标：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;userStat.index&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><h3 id="3-3-遍历Map集合"><a href="#3-3-遍历Map集合" class="headerlink" title="3.3 遍历Map集合"></a>3.3 遍历Map集合</h3><p>Controller中添加map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,Object&gt; dataMap = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();<br>dataMap.put(<span class="hljs-string">&quot;No&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>dataMap.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;深圳&quot;</span>);<br>model.addAttribute(<span class="hljs-string">&quot;dataMap&quot;</span>,dataMap);<br></code></pre></td></tr></table></figure><p>编写标签语言</p><p>注意： </p><ul><li><code>th:text=&quot;$&#123;map&#125;&quot;</code>会将键值对以 key=value 的形式呈现在浏览器上</li><li><code>$&#123;mapStat.current.key&#125;</code>获取键和值的时候，中间都带了个current</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;map,mapStat:$&#123;dataMap&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;map&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    key:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;mapStat.current.key&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    value:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;mapStat.current.value&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    ==============================================<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><p><img src="/images/image-20210805133846850.png" alt="image-20210805133846850"></p><h3 id="3-4-遍历数组"><a href="#3-4-遍历数组" class="headerlink" title="3.4 遍历数组"></a>3.4 遍历数组</h3><p>Controller中添加数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存储一个数组</span><br>String[] names = &#123;<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>&#125;;<br>model.addAttribute(<span class="hljs-string">&quot;names&quot;</span>,names);<br></code></pre></td></tr></table></figure><p>编写标签</p><p>注意：</p><ul><li><code>nmStat.count</code>中的count是从1开始计数的，如果换成<code>nmStat.index</code>则是从0开始计数的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;nm,nmStat:$&#123;names&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;nmStat.count&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;nm&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    ==============================================<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><p><img src="/images/image-20210805134433640.png" alt="image-20210805134433640"></p><h3 id="3-5-Date输出"><a href="#3-5-Date输出" class="headerlink" title="3.5 Date输出"></a>3.5 Date输出</h3><p>后台添加日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//日期</span><br>model.addAttribute(<span class="hljs-string">&quot;now&quot;</span>,<span class="hljs-keyword">new</span> Date());<br></code></pre></td></tr></table></figure><p>编写标签</p><p>注意：</p><ul><li><code>#dates.format</code>表示调用thymeleaf中的方法</li><li><code>now</code>是从控制器返回过来的键值对中的键</li><li><code>&#39;yyyy-MM-dd hh:ss:mm&#39;</code>设置要显示的日期格式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#dates.format(now,&#x27;yyyy-MM-dd hh:ss:mm&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><p><img src="/images/image-20210805135336701.png" alt="image-20210805135336701"></p><h3 id="3-6-条件判断（th-if）"><a href="#3-6-条件判断（th-if）" class="headerlink" title="3.6 条件判断（th:if）"></a>3.6 条件判断（th:if）</h3><p>Controller添加代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//if条件</span><br>model.addAttribute(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><p>编写标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;(age&gt;=18)&#125;&quot;</span>&gt;</span>终于长大了！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><p><img src="/images/image-20210805135716174.png" alt="image-20210805135716174"></p><h3 id="3-7-模块申明与页面包含"><a href="#3-7-模块申明与页面包含" class="headerlink" title="3.7 模块申明与页面包含"></a>3.7 模块申明与页面包含</h3><p>创建一个footer.html代码如下</p><p>注意：</p><ul><li><code>th:fragment=&quot;copy&quot;</code>定义一个copy模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html;charset=charset=utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>fragment<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;C&quot;</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;copy&quot;</span> &gt;</span><br>    关于我们<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在demo.html中引入模块</p><p>注意：</p><ul><li><code>th:include=&quot;footer::copy&quot;</code>, 表示的是引入footer.html中的被定义为copy的模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;footer::copy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:8080/test/hello">http://localhost:8080/test/hello</a></p><h2 id="4-搜索页面渲染"><a href="#4-搜索页面渲染" class="headerlink" title="4 搜索页面渲染"></a>4 搜索页面渲染</h2><h3 id="4-1-搜索分析"><a href="#4-1-搜索分析" class="headerlink" title="4.1 搜索分析"></a>4.1 搜索分析</h3><p><img src="/images/image-20210805162300670.png" alt="image-20210805162300670"></p><p>搜索页面要显示的内容主要分为3块:</p><ol><li>搜索的数据结果</li><li>筛选出的数据搜索条件</li><li>用户已经勾选的数据条件</li></ol><h3 id="4-2-搜索实现"><a href="#4-2-搜索实现" class="headerlink" title="4.2 搜索实现"></a>4.2 搜索实现</h3><p><img src="/images/image-20210805162446418.png" alt="image-20210805162446418"></p><p>搜索的业务流程如上图，用户每次搜索的时候，先经过搜索业务工程，搜索业务工程调用搜索微服务工程，然后由thymeleaf渲染出静态化页面后返回给客户端</p><h4 id="4-2-1-搜索工程搭建"><a href="#4-2-1-搜索工程搭建" class="headerlink" title="4.2.1 搜索工程搭建"></a>4.2.1 搜索工程搭建</h4><ol><li><p>在changgou-service_search工程中的pom.xml中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>静态资源导入</p><p>将本地笔记中的html页面复制到工程的resources.templates包下</p><p><img src="/images/image-20210805165043549.png" alt="image-20210805165043549"></p><p>将本地笔记中的资源复制到resources.static包下。（这两个包的名字固定）</p><p><img src="/images/image-20210805165243525.png" alt="image-20210805165243525"></p></li><li><p>更改配置文件,在spring下添加内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">thymeleaf:</span><br>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 不开启缓存</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="4-2-2-基础数据渲染"><a href="#4-2-2-基础数据渲染" class="headerlink" title="4.2.2 基础数据渲染"></a>4.2.2 基础数据渲染</h4><ol><li><p>更新SearchController,定义跳转搜索结果页面方法</p><p>代码如下</p><p>注意：</p><ul><li>由于这里要返回到页面，必须把类上的@RestController给换成@Controller，并把其他需要返回给前端json串的方法上添加@ResponseBody的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//搜索页面   http://localhost:9009//sku_search/list?keywords=手机&amp;brand=华为&amp;spec_网络制式=移动4G</span><br><span class="hljs-comment">//入参：Map</span><br><span class="hljs-comment">//返回值 Map</span><br><span class="hljs-comment">//由于页面是thymeleaf 完成的 属于服务器内页面渲染 跳转页面</span><br><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; searchMap, Model model)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   <br>    <span class="hljs-comment">//特殊符号处理，这个方法被单独抽出来了</span><br>    handlerSearchMap(searchMap);<br>   <br>    <span class="hljs-comment">//执行查询返回值</span><br>    Map&lt;String, Object&gt; resultMap = searchService.search(searchMap);<br>   <br>    <span class="hljs-comment">//把药传递的数据以键值对的形式存储在model中</span><br>    model.addAttribute(<span class="hljs-string">&quot;searchMap&quot;</span>, searchMap);<br>    model.addAttribute(<span class="hljs-string">&quot;result&quot;</span>, resultMap);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;search&quot;</span>;  <span class="hljs-comment">//跳转到search.html页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发送请求：<a href="http://localhost:9009//sku_search/list?keywords=%E6%89%8B%E6%9C%BA&amp;brand=%E5%8D%8E%E4%B8%BA&amp;spec_%E7%BD%91%E7%BB%9C%E5%88%B6%E5%BC%8F=%E7%A7%BB%E5%8A%A84G">http://localhost:9009//sku_search/list?keywords=手机&amp;brand=华为&amp;spec_网络制式=移动4G</a></p><p><img src="/images/image-20210805170254574.png" alt="image-20210805170254574"></p></li><li><p>搜索结果页面渲染, 根据用户选择条件回显</p><p>(从search.html的465行开始)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bread&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl sui-breadcrumb&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>全部结果<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;searchMap.keywords&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl sui-tag&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 品牌--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;with-x&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;#maps.containsKey(searchMap,&#x27;brand&#x27;)&#125;&quot;</span>&gt;</span><br>            品牌:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;searchMap.brand&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 价格--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;with-x&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;#maps.containsKey(searchMap,&#x27;price&#x27;)&#125;&quot;</span>&gt;</span><br>            价格:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;searchMap.price&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 规格--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;with-x&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;sm:$&#123;searchMap&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;#strings.startsWith(sm.key,&#x27;spec_&#x27;)&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#strings.replace(sm.key,&#x27;spec_&#x27;,&#x27;&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#strings.replace(sm.value,&#x27;%2B&#x27;,&#x27;+&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl sui-form form-dark&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-control control-right&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-icon icon-touch-magnifier&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>根据规格参数是否携带品牌决定是否返回品牌列表</p><p>代码从500行开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- th:unless和 th:<span class="hljs-keyword">if</span> 的逻辑刚好相反，如果这个map里面有brand的话，返回<span class="hljs-keyword">false</span>--&gt;<br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;type-wrap logo&quot;</span> th:unless=<span class="hljs-string">&quot;$&#123;#maps.containsKey(searchMap,&#x27;brand&#x27;)&#125;&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;fl key brand&quot;</span>&gt;品牌&lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;value logos&quot;</span>&gt;<br>        &lt;ul <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;logo-list&quot;</span>&gt;<br>            &lt;li th:each=<span class="hljs-string">&quot;brand,brandSate:$&#123;result.brandList&#125;&quot;</span>&gt;<br>                &lt;a th:text=<span class="hljs-string">&quot;$&#123;brand&#125;&quot;</span> th:href=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(brand=$&#123;brand&#125;)&#125;&quot;</span>&gt;&lt;/a&gt;<br>            &lt;/li&gt;<br>        &lt;/ul&gt;<br>    &lt;/div&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;ext&quot;</span>&gt;<br>        &lt;a href=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;sui-btn&quot;</span>&gt;多选&lt;/a&gt;<br>        &lt;a href=<span class="hljs-string">&quot;javascript:void(0);&quot;</span>&gt;更多&lt;/a&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>请求路径：<a href="http://localhost:9009//sku_search/list?keywords=%E6%89%8B%E6%9C%BA&amp;brand=%E5%8D%8E%E4%B8%BA">http://localhost:9009//sku_search/list?keywords=手机&amp;brand=华为</a></p><p>可以发现，品牌列表在传递的参数有品牌的时候不见了</p><p><img src="/images/image-20210805191635785.png" alt="image-20210805191635785"></p></li><li><p>规格数据格式转换及规格、价格显示</p><p>更新搜索业务层实现，将json字符串集合，转换成需要的map形式</p><p>记得在规格结果聚合那里调用下面这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将json字符串集合，转换成需要的map形式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> specList</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Map&lt;String, Set&lt;String&gt;&gt; formartSpec(List&lt;String&gt; specList)&#123;<br>    Map&lt;String,Set&lt;String&gt;&gt; resultMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (specList!=<span class="hljs-keyword">null</span> &amp;&amp; specList.size()&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span> (String specJsonString : specList) &#123;  <span class="hljs-comment">//&quot;&#123;&#x27;颜色&#x27;: &#x27;黑色&#x27;, &#x27;尺码&#x27;: &#x27;250度&#x27;&#125;&quot;</span><br>            <span class="hljs-comment">//将获取到的json转换为map</span><br>            Map&lt;String,String&gt; specMap = JSON.parseObject(specJsonString, Map.class);<br>            <span class="hljs-keyword">for</span> (String specKey : specMap.keySet()) &#123;<br>                Set&lt;String&gt; specSet = resultMap.get(specKey);<br>                <span class="hljs-keyword">if</span> (specSet == <span class="hljs-keyword">null</span>)&#123;<br>                    specSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>                &#125;<br>                <span class="hljs-comment">//将规格信息存入set中</span><br>                specSet.add(specMap.get(specKey));<br>                <span class="hljs-comment">//将set存入map</span><br>                resultMap.put(specKey,specSet);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultMap;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新页面与规格相关部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--规格部分--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-wrap&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;spec,specStat:$&#123;result.specList&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$&#123;#maps.containsKey(searchMap,&#x27;spec_&#x27;+spec.key)&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl key&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;spec.key&#125;&quot;</span>&gt;</span><br>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl value&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;op,opstat:$&#123;spec.value&#125;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;op&#125;&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(&#x27;spec_&#x27;+$&#123;spec.key&#125;=$&#123;op&#125;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl ext&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新价格相关代码</p><p>531行开始</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--价格部分--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-wrap&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$&#123;#maps.containsKey(searchMap,&#x27;price&#x27;)&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl key&quot;</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl value&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;type-list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;0-500元&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;0-500&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;500-1000元&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;500-1000&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;1000-1500元&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;1000-1500&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;1500-2000元&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;1500-2000&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;2000-3000元&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;2000-3000&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;3000元以上&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(price=&#x27;3000&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fl ext&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请求路径： <a href="http://localhost:9009//sku_search/list?keywords=%E6%89%8B%E6%9C%BA">http://localhost:9009//sku_search/list?keywords=手机</a></p><p>可以看到品牌，规格，价格都有改动</p><p><img src="/images/image-20210805193700666.png" alt="image-20210805193700666"></p></li><li><p>商品列表</p><p>609行开始</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--商品列表--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;goods-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;yui3-g&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;yui3-u-1-5&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;sku,skuStat:$&#123;result.rows&#125;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-wrap&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p-img&quot;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--&lt;a th:href=&quot;&#x27;http://192.168.200.128:8081/&#x27;+$&#123;sku.spuId&#125;+&#x27;.html&#x27;&quot;  target=&quot;_blank&quot;&gt;&lt;img th:src=&quot;$&#123;sku.image&#125;&quot; /&gt;&lt;/a&gt;--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;&#x27;http://192.168.200.128:8081/10000000616300.html&#x27;&quot;</span>  <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;$&#123;sku.image&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>¥<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;sku.price&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;attr&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;&#x27;http://192.168.200.128:8081/10000000616300.html&#x27;&quot;</span> <span class="hljs-attr">th:title</span>=<span class="hljs-string">&quot;$&#123;sku.spec&#125;&quot;</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;sku.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;commit&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;command&quot;</span>&gt;</span>已有<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2000<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>人评价<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;operate&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;success-cart.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-btn btn-bordered btn-danger&quot;</span>&gt;</span>加入购物车<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0);&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-btn btn-bordered&quot;</span>&gt;</span>收藏<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>请求路径：<a href="http://localhost:9009//sku_search/list?keywords=%E7%94%B5%E8%A7%86">http://localhost:9009//sku_search/list?keywords=电视</a></p><p><img src="/images/image-20210805194727321.png" alt="image-20210805194727321"></p></li></ol><h3 id="4-3-关键字搜索"><a href="#4-3-关键字搜索" class="headerlink" title="4.3 关键字搜索"></a>4.3 关键字搜索</h3><p>修改search.html，54行开始</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/search/list&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-form form-inline&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-append&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">th:type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;autocomplete&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span>  <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;searchMap.keywords&#125;&quot;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-error input-xxlarge&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-btn btn-xlarge btn-danger&quot;</span> <span class="hljs-attr">th:type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>搜索<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试路径：<a href="http://localhost:9009/sku_search/list?keywords=%E5%8D%8E%E4%B8%BA">http://localhost:9009/sku_search/list?keywords=华为</a></p><p><img src="/images/image-20210805200047392.png" alt="image-20210805200047392"></p><h3 id="4-4-条件搜索实现"><a href="#4-4-条件搜索实现" class="headerlink" title="4.4 条件搜索实现"></a>4.4 条件搜索实现</h3><p><img src="/images/image-20210805200258542.png" alt="image-20210805200258542"></p><p>用户每次点击搜索的时候，其实在上次搜索的基础之上加上了新的搜索条件，也就是在上一次请求的URL后面追加了新的搜索条件，我们可以在后台每次拼接组装出上次搜索的URL，然后每次将URL存入到Model中，页面每次点击不同条件的时候，从Model中取出上次请求的URL，然后再加上新点击的条件参数实现跳转即可。</p><ol><li><p>后台记录搜索URL</p><p>修改SkuController，添加组装URL的方法，并将组装好的URL存储起来,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拼装url</span><br>StringBuilder url = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;/search/list&quot;</span>);<br><span class="hljs-keyword">if</span> (searchMap != <span class="hljs-keyword">null</span> &amp;&amp; searchMap.size()&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//是由查询条件</span><br>    url.append(<span class="hljs-string">&quot;?&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String paramKey : searchMap.keySet()) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;sortRule&quot;</span>.equals(paramKey) &amp;&amp; !<span class="hljs-string">&quot;sortField&quot;</span>.equals(paramKey) &amp;&amp; !<span class="hljs-string">&quot;pageNum&quot;</span>.equals(paramKey))&#123;<br>            url.append(paramKey).append(<span class="hljs-string">&quot;=&quot;</span>).append(searchMap.get(paramKey)).append(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//http://localhost:9009/search/list?keywords=手机&amp;spec_网络制式=4G&amp;</span><br>    String urlString = url.toString();<br>    <span class="hljs-comment">//去除路径上的最后一个&amp;</span><br>    urlString=urlString.substring(<span class="hljs-number">0</span>,urlString.length()-<span class="hljs-number">1</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;url&quot;</span>,urlString);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;url&quot;</span>,url);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>页面搜索对接</p><p>修改品牌部份</p><p><img src="/images/image-20210805201634600.png" alt="image-20210805201634600"></p><p>修改规格部分</p><p><img src="/images/image-20210805202354898.png" alt="image-20210805202354898"></p><p>修改价格部分</p><p><img src="/images/image-20210805202524337.png" alt="image-20210805202524337"></p><p>测试，点击品牌，规格，价格参数后都会自动拼接到url字符串上</p><p><img src="/images/image-20210805203120830.png" alt="image-20210805203120830"></p></li></ol><h3 id="4-5-移除搜索条件"><a href="#4-5-移除搜索条件" class="headerlink" title="4.5 移除搜索条件"></a>4.5 移除搜索条件</h3><p><img src="/images/image-20210805203243750.png" alt="image-20210805203243750"></p><p>如上图，用户点击条件搜索后，要将选中的条件显示出来，并提供移除条件的<code>x</code>按钮,显示条件我们可以从searchMap中获取，移除其实就是将之前的请求地址中的指定条件删除即可。</p><p>修改search.html，移除分类、品牌、价格、规格搜索条件，代码如下：</p><p>只要修改方框里的内容，其实就是把字符串用空串代替</p><p><img src="/images/image-20210805204605803.png" alt="image-20210805204605803"></p><h3 id="4-6-排序"><a href="#4-6-排序" class="headerlink" title="4.6 排序"></a>4.6 排序</h3><p>修改search.html，实现排序，代码如下：</p><p>603行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(sortRule=&#x27;ASC&#x27;,sortField=&#x27;price&#x27;)&#125;&quot;</span>&gt;</span>价格↑<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(sortRule=&#x27;DESC&#x27;,sortField=&#x27;price&#x27;)&#125;&quot;</span>&gt;</span>价格↓<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试: 点击价格，看是否进行排序</p><p><img src="/images/image-20210805205025043.png" alt="image-20210805205025043"></p><h3 id="4-7-分页"><a href="#4-7-分页" class="headerlink" title="4.7 分页"></a>4.7 分页</h3><ol><li><p>分页工具类定义</p><p>在common工程中添加Page分页对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> &lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br><span class="hljs-comment">//当前默认为第一页</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer pageNum = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//默认每页显示条件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer pageSize = <span class="hljs-number">20</span>;<br><br><br><span class="hljs-comment">//判断当前页是否为空或是小于1</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">cpn</span><span class="hljs-params">(Integer pageNum)</span></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == pageNum || pageNum &lt; <span class="hljs-number">1</span>)&#123;<br>pageNum = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> pageNum;<br>&#125;<br><br><br><span class="hljs-comment">// 页数（第几页）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> currentpage;<br><br><span class="hljs-comment">// 查询数据库里面对应的数据有多少条</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> total;<span class="hljs-comment">// 从数据库查处的总记录数</span><br><br><span class="hljs-comment">// 每页显示多少分页标签</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">// 下页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> next;<br><br><span class="hljs-keyword">private</span> List&lt;T&gt; list;<br><br><span class="hljs-comment">// 最后一页</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> last;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lpage;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rpage;<br><br><span class="hljs-comment">//从哪条开始查</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start;<br><br><span class="hljs-comment">//全局偏移量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> offsize = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Page</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br>&#125;<br><br><span class="hljs-comment">/****</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentpage 当前页</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> total 总记录数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pagesize 每页显示多少条</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCurrentpage</span><span class="hljs-params">(<span class="hljs-keyword">long</span> currentpage,<span class="hljs-keyword">long</span> total,<span class="hljs-keyword">long</span> pagesize)</span> </span>&#123;<br><br><span class="hljs-comment">//如果整除表示正好分N页，如果不能整除在N页的基础上+1页</span><br><span class="hljs-keyword">int</span> totalPages = (<span class="hljs-keyword">int</span>) (total%pagesize==<span class="hljs-number">0</span>? total/pagesize : (total/pagesize)+<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//总页数</span><br><span class="hljs-keyword">this</span>.last = totalPages;<br><br><span class="hljs-comment">//判断当前页是否越界,如果越界，我们就查最后一页</span><br><span class="hljs-keyword">if</span>(currentpage&gt;totalPages)&#123;<br><span class="hljs-keyword">this</span>.currentpage = totalPages;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">this</span>.currentpage=currentpage;<br>&#125;<br><br><span class="hljs-comment">//计算起始页</span><br><span class="hljs-keyword">this</span>.start = (<span class="hljs-keyword">this</span>.currentpage-<span class="hljs-number">1</span>)*pagesize;<br>&#125;<br>  <br>  <span class="hljs-comment">/****</span><br><span class="hljs-comment"> * 初始化分页</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> total</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentpage</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pagesize</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initPage</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total,<span class="hljs-keyword">int</span> currentpage,<span class="hljs-keyword">int</span> pagesize)</span></span>&#123;<br><span class="hljs-comment">//总记录数</span><br><span class="hljs-keyword">this</span>.total = total;<br><span class="hljs-comment">//每页显示多少条</span><br><span class="hljs-keyword">this</span>.size=pagesize;<br><br><span class="hljs-comment">//计算当前页和数据库查询起始值以及总页数</span><br>setCurrentpage(currentpage, total, pagesize);<br><br><span class="hljs-comment">//分页计算</span><br><span class="hljs-keyword">int</span> leftcount =<span class="hljs-keyword">this</span>.offsize,<span class="hljs-comment">//需要向上一页执行多少次</span><br>rightcount =<span class="hljs-keyword">this</span>.offsize;<br><br><span class="hljs-comment">//起点页</span><br><span class="hljs-keyword">this</span>.lpage =currentpage;<br><span class="hljs-comment">//结束页</span><br><span class="hljs-keyword">this</span>.rpage =currentpage;<br><br><span class="hljs-comment">//2点判断</span><br><span class="hljs-keyword">this</span>.lpage = currentpage-leftcount;<span class="hljs-comment">//正常情况下的起点</span><br><span class="hljs-keyword">this</span>.rpage = currentpage+rightcount;<span class="hljs-comment">//正常情况下的终点</span><br><br><span class="hljs-comment">//页差=总页数和结束页的差</span><br><span class="hljs-keyword">int</span> topdiv = <span class="hljs-keyword">this</span>.last-rpage;<span class="hljs-comment">//判断是否大于最大页数</span><br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 起点页</span><br><span class="hljs-comment"> * 1、页差&lt;0  起点页=起点页+页差值</span><br><span class="hljs-comment"> * 2、页差&gt;=0 起点和终点判断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">this</span>.lpage=topdiv&lt;<span class="hljs-number">0</span>? <span class="hljs-keyword">this</span>.lpage+topdiv:<span class="hljs-keyword">this</span>.lpage;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 结束页</span><br><span class="hljs-comment"> * 1、起点页&lt;=0   结束页=|起点页|+1</span><br><span class="hljs-comment"> * 2、起点页&gt;0    结束页</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">this</span>.rpage=<span class="hljs-keyword">this</span>.lpage&lt;=<span class="hljs-number">0</span>? <span class="hljs-keyword">this</span>.rpage+(<span class="hljs-keyword">this</span>.lpage*-<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>: <span class="hljs-keyword">this</span>.rpage;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 当起点页&lt;=0  让起点页为第一页</span><br><span class="hljs-comment"> * 否则不管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">this</span>.lpage=<span class="hljs-keyword">this</span>.lpage&lt;=<span class="hljs-number">0</span>? <span class="hljs-number">1</span>:<span class="hljs-keyword">this</span>.lpage;<br><br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 如果结束页&gt;总页数   结束页=总页数</span><br><span class="hljs-comment"> * 否则不管</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">this</span>.rpage=<span class="hljs-keyword">this</span>.rpage&gt;last? <span class="hljs-keyword">this</span>.last:<span class="hljs-keyword">this</span>.rpage;<br>&#125;<br>  <br>  <span class="hljs-comment">/****</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> total   总记录数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentpage当前页</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pagesize每页显示多少条</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Page</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total,<span class="hljs-keyword">int</span> currentpage,<span class="hljs-keyword">int</span> pagesize)</span> </span>&#123;<br>initPage(total,currentpage,pagesize);<br>&#125;<br><br><span class="hljs-comment">//上一页</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getUpper</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> currentpage&gt;<span class="hljs-number">1</span>? currentpage-<span class="hljs-number">1</span>: currentpage;<br>&#125;<br><br><span class="hljs-comment">//总共有多少页，即末页</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.last = (<span class="hljs-keyword">int</span>) (total%size==<span class="hljs-number">0</span>? total/size : (total/size)+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/****</span><br><span class="hljs-comment"> * 带有偏移量设置的分页</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> total</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentpage</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pagesize</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> offsize</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Page</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total,<span class="hljs-keyword">int</span> currentpage,<span class="hljs-keyword">int</span> pagesize,<span class="hljs-keyword">int</span> offsize)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.offsize = offsize;<br>initPage(total, currentpage, pagesize);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span>  currentpage&lt;last? currentpage+<span class="hljs-number">1</span>: last;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> next)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.next = next;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCurrentpage</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> currentpage;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.total = total;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.size = size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLpage</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> lpage;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLpage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lpage)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.lpage = lpage;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getRpage</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rpage;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRpage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rpage)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.rpage = rpage;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getStart</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> start;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStart</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.start = start;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCurrentpage</span><span class="hljs-params">(<span class="hljs-keyword">long</span> currentpage)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.currentpage = currentpage;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the list</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> list the list to set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setList</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.list = list;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//总记录数</span><br><span class="hljs-comment">//当前页</span><br><span class="hljs-comment">//每页显示多少条</span><br><span class="hljs-keyword">int</span> cpage =<span class="hljs-number">17</span>;<br>Page page = <span class="hljs-keyword">new</span> Page(<span class="hljs-number">1001</span>,cpage,<span class="hljs-number">50</span>,<span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;开始页:&quot;</span>+page.getLpage()+<span class="hljs-string">&quot;__当前页：&quot;</span>+page.getCurrentpage()+<span class="hljs-string">&quot;__结束页&quot;</span>+page.getRpage()+<span class="hljs-string">&quot;____总页数：&quot;</span>+page.getLast());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分页实现</p><p>修改SkuController,实现分页信息封装，代码如下：</p><p>添加到拼接url的上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//封装分页数据并返回</span><br><span class="hljs-comment">//1.总记录数</span><br><span class="hljs-comment">//2.当前页</span><br><span class="hljs-comment">//3.每页显示多少条</span><br>Page&lt;SkuInfo&gt; page = <span class="hljs-keyword">new</span> Page&lt;SkuInfo&gt;(<br>        Long.parseLong(String.valueOf( resultMap.get(<span class="hljs-string">&quot;total&quot;</span>))),<br>        Integer.parseInt(String.valueOf(resultMap.get(<span class="hljs-string">&quot;pageNum&quot;</span>))),<br>        Page.pageSize<br>);<br>model.addAttribute(<span class="hljs-string">&quot;page&quot;</span>,page);<br></code></pre></td></tr></table></figure></li><li><p>页面分页实现</p><p>修改search.html，实现分页查询，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fr page&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sui-pagination pagination-large&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;prev disabled&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(pageNum=$&#123;page.upper&#125;)&#125;&quot;</span>&gt;</span>«上一页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;i:$&#123;#numbers.sequence(page.lpage,page.rpage)&#125;&quot;</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;i&#125;==$&#123;page.currentpage&#125;?&#x27;active&#x27;:&#x27;&#x27;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(pageNum=$&#123;i&#125;)&#125;&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;i&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;next&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;$&#123;url&#125;(pageNum=$&#123;page.next&#125;)&#125;&quot;</span>&gt;</span>下一页»<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;page.last&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>页<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>共<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;page.total&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>个商品<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="5-畅购商品详情页"><a href="#5-畅购商品详情页" class="headerlink" title="5. 畅购商品详情页"></a>5. 畅购商品详情页</h2><h3 id="5-1-需求分析"><a href="#5-1-需求分析" class="headerlink" title="5.1 需求分析"></a>5.1 需求分析</h3><p>当系统审核完成商品，需要将商品详情页进行展示，那么采用静态页面生成的方式生成，并部署到高性能的web服务器中进行访问是比较合适的。所以，开发流程如下图所示：</p><p><img src="/images/image-20210805232618788.png" alt="image-20210805232618788"></p><p>此处MQ我们使用Rabbitmq即可。</p><p>执行步骤解释：</p><ul><li>系统管理员（商家运维人员）修改或者审核商品的时候, 会更改数据库中商品上架状态并发送商品id给rabbitMq中的上架交换器</li><li>上架交换器会将商品id发给静态页生成队列</li><li>静态页微服务设置监听器, 监听静态页生成队列, 根据商品id获取商品详细数据并使用thymeleaf的模板技术生成静态页</li></ul><h3 id="5-2-商品静态化微服务创建"><a href="#5-2-商品静态化微服务创建" class="headerlink" title="5.2 商品静态化微服务创建"></a>5.2 商品静态化微服务创建</h3><h4 id="5-2-1-需求分析"><a href="#5-2-1-需求分析" class="headerlink" title="5.2.1 需求分析"></a>5.2.1 需求分析</h4><p>该微服务只用于生成商品静态页，不做其他事情。</p><h4 id="5-2-2-搭建项目"><a href="#5-2-2-搭建项目" class="headerlink" title="5.2.2 搭建项目"></a>5.2.2 搭建项目</h4><ol><li><p>在changgou-service下创建一个名称为changgou_service_page的项目,作为静态化页面生成微服务</p></li><li><p>changgou-service-page中添加起步依赖，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_goods_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改application.yml的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9011</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">page</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#当遇到同样名字的时候，是否允许覆盖注册</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span>   <span class="hljs-comment">#配置全局的feign的调用超时时间  如果 有指定的服务配置 默认的配置不会生效</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">600000</span> <span class="hljs-comment"># 指定的是 消费者 连接服务提供者的连接超时时间 是否能连接  单位是毫秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">600000</span>  <span class="hljs-comment"># 指定的是调用服务提供者的 服务 的超时时间（）  单位是毫秒</span><br><span class="hljs-comment">#hystrix 配置</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">timeout:</span><br>          <span class="hljs-comment">#如果enabled设置为false，则请求超时交给ribbon控制</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">strategy:</span> <span class="hljs-string">SEMAPHORE</span><br><span class="hljs-comment"># 生成静态页的位置</span><br><span class="hljs-attr">pagepath:</span> <span class="hljs-string">D:\items</span><br></code></pre></td></tr></table></figure></li><li><p>创建系统启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.changgou.goods.feign&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(PageApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-生成静态页"><a href="#5-3-生成静态页" class="headerlink" title="5.3 生成静态页"></a>5.3 生成静态页</h3><h4 id="5-3-1-需求分析"><a href="#5-3-1-需求分析" class="headerlink" title="5.3.1 需求分析"></a>5.3.1 需求分析</h4><p>页面发送请求，传递要生成的静态页的商品的SpuID.后台controller 接收请求，调用thyemleaf的原生API生成商品静态页。</p><p><img src="/images/image-20210805233422423.png" alt="image-20210805233422423"></p><p>上图是要生成的商品详情页，从图片上可以看出需要查询SPU的3个分类作为面包屑显示，同时还需要查询SKU和SPU信息。</p><h4 id="5-3-2-Feign创建"><a href="#5-3-2-Feign创建" class="headerlink" title="5.3.2 Feign创建"></a>5.3.2 Feign创建</h4><p>一会儿需要查询SPU和SKU以及Category，所以我们需要先创建Feign，修改changgou-service-goods-api,添加CategoryFeign，并在CategoryFeign中添加根据ID查询分类数据，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;goods&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryFeign</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/category/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在changgou-service-goods-api,添加SkuFeign,并添加根据SpuID查询Sku集合，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;goods&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/sku&quot;)</span>  <span class="hljs-comment">//这个路径拼接到下面方法上也可以</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SkuFeign</span> </span>&#123;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 多条件搜索品牌数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> spuId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/spu/&#123;spuId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sku&gt; <span class="hljs-title">findSkuListBySpuId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;spuId&quot;)</span> String spuId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在changgou-service-goods-api,添加SpuFeign,并添加根据SpuID查询Spu信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;goods&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpuFeign</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/spu/findSpuById/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findSpuById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-3-静态页生成代码"><a href="#5-3-3-静态页生成代码" class="headerlink" title="5.3.3 静态页生成代码"></a>5.3.3 静态页生成代码</h4><ol><li><p>创建PageService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PageService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成静态化页面</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> spuId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateItemPage</span><span class="hljs-params">(String spuId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建PageServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PageService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SpuFeign spuFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CategoryFeign categoryFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SkuFeign skuFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TemplateEngine templateEngine;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;pagepath&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String pagepath;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateItemPage</span><span class="hljs-params">(String spuId)</span> </span>&#123;<br>        <span class="hljs-comment">//获取context对象,用于存放商品详情数据</span><br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        Map&lt;String, Object&gt; itemData = <span class="hljs-keyword">this</span>.findItemData(spuId);<br>        context.setVariables(itemData);<br>        <span class="hljs-comment">//获取商品详情页生成的指定位置</span><br>        File dir = <span class="hljs-keyword">new</span> File(pagepath);<br>        <span class="hljs-comment">//判断商品详情页文件夹是否存在,不存在则创建</span><br>        <span class="hljs-keyword">if</span> (!dir.exists())&#123;<br>            dir.mkdirs();<br>        &#125;<br>        <span class="hljs-comment">//定义输出流,进行文件生成</span><br>        File file = <span class="hljs-keyword">new</span> File(dir+<span class="hljs-string">&quot;/&quot;</span>+spuId+<span class="hljs-string">&quot;.html&quot;</span>);<br>        Writer out = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            out = <span class="hljs-keyword">new</span> PrintWriter(file);<br>            <span class="hljs-comment">//生成文件</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 1.模板名称</span><br><span class="hljs-comment">             * 2.context对象,包含了模板需要的数据</span><br><span class="hljs-comment">             * 3.输出流,指定文件输出位置</span><br><span class="hljs-comment">             */</span><br>            templateEngine.process(<span class="hljs-string">&quot;item&quot;</span>,context,out);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭流</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                out.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//获取静态化页面数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; <span class="hljs-title">findItemData</span><span class="hljs-params">(String spuId)</span> </span>&#123;<br><br>        Map&lt;String,Object&gt; resultMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">//获取spu信息</span><br>        Result&lt;Spu&gt; spuResult = spuFeign.findSpuById(spuId);<br>        Spu spu = spuResult.getData();<br>        resultMap.put(<span class="hljs-string">&quot;spu&quot;</span>,spu);<br><br>        <span class="hljs-comment">//获取图片信息</span><br>        <span class="hljs-keyword">if</span> (spu != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(spu.getImages()))&#123;<br>                resultMap.put(<span class="hljs-string">&quot;imageList&quot;</span>,spu.getImages().split(<span class="hljs-string">&quot;,&quot;</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//获取分类信息</span><br>        Category category1 = (Category) categoryFeign.findById(spu.getCategory1Id()).getData();<br>        resultMap.put(<span class="hljs-string">&quot;category1&quot;</span>,category1);<br>        Category category2 = (Category) categoryFeign.findById(spu.getCategory2Id()).getData();<br>        resultMap.put(<span class="hljs-string">&quot;category2&quot;</span>,category2);<br>        Category category3 = (Category) categoryFeign.findById(spu.getCategory3Id()).getData();<br>        resultMap.put(<span class="hljs-string">&quot;category3&quot;</span>,category3);<br>        <span class="hljs-comment">//获取sku集合信息</span><br>        List&lt;Sku&gt; skuList = skuFeign.findSkuListBySpuId(spuId);<br>        resultMap.put(<span class="hljs-string">&quot;skuList&quot;</span>,skuList);<br><br>        resultMap.put(<span class="hljs-string">&quot;specificationList&quot;</span>, JSON.parseObject(spu.getSpecItems(), Map.class));<br>        <span class="hljs-keyword">return</span> resultMap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明page_create_queue队列,并绑定到商品上架交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_UP_EXCHANGE=<span class="hljs-string">&quot;goods_up_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_DOWN_EXCHANGE=<span class="hljs-string">&quot;goods_down_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//定义队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD_UPDATE_QUEUE=<span class="hljs-string">&quot;ad_update_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_ADD_QUEUE=<span class="hljs-string">&quot;search_add_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_DEL_QUEUE=<span class="hljs-string">&quot;search_del_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PAGE_CREATE_QUEUE=<span class="hljs-string">&quot;page_create_queue&quot;</span>;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(AD_UPDATE_QUEUE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(SEARCH_ADD_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_ADD_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_ADD_QUEUE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(SEARCH_DEL_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_DEL_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_DEL_QUEUE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(PAGE_CREATE_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">PAGE_CREATE_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(PAGE_CREATE_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(GOODS_UP_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_UP_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_UP_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(GOODS_DOWN_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_DOWN_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_DOWN_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br><br>    <span class="hljs-comment">//队列与交换机的绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">GOODS_UP_EXCHANGE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_ADD_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_UP_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">PAGE_CREATE_QUEUE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(PAGE_CREATE_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_UP_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">GOODS_DOWN_EXCHANGE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_DEL_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_DOWN_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建PageListener监听类,监听page_create_queue队列,获取消息,并生成静态化页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PageService pageService;<br><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.PAGE_CREATE_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String spuId)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;生成商品详情页面,商品id为: &quot;</span>+spuId);<br>        <span class="hljs-comment">//生成静态化页面</span><br>        pageService.generateItemPage(spuId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更新canal中消息队列配置类与Page服务一致</p></li><li><p>更新canal中对于spu表的监听类,当商品审核状态从0变1,则将当前spuId发送到消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取最新审核商品</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;0&quot;</span>.equals(oldData.get(<span class="hljs-string">&quot;status&quot;</span>)) &amp;&amp; <span class="hljs-string">&quot;1&quot;</span>.equals(newData.get(<span class="hljs-string">&quot;status&quot;</span>)))&#123;<br>  <span class="hljs-comment">//发送商品spuId</span><br>  rabbitTemplate.convertAndSend(RabbitMQConfig.GOODS_UP_EXCHANGE,<span class="hljs-string">&quot;&quot;</span>,newData.get(<span class="hljs-string">&quot;id&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>最后记得把list.html拷贝到templates包下</p><h4 id="5-3-4-启动测试"><a href="#5-3-4-启动测试" class="headerlink" title="5.3.4 启动测试"></a>5.3.4 启动测试</h4><p>启动eurekea服务端,数据监控服务,商品服务,静态页生成服务. 将spu表中status字段从0更新为1。在生成的items目录下会看到新增的页面，把css, img等那些静态资源放到与items同级的包下，可以看到，点开页面可以看到下图</p><p><img src="/images/image-20210806141505171.png" alt="image-20210806141505171"></p><h4 id="5-3-5-基于nginx完成静态页访问"><a href="#5-3-5-基于nginx完成静态页访问" class="headerlink" title="5.3.5 基于nginx完成静态页访问"></a>5.3.5 基于nginx完成静态页访问</h4><p>用FileZilla连接到服务器（这里就是我们的虚拟机）</p><p><img src="/images/image-20210806142622109.png" alt="image-20210806142622109"></p><p>把生成的html页面复制到服务器端的html包下</p><p><img src="/images/image-20210806142913422.png" alt="image-20210806142913422"></p><p>然后重启服务器端的nginx</p><p>输入请求路径（端口改为http协议默认端口80了）：<a href="http://192.168.200.128/10000001516600.html">http://192.168.200.128/10000001516600.html</a></p><p>可以发现，通过访问远端服务器也可以访问到图片了</p><p><img src="/images/image-20210806143130888.png" alt="image-20210806143130888"></p>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第二部分</title>
    <link href="/2021/07/26/1.2%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/26/1.2%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-04-商品管理"><a href="#Part-04-商品管理" class="headerlink" title="Part-04 商品管理"></a>Part-04 商品管理</h1><h2 id="1-分布式ID生成解决方案"><a href="#1-分布式ID生成解决方案" class="headerlink" title="1. 分布式ID生成解决方案"></a>1. 分布式<strong>ID</strong>生成解决方案</h2><p>数据太多导致数据库单表性能下降，需要对数据库进行分库分表、数据库多实例部署等，如果此时这张表还按照主键自增，因为已经不在一个机器上了，这种方式会使主键重复。为了避免ID重复，因此需要分布式ID</p><h3 id="1-1-分布式ID生成解决方案"><a href="#1-1-分布式ID生成解决方案" class="headerlink" title="1.1 分布式ID生成解决方案"></a>1.1 分布式<strong>ID</strong>生成解决方案</h3><p>UUID, Redis, 开源算法<strong>snowflake</strong> 都可以实现分布式ID。这里主要讲下开源算法<strong>snowflake</strong> ，其他的如果用到去网上搜博客深入学习。</p><h4 id="1-1-1-开源算法snowflake"><a href="#1-1-1-开源算法snowflake" class="headerlink" title="1.1.1 开源算法snowflake"></a>1.1.1 开源算法<strong>snowflake</strong></h4><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型（8字节，64位）的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0</p><img src="/images/image-20210728121416974.png" alt="image-20210728121416974" style="zoom:80%;" /><p>快速入门</p><ol><li><p>新建工程，将资料/工具类下的IdWorker.java拷贝到工程中 （这个工具类会用就行了，需要深入学习时再细看）</p></li><li><p>编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">snowFlakeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IdWorker idWorker = <span class="hljs-keyword">new</span> IdWorker(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) &#123;<br>            <span class="hljs-keyword">long</span> id = idWorker.nextId();<br>            System.out.println(id);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="1-1-2-配置分布式ID生成器"><a href="#1-1-2-配置分布式ID生成器" class="headerlink" title="1.1.2 配置分布式ID生成器"></a>1.1.2 配置分布式<strong>ID</strong>生成器</h4><ol><li><p>IdWorker.java拷贝到changgou_common工程com.changgou.util包中 （放到common包是因为微服务都要用到他。如果把这个类部署到微服务会很麻烦，要一个一个部署）</p></li><li><p>changgou_service_goods的application.yml添加配置 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">workerId:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">datacenterId:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>修改GoodsApplication, 增加代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;workerId&#125;&quot;)</span><br>   <span class="hljs-keyword">private</span> Integer workerId;<br>   <br>   <span class="hljs-meta">@Value(&quot;$&#123;datacenterId&#125;&quot;)</span><br>   <span class="hljs-keyword">private</span> Integer  datacenterId;<br>   <br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> IdWorker <span class="hljs-title">idWorker</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IdWorker(workerId,datacenterId);<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-新增和修改商品"><a href="#2-新增和修改商品" class="headerlink" title="2. 新增和修改商品"></a>2. 新增和修改商品</h2><h3 id="2-1-概念与表结构分析"><a href="#2-1-概念与表结构分析" class="headerlink" title="2.1 概念与表结构分析"></a><strong>2.1</strong> 概念与表结构分析</h3><h4 id="2-1-1-SPU与SKU概念"><a href="#2-1-1-SPU与SKU概念" class="headerlink" title="2.1.1 SPU与SKU概念"></a><strong>2.1.1 SPU</strong>与<strong>SKU</strong>概念</h4><p><strong>SPU = Standard Product Unit （标准产品单位）</strong> </p><ul><li><p>概念 : SPU 是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。 </p></li><li><p>通俗点讲，属性值、特性相同的货品就可以称为一个 SPU</p><p>例如：华为<strong>P30</strong> 就是一个 <strong>SPU</strong> </p></li></ul><p><strong>SKU=stock keeping unit ( 库存量单位)</strong></p><ul><li><p>SKU 即库存进出计量的单位， 可以是以件、盒、托盘等为单位。</p></li><li><p>SKU 是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。</p><p>例如：华为<strong>P30</strong> 红色 <strong>64G</strong> 就是一个 <strong>SKU</strong></p></li></ul><h4 id="2-1-2-表结构分析"><a href="#2-1-2-表结构分析" class="headerlink" title="2.1.2 表结构分析"></a><strong>2.1.2</strong> 表结构分析</h4><p>tb_spu 表 （SPU表）</p><table><thead><tr><th>字段名称</th><th>字段含义</th><th>字段类型</th><th>字段长度</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>主键</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>sn</td><td>货号</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>name</td><td>SPU名</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>caption</td><td>副标题</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>brand_id</td><td>品牌ID</td><td>INT</td><td></td><td></td></tr><tr><td>category1_id</td><td>一级分类</td><td>INT</td><td></td><td></td></tr><tr><td>category2_id</td><td>二级分类</td><td>INT</td><td></td><td></td></tr><tr><td>category3_id</td><td>三级分类</td><td>INT</td><td></td><td></td></tr><tr><td>template_id</td><td>模板ID</td><td>INT</td><td></td><td></td></tr><tr><td>freight_id</td><td>运费模板id</td><td>INT</td><td></td><td></td></tr><tr><td>image</td><td>图片</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>images</td><td>图片列表</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>sale_service</td><td>售后服务</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>introduction</td><td>介绍</td><td>TEXT</td><td></td><td></td></tr><tr><td>spec_items</td><td>规格列表</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>para_items</td><td>参数列表</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>sale_num</td><td>销量</td><td>INT</td><td></td><td></td></tr><tr><td>comment_num</td><td>评论数</td><td>INT</td><td></td><td></td></tr><tr><td>is_marketable</td><td>是否上架</td><td>CHAR</td><td></td><td></td></tr><tr><td>is_enable_spec</td><td>是否启用规格</td><td>CHAR</td><td></td><td></td></tr><tr><td>is_delete</td><td>是否删除</td><td>CHAR</td><td></td><td></td></tr><tr><td>status</td><td>审核状态</td><td>CHAR</td><td></td><td></td></tr></tbody></table><p>tb_sku 表（SKU商品表）</p><table><thead><tr><th>字段名称</th><th>字段含义</th><th>字段类型</th><th>字段长度</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>商品id</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>sn</td><td>商品条码</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>name</td><td>SKU名称</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>price</td><td>价格（分）</td><td>INT</td><td></td><td></td></tr><tr><td>num</td><td>库存数量</td><td>INT</td><td></td><td></td></tr><tr><td>alert_num</td><td>库存预警数量</td><td>INT</td><td></td><td></td></tr><tr><td>image</td><td>商品图片</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>images</td><td>商品图片列表</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>weight</td><td>重量（克）</td><td>INT</td><td></td><td></td></tr><tr><td>create_time</td><td>创建时间</td><td>DATETIME</td><td></td><td></td></tr><tr><td>update_time</td><td>更新时间</td><td>DATETIME</td><td></td><td></td></tr><tr><td>spu_id</td><td>SPUID</td><td>BIGINT</td><td></td><td></td></tr><tr><td>category_id</td><td>类目ID</td><td>INT</td><td></td><td></td></tr><tr><td>category_name</td><td>类目名称</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>brand_name</td><td>品牌名称</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>spec</td><td>规格</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>sale_num</td><td>销量</td><td>INT</td><td></td><td></td></tr><tr><td>comment_num</td><td>评论数</td><td>INT</td><td></td><td></td></tr><tr><td>status</td><td>商品状态 1-正常，2-下架，3-删除</td><td>CHAR</td><td></td><td></td></tr></tbody></table><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a><strong>2.2</strong> 代码实现</h3><h4 id="2-2-1-SPU与SKU列表的保存"><a href="#2-2-1-SPU与SKU列表的保存" class="headerlink" title="2.2.1 SPU与SKU列表的保存"></a>2.2.1 <strong>SPU</strong>与<strong>SKU</strong>列表的保存</h4><ol><li><p>changgou_service_goods_api工程的pojo包中创建组合实体类Goods </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> Spu spu;<br>    <span class="hljs-keyword">private</span> List&lt;Sku&gt; skuList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Spu <span class="hljs-title">getSpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> spu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpu</span><span class="hljs-params">(Spu spu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.spu = spu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sku&gt; <span class="hljs-title">getSkuList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> skuList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkuList</span><span class="hljs-params">(List&lt;Sku&gt; skuList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.skuList = skuList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods工程SpuService新增方法add(Goods goods) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment">    * 新增</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Goods goods)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods工程SpuServiceImpl实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> CategoryMapper categoryMapper;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> SkuMapper skuMapper;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> BrandMapper brandMapper;<br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> IdWorker idWorker;<br>   <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 增加</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Transactional</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Goods goods)</span></span>&#123;<br>   <br>       Spu spu = goods.getSpu();<br>       <span class="hljs-keyword">long</span> spuId = idWorker.nextId();<br>       spu.setId(String.valueOf(spuId));<br>       spu.setIsDelete(<span class="hljs-string">&quot;0&quot;</span>);<br>       spu.setIsMarketable(<span class="hljs-string">&quot;0&quot;</span>);<br>       spu.setStatus(<span class="hljs-string">&quot;0&quot;</span>);<br>       spuMapper.insertSelective(spu);<br>   <br>       saveSkuList(goods);<br>   &#125;<br>   <br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 保存sku列表。</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 这里单独加一个方法是因为这个操作步骤较多</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveSkuList</span><span class="hljs-params">(Goods goods)</span> </span>&#123;<br>       <span class="hljs-comment">//获取spu对象</span><br>       Spu spu = goods.getSpu();<br>       <span class="hljs-comment">//获取当前日期</span><br>       Date date = <span class="hljs-keyword">new</span> Date();<br>       <span class="hljs-comment">//获取品牌对象</span><br>       Brand brand = brandMapper.selectByPrimaryKey(spu.getBrandId());<br>       <span class="hljs-comment">//获取分类对象</span><br>       Category category = categoryMapper.selectByPrimaryKey(spu.getCategory3Id());<br>       <span class="hljs-comment">//获取sku集合对象</span><br>       List&lt;Sku&gt; skuList = goods.getSkuList();<br>   <br>       <span class="hljs-keyword">if</span>(skuList != <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-comment">//小技巧： 直接打 iter 可以快速出来下面的遍历代码</span><br>           <span class="hljs-keyword">for</span> (Sku sku : skuList) &#123;<br>               <span class="hljs-comment">//设置sku主键ID</span><br>               sku.setId(String.valueOf(idWorker.nextId()));<br>               <span class="hljs-comment">//设置sku规格</span><br>               <span class="hljs-keyword">if</span>(sku.getSpec() == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(sku.getSpec()))&#123;<br>                   sku.setSpec(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>               &#125;<br>               <span class="hljs-comment">//设置sku名称(商品名称 + 规格)</span><br>               String name = spu.getName();<br>               <span class="hljs-comment">//将规格json字符串转换成Map</span><br>               Map&lt;String, String&gt; specMap = JSON.parseObject(sku.getSpec(), Map.class);<br>               <span class="hljs-keyword">if</span> (specMap != <span class="hljs-keyword">null</span> &amp;&amp; specMap.size() &gt;<span class="hljs-number">0</span>)&#123;<br>                   <span class="hljs-keyword">for</span> (String value : specMap.values()) &#123;<br>                       name += <span class="hljs-string">&quot; &quot;</span>+value;<br>                   &#125;<br>               &#125;<br>   <br>               sku.setName(name);<span class="hljs-comment">//名称</span><br>               sku.setSpuId(spu.getId());<span class="hljs-comment">//设置spu的ID</span><br>               sku.setCreateTime(date);<span class="hljs-comment">//创建日期</span><br>               sku.setUpdateTime(date);<span class="hljs-comment">//修改日期</span><br>               sku.setCategoryId(category.getId());<span class="hljs-comment">//商品分类ID</span><br>               sku.setCategoryName(category.getName());<span class="hljs-comment">//商品分类名称</span><br>               sku.setBrandName(brand.getName());<span class="hljs-comment">//品牌名称</span><br>               skuMapper.insertSelective(sku);<span class="hljs-comment">//插入sku表数据</span><br>           &#125;<br>       &#125;<br>   <br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>修改SpuController的add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment">    * 新增数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Goods goods)</span></span>&#123;<br>       spuService.add(goods);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;添加成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-2-品牌与分类关联"><a href="#2-2-2-品牌与分类关联" class="headerlink" title="2.2.2 品牌与分类关联"></a>2.2.2 品牌与分类关联</h4><p>将分类ID与SPU的品牌ID 一起插入到tb_category_brand表中</p><ol><li><p>创建实体类</p><p>注意：</p><ul><li>这个表是联合主键，所以categoryId和brandId都有@Id注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Table(name=&quot;tb_category_brand&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoryBrand</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Integer categoryId;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Integer brandId;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getCategoryId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> categoryId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCategoryId</span><span class="hljs-params">(Integer categoryId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.categoryId = categoryId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBrandId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brandId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBrandId</span><span class="hljs-params">(Integer brandId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brandId = brandId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建数据访问接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryBrandMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">CategoryBrand</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CategoryBrandMapper categoryBrandMapper;<br></code></pre></td></tr></table></figure></li><li><p>修改SpuServiceImpl的saveSkuList方法，添加分类与品牌之间的关联, 修改后代码如下:</p><p>注意：</p><ul><li>在原基础上添加的部分在两个<code>=</code>之间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 保存sku列表。</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveSkuList</span><span class="hljs-params">(Goods goods)</span> </span>&#123;<br>       <span class="hljs-comment">//获取spu对象</span><br>       Spu spu = goods.getSpu();<br>       <span class="hljs-comment">//获取当前日期</span><br>       Date date = <span class="hljs-keyword">new</span> Date();<br>       <span class="hljs-comment">//获取品牌对象</span><br>       Brand brand = brandMapper.selectByPrimaryKey(spu.getBrandId());<br>       <span class="hljs-comment">//获取分类对象</span><br>       Category category = categoryMapper.selectByPrimaryKey(spu.getCategory3Id());<br>   <br>       <span class="hljs-comment">// =========================================</span><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 添加分类与品牌之间的关联</span><br><span class="hljs-comment">        */</span><br>       CategoryBrand categoryBrand = <span class="hljs-keyword">new</span> CategoryBrand();<br>       categoryBrand.setBrandId(spu.getBrandId());<br>       categoryBrand.setCategoryId(spu.getCategory3Id());<br>       <span class="hljs-keyword">int</span> count = categoryBrandMapper.selectCount(categoryBrand);<br>       <span class="hljs-comment">//判断是否有这个品牌和分类的关系数据</span><br>       <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//如果没有关系数据则添加品牌和分类关系数据</span><br>           categoryBrandMapper.insert(categoryBrand);<br>       &#125;<br>       <span class="hljs-comment">// =========================================</span><br>       <br>       <span class="hljs-comment">//获取sku集合对象</span><br>       List&lt;Sku&gt; skuList = goods.getSkuList();<br>   <br>       <span class="hljs-keyword">if</span>(skuList != <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-comment">//小技巧： 直接打 iter 可以快速出来下面的遍历代码</span><br>           <span class="hljs-keyword">for</span> (Sku sku : skuList) &#123;<br>               <span class="hljs-comment">//设置sku主键ID</span><br>               sku.setId(String.valueOf(idWorker.nextId()));<br>               <span class="hljs-comment">//设置sku规格</span><br>               <span class="hljs-keyword">if</span>(sku.getSpec() == <span class="hljs-keyword">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(sku.getSpec()))&#123;<br>                   sku.setSpec(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>);<br>               &#125;<br>               <span class="hljs-comment">//设置sku名称(商品名称 + 规格)</span><br>               String name = spu.getName();<br>               <span class="hljs-comment">//将规格json字符串转换成Map</span><br>               Map&lt;String, String&gt; specMap = JSON.parseObject(sku.getSpec(), Map.class);<br>               <span class="hljs-keyword">if</span> (specMap != <span class="hljs-keyword">null</span> &amp;&amp; specMap.size() &gt;<span class="hljs-number">0</span>)&#123;<br>                   <span class="hljs-keyword">for</span> (String value : specMap.values()) &#123;<br>                       name += <span class="hljs-string">&quot; &quot;</span>+value;<br>                   &#125;<br>               &#125;<br>   <br>               sku.setName(name);<span class="hljs-comment">//名称</span><br>               sku.setSpuId(spu.getId());<span class="hljs-comment">//设置spu的ID</span><br>               sku.setCreateTime(date);<span class="hljs-comment">//创建日期</span><br>               sku.setUpdateTime(date);<span class="hljs-comment">//修改日期</span><br>               sku.setCategoryId(category.getId());<span class="hljs-comment">//商品分类ID</span><br>               sku.setCategoryName(category.getName());<span class="hljs-comment">//商品分类名称</span><br>               sku.setBrandName(brand.getName());<span class="hljs-comment">//品牌名称</span><br>               skuMapper.insertSelective(sku);<span class="hljs-comment">//插入sku表数据</span><br>           &#125;<br>       &#125;<br>   <br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-3-根据ID查询商品"><a href="#2-2-3-根据ID查询商品" class="headerlink" title="2.2.3 根据ID查询商品"></a>2.2.3 根据ID查询商品</h4><p>需求：根据id 查询SPU和SKU列表 , 结果以goods对象返回</p><p>代码实现：</p><ol><li><p>changgou_service_goods工程SpuService新增方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据ID查询商品</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function">Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods工程SpuServiceImpl实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Goods <span class="hljs-title">findGoodsById</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    <span class="hljs-comment">//查询spu</span><br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-comment">//查询SKU 列表</span><br>    Example example = <span class="hljs-keyword">new</span> Example(Sku.class);<br>    Example.Criteria criteria = example.createCriteria();<br>    criteria.andEqualTo(<span class="hljs-string">&quot;spuId&quot;</span>, id);<br>    List&lt;Sku&gt; skuList = skuMapper.selectByExample(example);<br>   <br>    <span class="hljs-comment">//封装，返回</span><br>    Goods goods = <span class="hljs-keyword">new</span> Goods();<br>    goods.setSpu(spu);<br>    goods.setSkuList(skuList);<br>    <span class="hljs-keyword">return</span> goods;<br>&#125;<br>   <br></code></pre></td></tr></table></figure></li><li><p>修改SpuController的findById方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    Goods goods = spuService.findGoodsById(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;查询成功&quot;</span>,goods);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-4-保存修改"><a href="#2-2-4-保存修改" class="headerlink" title="2.2.4 保存修改"></a>2.2.4 保存修改</h4><ol><li><p>changgou_service_goods工程SpuService新增方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Goods goods)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods工程SpuServiceImpl实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Goods goods)</span> </span>&#123;<br>       <span class="hljs-comment">//取出spu部分</span><br>       Spu spu = goods.getSpu();<br>       spuMapper.updateByPrimaryKey(spu);<br>   <br>       <span class="hljs-comment">//删除原sku列表</span><br>       Example example = <span class="hljs-keyword">new</span> Example(Sku.class);<br>       Example.Criteria criteria = example.createCriteria();<br>       criteria.andEqualTo(<span class="hljs-string">&quot;spuId&quot;</span>, spu.getId());<br>       skuMapper.deleteByExample(example);<br>   <br>       <span class="hljs-comment">//保存sku列表</span><br>       saveSkuList(goods);<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>修改SpuController的update方法</p><p>注意：</p><ul><li><code>&#123;id&#125;</code>是把请求路径中对应部分的字符串赋值给id, 并不是要在请求路径中拼接 <code>？id=string</code>这种写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment">    * 修改数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> goods</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping(value=&quot;/&#123;id&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Goods goods,<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>       spuService.update(goods);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;修改成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-商品审核与上下架"><a href="#3-商品审核与上下架" class="headerlink" title="3. 商品审核与上下架"></a>3. 商品审核与上下架</h2><p>需求分析：</p><ul><li>商品新增后，审核状态为0（未审核），默认为下架状态(也为0)</li><li>审核商品，需要校验是否是被删除的商品，如果未删除则修改审核状态为1，并自动上架</li><li>下架商品，需要校验是否是被删除的商品，如果未删除则修改上架状态为0</li><li>上架商品，需要审核状态为1,如果为1,则更改上下架状态为1</li></ul><p>实现思路：</p><ul><li>按照ID查询SPU信息</li><li>判断修改审核、上架下架状态</li><li>保存Spu</li></ul><h3 id="3-1-代码实现"><a href="#3-1-代码实现" class="headerlink" title="3.1 代码实现"></a>3.1 代码实现</h3><h4 id="3-1-1-商品审核"><a href="#3-1-1-商品审核" class="headerlink" title="3.1.1 商品审核"></a>3.1.1 商品审核</h4><p>需要校验是否是被删除的商品，如果未删除则修改审核状态为1，并自动上架</p><ol><li><p>SpuService新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 审核</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audit</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl实现方法</p><p>注意： </p><ul><li>开启<code>@Transactional</code>事务注解(对于要修改数据库的操作，都加上事务注解)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">audit</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    <span class="hljs-comment">//查询spu对象</span><br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-keyword">if</span>(spu == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前商品不存在&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">//判断当前spu是否处于删除状态</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;1&quot;</span>.equals(spu.getIsDelete()))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前商品处于删除状态&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">//不处于删除状态,修改审核状态为1,上下架状态为1</span><br>    spu.setStatus(<span class="hljs-string">&quot;1&quot;</span>);<br>    spu.setIsMarketable(<span class="hljs-string">&quot;1&quot;</span>);<br>   <br>    <span class="hljs-comment">//执行修改操作</span><br>    spuMapper.updateByPrimaryKeySelective(spu);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/audit/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">audit</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    spuService.audit(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;商品审核成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-1-2-下架商品"><a href="#3-1-2-下架商品" class="headerlink" title="3.1.2 下架商品"></a>3.1.2 下架商品</h4><p>校验是否是被删除的商品，如果未删除则修改上架状态为0</p><ol><li><p>SpuService新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下架商品</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pull</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pull</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    <span class="hljs-comment">//查询spu</span><br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-keyword">if</span> (spu == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前商品不存在&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">//判断当前商品是否处于删除状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;1&quot;</span>.equals(spu.getIsDelete()))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前商品处于删除状态&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-comment">//商品处于未删除状态的话,则修改上下架状态为已下架(0)</span><br>    spu.setIsMarketable(<span class="hljs-string">&quot;0&quot;</span>);<br>    spuMapper.updateByPrimaryKeySelective(spu);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/pull/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">pull</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    spuService.pull(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;商品下架成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-1-3-上架商品"><a href="#3-1-3-上架商品" class="headerlink" title="3.1.3 上架商品"></a>3.1.3 上架商品</h4><p>必须是通过审核的商品才能上架</p><ol><li><p>SpuService新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上架商品</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl 实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上架商品</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-keyword">if</span>(!spu.getStatus().equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;未通过审核的商品不能上架！&quot;</span>);<br>    &#125;<br>    spu.setIsMarketable(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//上架状态</span><br>    spuMapper.updateByPrimaryKeySelective(spu);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 上架</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/put/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    spuService.put(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-删除与还原商品"><a href="#4-删除与还原商品" class="headerlink" title="4. 删除与还原商品"></a>4. 删除与还原商品</h2><p>需求分析：</p><ul><li>商品列表中的删除商品功能，并非真正的删除(物理删除)，而是采用逻辑删除将删除标记的字段设置为1.</li><li>在回收站中有还原商品的功能，将删除标记的字段设置为0</li><li>在回收站中有删除商品的功能，是真正的物理删除,将数据从数据库中删除掉。</li></ul><p>实现思路：</p><ul><li>商品列表中的删除商品,执行逻辑删除，修改spu表is_delete字段为1</li><li>商品回收站中的还原商品,修改spu表is_delete字段为0</li><li>商品回收站中的删除商品,执行delete操作,进行物理删除</li></ul><h3 id="4-1-代码实现"><a href="#4-1-代码实现" class="headerlink" title="4.1 代码实现"></a>4.1 代码实现</h3><h4 id="4-1-1-逻辑删除商品"><a href="#4-1-1-逻辑删除商品" class="headerlink" title="4.1.1 逻辑删除商品"></a>4.1.1 逻辑删除商品</h4><ol><li><p>修改SpuServiceImpl的delete方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 删除</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String id)</span></span>&#123;<br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-comment">//检查是否下架的商品</span><br>    <span class="hljs-keyword">if</span>(!spu.getIsMarketable().equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;必须先下架再删除！&quot;</span>);<br>    &#125;<br>    spu.setIsDelete(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//删除</span><br>    spu.setStatus(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//未审核</span><br>    spuMapper.updateByPrimaryKeySelective(spu);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-1-2-还原被删除的商品"><a href="#4-1-2-还原被删除的商品" class="headerlink" title="4.1.2 还原被删除的商品"></a>4.1.2 还原被删除的商品</h4><ol><li><p>SpuService新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恢复数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恢复数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-comment">//检查是否删除的商品</span><br>    <span class="hljs-keyword">if</span>(!spu.getIsDelete().equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;此商品未删除！&quot;</span>);<br>    &#125;<br>    spu.setIsDelete(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//未删除</span><br>    spu.setStatus(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//未审核</span><br>    spuMapper.updateByPrimaryKeySelective(spu);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恢复数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/restore/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">restore</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>    spuService.restore(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;还原成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-1-3-物理删除商品"><a href="#4-1-3-物理删除商品" class="headerlink" title="4.1.3 物理删除商品"></a>4.1.3 物理删除商品</h4><p>判断必须逻辑删除商品才能物理删除</p><ol><li><p>SpuService 新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 物理删除</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">realDelete</span><span class="hljs-params">(String id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>SpuServiceImpl 实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realDelete</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    Spu spu = spuMapper.selectByPrimaryKey(id);<br>    <span class="hljs-comment">//检查是否删除的商品</span><br>    <span class="hljs-keyword">if</span>(!spu.getIsDelete().equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;此商品未删除！&quot;</span>);<br>    &#125;<br>    spuMapper.deleteByPrimaryKey(id);<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>SpuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 物理删除</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@DeleteMapping(&quot;/realDelete/&#123;id&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">realDelete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>&#123;<br>       spuService.realDelete(id);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;物理删除成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Part-05-网站首页高可用nginx-lua"><a href="#Part-05-网站首页高可用nginx-lua" class="headerlink" title="Part-05 网站首页高可用nginx+lua"></a>Part-05 网站首页高可用nginx+lua</h1><h2 id="1-Lua"><a href="#1-Lua" class="headerlink" title="1. Lua"></a>1. Lua</h2><h3 id="1-1-Lua介绍"><a href="#1-1-Lua介绍" class="headerlink" title="1.1 Lua介绍"></a>1.1 Lua介绍</h3><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。（如果想要了解他的详细背景去搜对应资料）</p><p><strong>lua 语言具有以下特性</strong>：（还不是很能理解，慢慢理解）</p><ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul><p><strong>应用场景</strong></p><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li><li>redis中嵌套调用实现类似事务的功能</li><li>web容器中应用处理一些过滤 缓存等等的逻辑，例如nginx。</li></ul><h3 id="1-2-lua的安装"><a href="#1-2-lua的安装" class="headerlink" title="1.2 lua的安装"></a>1.2 lua的安装</h3><p>这里省略，有需要去搜具体博客或者本地笔记查看</p><h3 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h3><p>开启和关闭(ctrl + c)lua命令行交互</p><p><img src="/images/image-20210729135124466-1629279323872.png" alt="image-20210729135124466"></p><p>创建hello.lua文件，执行语句：</p><p><img src="/images/image-20210729134904915-1629279323872.png" alt="image-20210729134904915"></p><h3 id="1-4-LUA的基本语法"><a href="#1-4-LUA的基本语法" class="headerlink" title="1.4 LUA的基本语法"></a>1.4 LUA的基本语法</h3><ul><li>lua有交互式编程和脚本式编程。一般采用脚本式编程。</li></ul><h4 id="1-4-1-注释"><a href="#1-4-1-注释" class="headerlink" title="1.4.1 注释"></a>1.4.1 注释</h4><p>单行注释：两个减号是单行注释:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p>多行注释：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment"> 多行注释</span><br><span class="hljs-comment"> 多行注释</span><br><span class="hljs-comment"> --]]</span><br></code></pre></td></tr></table></figure><h4 id="1-4-2-关键字"><a href="#1-4-2-关键字" class="headerlink" title="1.4.2 关键字"></a>1.4.2 关键字</h4><p>lua的关键字如下：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>and</td><td>break</td><td>do</td><td>else</td></tr><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-4-3-定义变量"><a href="#1-4-3-定义变量" class="headerlink" title="1.4.3 定义变量"></a>1.4.3 定义变量</h4><p>全局变量，默认的情况下，定义一个变量都是全局变量，</p><p>如果要用局部变量 需要声明为local.例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 全局变量赋值</span><br>a=<span class="hljs-number">1</span><br><span class="hljs-comment">-- 局部变量赋值</span><br><span class="hljs-keyword">local</span> b=<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p>如果变量没有初始化：则 它的值为nil</p><h4 id="1-4-4-Lua中的数据类型"><a href="#1-4-4-Lua中的数据类型" class="headerlink" title="1.4.4 Lua中的数据类型"></a>1.4.4 Lua中的数据类型</h4><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><h4 id="1-4-5-流程控制"><a href="#1-4-5-流程控制" class="headerlink" title="1.4.5 流程控制"></a>1.4.5 流程控制</h4><p>如下：类似于if else </p><p>注意：</p><ul><li>以<code>end</code>结束</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[ 0 为 true ]</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0 为 true&quot;</span>)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0 不为true&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="1-4-6-函数"><a href="#1-4-6-函数" class="headerlink" title="1.4.6 函数"></a>1.4.6 函数</h4><p>lua中也可以定义函数。例如：</p><p>注意：</p><ul><li>函数也是以<code>end</code>结束</li><li>稍微注意下他的字符串拼接方式</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[ 函数返回两个值的最大值 --]]</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2)</span></span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) <span class="hljs-keyword">then</span><br>      result = num1;<br>   <span class="hljs-keyword">else</span><br>      result = num2;<br>   <span class="hljs-keyword">end</span><br><br>   <span class="hljs-keyword">return</span> result; <br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 调用函数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两值比较最大值为 &quot;</span>,<span class="hljs-built_in">max</span>(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两值比较最大值为 &quot;</span>,<span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><p>执行之后的结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">两值比较最大值为     <span class="hljs-number">10</span><br>两值比较最大值为     <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="1-4-7-require-函数"><a href="#1-4-7-require-函数" class="headerlink" title="1.4.7 require 函数"></a>1.4.7 require 函数</h4><p>require 用于 引入其他的模块，类似于java中的类要引用别的类的效果。</p><p>用法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;&lt;模块名&gt;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-nginx-lua-redis实现广告缓存"><a href="#2-nginx-lua-redis实现广告缓存" class="headerlink" title="2. nginx+lua+redis实现广告缓存"></a>2. nginx+lua+redis实现广告缓存</h2><p>需求分析：</p><ul><li>需要在首页页面不同位置处显示相应的广告</li></ul><h3 id="2-1-nginx"><a href="#2-1-nginx" class="headerlink" title="2.1 nginx"></a>2.1 nginx</h3><p>负载均衡功能</p><img src="/images/image-20210729153602339.png" alt="image-20210729153602339" style="zoom: 80%;" /><p>反向代理功能</p><img src="/images/image-20210729153737126.png" alt="image-20210729153737126" style="zoom:80%;" /><p>http服务器功能</p><img src="/images/image-20210729153818568.png" alt="image-20210729153818568" style="zoom:80%;" /><h3 id="2-2-OpenResty"><a href="#2-2-OpenResty" class="headerlink" title="2.2 OpenResty"></a>2.2 OpenResty</h3><h4 id="2-2-1-OpenResty介绍"><a href="#2-2-1-OpenResty介绍" class="headerlink" title="2.2.1 OpenResty介绍"></a>2.2.1 OpenResty介绍</h4><p>OpenResty(又称：ngx_openresty) 是一个基于 NGINX 的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。</p><p>OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以 快速构造出足以胜任 10K 乃至1000K以上并发连接响应的超高性能 Web 应用系统。</p><p>360，UPYUN，阿里云，新浪，腾讯网，去哪儿网，酷狗音乐等都是 OpenResty 的深度用户。</p><p>OpenResty 简单理解，就相当于封装了nginx,并且集成了LUA脚本，开发人员只需要简单的为其提供模块就可以实现相关的逻辑，而不再像之前，还需要在nginx中自己编写lua的脚本，再进行调用了。</p><h3 id="2-2-2-OpenResty安装"><a href="#2-2-2-OpenResty安装" class="headerlink" title="2.2.2 OpenResty安装"></a>2.2.2 OpenResty安装</h3><p>具体见本地讲义</p><h4 id="2-2-3-安装nginx"><a href="#2-2-3-安装nginx" class="headerlink" title="2.2.3 安装nginx"></a>2.2.3 安装nginx</h4><p>默认已经安装好了nginx,在目录：/usr/local/openresty/nginx 下。</p><p>修改/usr/local/openresty/nginx/conf/nginx.conf ,将配置文件使用的根设置为root,目的就是将来要使用lua脚本的时候 ，直接可以加载在root下的lua脚本。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#user nobody; 配置文件第一行原来为这样, 现改为下面的配置</span><br><span class="hljs-keyword">user</span> <span class="hljs-title">root</span> root;<br></code></pre></td></tr></table></figure><p>测试访问 <a href="http://192.168.200.128/">http://192.168.200.128</a></p><img src="/images/image-20210729154301413.png" alt="image-20210729154301413" style="zoom: 67%;" /><h3 id="2-3-实现思路"><a href="#2-3-实现思路" class="headerlink" title="2.3 实现思路"></a>2.3 实现思路</h3><h4 id="2-3-1-表结构分析"><a href="#2-3-1-表结构分析" class="headerlink" title="2.3.1 表结构分析"></a>2.3.1 表结构分析</h4><p>tb_ad （广告表）</p><table><thead><tr><th>字段名称</th><th>字段含义</th><th>字段类型</th><th>字段长度</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>ID</td><td>INT</td><td></td><td></td></tr><tr><td>name</td><td>广告名称</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>position</td><td>广告位置</td><td>VARCHAR</td><td></td><td>系统定义</td></tr><tr><td>start_time</td><td>开始时间</td><td>DATETIME</td><td></td><td></td></tr><tr><td>end_time</td><td>到期时间</td><td>DATETIME</td><td></td><td></td></tr><tr><td>status</td><td>状态</td><td>CHAR</td><td></td><td>0：无效 1:有效</td></tr><tr><td>image</td><td>图片地址</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>url</td><td>URL</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>remarks</td><td>备注</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>web_index_lb</td><td>首页轮播图</td><td></td><td></td><td></td></tr><tr><td>web_index_amusing</td><td>有趣区</td><td></td><td></td><td></td></tr><tr><td>web_index_ea_lb</td><td>家用电器楼层轮播图</td><td></td><td></td><td></td></tr><tr><td>web_index_ea</td><td>家用电器楼层广告</td><td></td><td></td><td></td></tr><tr><td>web_index_mobile_lb</td><td>手机通讯楼层轮播图</td><td></td><td></td><td></td></tr><tr><td>web_index_mobile</td><td>手机通讯楼层广告</td><td></td><td></td><td></td></tr></tbody></table><h4 id="2-3-2-缓存预热与二级缓存查询"><a href="#2-3-2-缓存预热与二级缓存查询" class="headerlink" title="2.3.2 缓存预热与二级缓存查询"></a>2.3.2 缓存预热与二级缓存查询</h4><ol><li><p>编写lua脚本实现缓存预热（将mysql里的数据查询出来存入redis）</p><img src="/images/image-20210729154726183.png" alt="image-20210729154726183" style="zoom:80%;" /></li><li><p>编写lua脚本实现二级缓存读取</p><img src="/images/image-20210729154821590.png" alt="image-20210729154821590" style="zoom:80%;" /><p>就是说客户端查询的时候先查询本地缓存</p></li></ol><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><h4 id="2-4-1-缓存预热"><a href="#2-4-1-缓存预热" class="headerlink" title="2.4.1 缓存预热"></a>2.4.1 缓存预热</h4><p>实现思路：</p><p>定义请求：用于查询数据库中的数据更新到redis中。</p><ol><li>连接mysql ，按照广告分类ID读取广告列表，转换为json字符串</li><li>连接redis，将广告列表json字符串存入redis</li></ol><p>定义请求：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">请求：<br>    /ad_update<br>参数：<br>    position  <span class="hljs-comment">--指定广告位置</span><br>返回值：<br>    <span class="hljs-type">json</span><br></code></pre></td></tr></table></figure><p>在/root/lua目录下创建ad_load.lua ，实现连接mysql 查询数据 并存储到redis中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua">ngx.header.content_type=<span class="hljs-string">&quot;application/json;charset=utf8&quot;</span> <span class="hljs-comment">-- 表明内容以json数据进行传递</span><br><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cjson&quot;</span>) <span class="hljs-comment">-- 引入第三方模块，表明支持json</span><br><span class="hljs-keyword">local</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.mysql&quot;</span>) <span class="hljs-comment">-- 引入mysql支持</span><br><span class="hljs-keyword">local</span> uri_args = ngx.req.get_uri_args() <span class="hljs-comment">-- 获取当前请求路径上的参数赋值给uri_args</span><br><span class="hljs-keyword">local</span> position = uri_args[<span class="hljs-string">&quot;position&quot;</span>]  <span class="hljs-comment">-- 获取请求参数中的position的值</span><br><br><span class="hljs-keyword">local</span> db = mysql:new() <span class="hljs-comment">-- 设置一个新的mysql连接</span><br>db:set_timeout(<span class="hljs-number">1000</span>)  <span class="hljs-comment">-- 设置数据库连接的超时时间</span><br><span class="hljs-keyword">local</span> props = &#123;    <span class="hljs-comment">-- 设置要连接的数据库服务器的参数信息</span><br>    host = <span class="hljs-string">&quot;192.168.200.128&quot;</span>,  <br>    port = <span class="hljs-number">3306</span>,  <br>    database = <span class="hljs-string">&quot;changgou_business&quot;</span>,  <br>    user = <span class="hljs-string">&quot;root&quot;</span>,  <br>    password = <span class="hljs-string">&quot;root&quot;</span>  <br>&#125;<br><br><span class="hljs-keyword">local</span> res = db:connect(props)  <span class="hljs-comment">-- 基于上面的参数进行真正的连接</span><br><span class="hljs-keyword">local</span> select_sql = <span class="hljs-string">&quot;select url,image from tb_ad where status =&#x27;1&#x27; and position=&#x27;&quot;</span>..position..<span class="hljs-string">&quot;&#x27; and start_time&lt;= NOW() AND end_time&gt;= NOW()&quot;</span>  <span class="hljs-comment">-- 定义sql语句</span><br>res = db:query(select_sql)  <span class="hljs-comment">-- 执行连接到mysql以后要执行的sql语句</span><br>db:<span class="hljs-built_in">close</span>()  <span class="hljs-comment">-- 关闭数据库的连接</span><br><br><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.redis&quot;</span>) <span class="hljs-comment">-- 引入redis第三方面模块</span><br><span class="hljs-keyword">local</span> red = redis:new() <span class="hljs-comment">-- 设置redis的连接</span><br>red:set_timeout(<span class="hljs-number">2000</span>)  <span class="hljs-comment">-- 设置redis的连接超时时间</span><br><br><span class="hljs-keyword">local</span> ip =<span class="hljs-string">&quot;192.168.200.128&quot;</span>  <span class="hljs-comment">-- 设置redis服务器的ip地址</span><br><span class="hljs-keyword">local</span> port = <span class="hljs-number">6379</span>  <span class="hljs-comment">-- 设置redis服务器的端口号</span><br>red:connect(ip,port) <span class="hljs-comment">-- 开启真正的redis连接</span><br><br>red:set(<span class="hljs-string">&quot;ad_&quot;</span>..position,cjson.encode(res))  <span class="hljs-comment">-- 设置向redis中存放的内容</span><br>red:<span class="hljs-built_in">close</span>() <span class="hljs-comment">-- 关闭连接</span><br><br>ngx.say(<span class="hljs-string">&quot;&#123;flag:true&#125;&quot;</span>)  <span class="hljs-comment">-- 响应给客户端的字符串信息</span><br></code></pre></td></tr></table></figure><p>修改/usr/local/openresty/nginx/conf/nginx.conf文件，代码如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">user</span> root root;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br>        <span class="hljs-comment"># 添加</span><br>        <span class="hljs-attribute">location</span> /ad_update &#123; <span class="hljs-comment"># 这个路径映射到下面这个本地ad_update.lua文件</span><br>            <span class="hljs-attribute">content_by_lua_file</span> /root/lua/ad_update.lua;<br>        &#125;<br>        <br>        <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新启动nginx   (<code>./nginx -s reload</code>)</p><p>测试：<a href="http://192.168.200.128/ad_update?position=web_index_lb">http://192.168.200.128/ad_update?position=web_index_lb</a>   （我这一步没报错，但是数据没输进去，这个bug先放这儿，后面熟悉了再慢慢解决）</p><h4 id="广告缓存读取"><a href="#广告缓存读取" class="headerlink" title="广告缓存读取"></a>广告缓存读取</h4><p>实现思路：</p><ul><li>通过lua脚本直接从redis中获取数据即可。</li></ul><p>定义请求：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">请求<span class="hljs-symbol">:/ad_read</span><br>参数：position<br>返回值：json<br></code></pre></td></tr></table></figure><p>在/root/lua目录下创建ad_read.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua">ngx.header.content_type=<span class="hljs-string">&quot;application/json;charset=utf8&quot;</span><br><br><span class="hljs-keyword">local</span> uri_args = ngx.req.get_uri_args();<br><span class="hljs-keyword">local</span> position = uri_args[<span class="hljs-string">&quot;position&quot;</span>];<br><br><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.redis&quot;</span>);<br><br><span class="hljs-keyword">local</span> red = redis:new()<br><br>red:set_timeout(<span class="hljs-number">2000</span>)<br><br><span class="hljs-keyword">local</span> ok, err = red:connect(<span class="hljs-string">&quot;192.168.200.128&quot;</span>, <span class="hljs-number">6379</span>)<br><br><span class="hljs-keyword">local</span> rescontent=red:get(<span class="hljs-string">&quot;ad_&quot;</span>..position)<br><br>ngx.say(rescontent)<br><br>red:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p>在/usr/local/openresty/nginx/conf/nginx.conf中server下添加配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /ad_read &#123;<br>  <span class="hljs-attribute">content_by_lua_file</span> /root/lua/ad_read.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试 <a href="http://192.168.200.128/ad_read?position=web_index_lb">http://192.168.200.128/ad_read?position=web_index_lb</a> 输出</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;img\/banner1.jpg&quot;</span>,<span class="hljs-attr">&quot;image&quot;</span>:<span class="hljs-string">&quot;img\/banner1.jpg&quot;</span>&#125;,&#123;<span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;img\/banner2.jpg&quot;</span>,<span class="hljs-attr">&quot;image&quot;</span>:<span class="hljs-string">&quot;img\/banner2.jpg&quot;</span>&#125;]<br></code></pre></td></tr></table></figure><h4 id="2-4-3-二级缓存-加入openresty本地缓存"><a href="#2-4-3-二级缓存-加入openresty本地缓存" class="headerlink" title="2.4.3 二级缓存-加入openresty本地缓存"></a>2.4.3 二级缓存-加入openresty本地缓存</h4><p>如上的方式没有问题，但是如果请求都到redis，redis压力也很大，所以我们一般采用多级缓存的方式来减少下游系统的服务压力</p><p>先查询openresty本地缓存 如果没有再查询redis中的数据<br>修改/root/lua目录下ad_read文件, 内容如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--设置响应头类型</span><br>ngx.header.content_type=<span class="hljs-string">&quot;application/json;charset=utf8&quot;</span><br><span class="hljs-comment">--获取请求中的参数ID</span><br><span class="hljs-keyword">local</span> uri_args = ngx.req.get_uri_args();<br><span class="hljs-keyword">local</span> position = uri_args[<span class="hljs-string">&quot;position&quot;</span>];<br><br><span class="hljs-comment">--获取本地缓存</span><br><span class="hljs-keyword">local</span> cache_ngx = ngx.shared.dis_cache;<br><span class="hljs-comment">--根据ID 获取本地缓存数据</span><br><span class="hljs-keyword">local</span> adCache = cache_ngx:get(<span class="hljs-string">&#x27;ad_cache_&#x27;</span>..position);<br><br><span class="hljs-keyword">if</span> adCache == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">or</span> adCache == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><br><span class="hljs-comment">--引入redis库</span><br><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.redis&quot;</span>);<br><span class="hljs-comment">--创建redis对象</span><br><span class="hljs-keyword">local</span> red = redis:new()<br><span class="hljs-comment">--设置超时时间</span><br>red:set_timeout(<span class="hljs-number">2000</span>)<br><span class="hljs-comment">--连接</span><br><span class="hljs-keyword">local</span> ok, err = red:connect(<span class="hljs-string">&quot;192.168.200.128&quot;</span>, <span class="hljs-number">6379</span>)<br><span class="hljs-comment">--获取key的值</span><br><span class="hljs-keyword">local</span> rescontent=red:get(<span class="hljs-string">&quot;ad_&quot;</span>..position)<br><span class="hljs-comment">--输出到返回响应中</span><br>ngx.say(rescontent)<br><span class="hljs-comment">--关闭连接</span><br>red:<span class="hljs-built_in">close</span>()<br><span class="hljs-comment">--将redis中获取到的数据存入nginx本地缓存</span><br>cache_ngx:set(<span class="hljs-string">&#x27;ad_cache_&#x27;</span>..position, rescontent, <span class="hljs-number">10</span>*<span class="hljs-number">60</span>);<br><br><span class="hljs-keyword">else</span><br> <span class="hljs-comment">--nginx本地缓存中获取到数据直接输出</span><br> ngx.say(adCache)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>修改nginx配置文件vi /usr/local/openresty/nginx/conf/nginx.conf ，http节点下添加配置:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#包含redis初始化模块</span><br><span class="hljs-attribute">lua_shared_dict</span> dis_cache <span class="hljs-number">5m</span>;  <span class="hljs-comment">#共享内存开启</span><br></code></pre></td></tr></table></figure><h4 id="2-4-4-前端页面实现（了解）"><a href="#2-4-4-前端页面实现（了解）" class="headerlink" title="2.4.4 前端页面实现（了解）"></a>2.4.4 前端页面实现（了解）</h4><p>这里先不学，有需要再说。</p><p>待更改完成后用FileZilla连接服务器（在这里就是那台linux虚拟机）</p><p><img src="images/image-20210729213014273-1629279323872.png" alt="image-20210729213014273"></p><p>连接成功后，把本地的前端页面以及其样式设置的文件和文件夹全部都拷贝到服务器上nginx目录下的html文件夹中</p><p><img src="images/image-20210729213222244-1629279323872.png" alt="image-20210729213222244"></p><p>最后更改nginx.conf的配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 加载首页</span><br>      <span class="hljs-attribute">location</span> / &#123;<br>          <span class="hljs-attribute">root</span>   html;  <span class="hljs-comment"># 表明页面文件都部署在html文件夹下</span><br>          <span class="hljs-attribute">index</span>  index.html index.htm;  <span class="hljs-comment"># 表明location对应的主页页面</span><br>      &#125;<br></code></pre></td></tr></table></figure><p>配置完成后重启nginx即可</p><p>最后根据首页的<code>location</code>, 在浏览器输入 192.168.200.128 即可完成访问。<code>location</code>的<code>/</code>在地址栏可输也可不输入。看到主页的广告图出现，说明设置成功。</p><h2 id="3-nginx限流"><a href="#3-nginx限流" class="headerlink" title="3 nginx限流"></a>3 nginx限流</h2><p>一般情况下，首页的并发量是比较大的，即使有了多级缓存，如果有大量恶意的请求，也会对系统造成影响。而限流就是保护措施之一。</p><p>nginx提供两种限流的方式：</p><ul><li>一是控制速率</li><li>二是控制并发连接数</li></ul><h3 id="3-1-控制速率"><a href="#3-1-控制速率" class="headerlink" title="3.1 控制速率"></a>3.1 控制速率</h3><p>控制速率的方式之一就是采用漏桶算法</p><h4 id="3-1-1-漏桶算法实现控制速率限流"><a href="#3-1-1-漏桶算法实现控制速率限流" class="headerlink" title="3.1.1 漏桶算法实现控制速率限流"></a>3.1.1 漏桶算法实现控制速率限流</h4><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.</p><p>漏桶算法实现 nginx的配置：</p><ul><li><p>修改/usr/local/openresty/nginx/conf/nginx.conf:</p><p>注意：</p><ul><li><p>被<code>#</code>包裹的设置这个算法的地方</p></li><li><p>binary_remote_addr 是一种key，表示基于 remote_addr(客户端IP) 来做限流，binary_ 的目的是压缩内存占用量 </p></li><li><p>zone：定义共享内存区来存储访问信息， myRateLimit:10m 表示一个大小为10M，名字为myRateLimit的内存区域。1M能存储16000 IP地址的访问信息，10M可以存储16W IP地址访问信息。</p></li><li><p>rate 用于设置最大访问速率，rate=10r/s 表示每秒最多处理10个请求。我们这里设置成2 方便测试。</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">user</span> root root;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br>    <span class="hljs-comment">##############################</span><br>    <span class="hljs-attribute">limit_req_zone</span> $binary_remote_addr zone=myRateLimit:<span class="hljs-number">10m</span> rate=2r/s;<br><span class="hljs-comment">###############################</span><br>    <span class="hljs-section">server</span> &#123;  <br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-comment">##########################</span><br>            <span class="hljs-attribute">limit_req</span> zone=myRateLimit;<br>            <span class="hljs-comment">##########################</span><br>            <span class="hljs-attribute">root</span>   html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：重新加载配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/openresty/</span>nginx/sbin<br><br>./nginx -s reload<br></code></pre></td></tr></table></figure><p>快速点击，会报错</p><p><img src="/images/image-20210729220115898-1629279323872.png" alt="image-20210729220115898"></p></li></ul><h4 id="3-1-2-处理突发流量"><a href="#3-1-2-处理突发流量" class="headerlink" title="3.1.2 处理突发流量"></a>3.1.2 处理突发流量</h4><p>上面例子限制 2r/s，如果有时正常流量突然增大，超出的请求将被拒绝，无法处理突发流量，可以结合 <strong>burst</strong> 参数使用来解决该问题。</p><p>例如，如下配置表示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">limit_req</span> zone=myRateLimit burst=<span class="hljs-number">5</span>;<br>        <span class="hljs-attribute">root</span>   html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>burst 译为突发、爆发，表示在超过设定的处理速率后能额外处理的请求数,当 rate=2r/s 时，将1s拆成2份，即每500ms可处理1个请求。</p><p>此处，<strong>burst=5</strong> ，若同时有6个请求到达，Nginx 会处理第一个请求，剩余5个请求将放入队列，然后每隔500ms从队列中获取一个请求进行处理。若请求数大于6，将拒绝处理多余的请求，直接返回503.</p><p>不过，单独使用 burst 参数并不实用。假设 burst=50 ，rate为10r/s，排队中的50个请求虽然每100ms会处理一个，但第50个请求却需要等待 50 * 100ms即 5s，这么长的处理时间自然难以接受。</p><p>因此，burst 往往结合 nodelay 一起使用。</p><p>例如：如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">limit_req</span> zone=myRateLimit burst=<span class="hljs-number">5</span> nodelay;<br>        <span class="hljs-attribute">root</span>   html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上表示：</p><p>处理突发5个请求的时候，没有延迟，等到完成之后，按照正常的速率处理。</p><p>如上两种配置结合就达到了速率稳定，但突然流量也能正常处理的效果。配置代码如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">user</span> root root;<br><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment"># 设置限流配置</span><br>    <span class="hljs-attribute">limit_req_zone</span> $binary_remote_addr zone=myRateLimit:<span class="hljs-number">10m</span> rate=2r/s;<br><br>    <span class="hljs-section">server</span> &#123;  <br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">8081</span>;<br>        <span class="hljs-attribute">server_name</span>  localhost;<br>        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">limit_req</span> zone=myRateLimit burst = <span class="hljs-number">5</span> nodelay;<br>            <span class="hljs-attribute">root</span>   html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成以后记得重启nginx （改配置文件需要重启，其他时候不用重启）</p><p>测试：在1秒钟之内可以刷新5次，正常处理。</p><p>但超过之后会报错</p><h1 id="Part-06-数据同步解决方案-canal"><a href="#Part-06-数据同步解决方案-canal" class="headerlink" title="Part-06 数据同步解决方案-canal"></a>Part-06 数据同步解决方案-canal</h1><h2 id="1-canal"><a href="#1-canal" class="headerlink" title="1. canal"></a>1. canal</h2><h3 id="1-1-canal简介"><a href="#1-1-canal简介" class="headerlink" title="1.1 canal简介"></a>1.1 canal简介</h3><p>canal可以用来监控数据库数据的变化，从而获得新增数据，或者修改的数据。</p><p>canal是应对阿里巴巴存在杭州和美国的双机房部署，存在跨机房同步的业务需求而提出的。</p><p>阿里系公司开始逐步的尝试基于数据库的日志解析，获取增量变更进行同步，由此衍生出了增量订阅&amp;消费的业务。</p><img src="/images/image-20210730122738581.png" alt="image-20210730122738581" style="zoom:80%;" /><p>原理相对比较简单：(这里不是太理解)</p><ol><li>canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议</li><li>mysql master收到dump请求，开始推送binary log给slave(也就是canal)</li><li>canal解析binary log对象(原始为byte流)</li></ol><h3 id="1-2-环境部署"><a href="#1-2-环境部署" class="headerlink" title="1.2 环境部署"></a>1.2 环境部署</h3><h4 id="1-2-1-mysql开启binlog模式"><a href="#1-2-1-mysql开启binlog模式" class="headerlink" title="1.2.1 mysql开启binlog模式"></a>1.2.1 mysql开启binlog模式</h4><p>​    这部分看具体博客或者本地笔记</p><h4 id="1-2-2-canal服务端安装配置"><a href="#1-2-2-canal服务端安装配置" class="headerlink" title="1.2.2 canal服务端安装配置"></a>1.2.2 canal服务端安装配置</h4><p>​    这部分看具体博客或者本地笔记都可</p><h3 id="1-3-数据监控微服务"><a href="#1-3-数据监控微服务" class="headerlink" title="1.3 数据监控微服务"></a>1.3 数据监控微服务</h3><p>当用户执行数据库的操作的时候，binlog 日志会被canal捕获到，并解析出数据。我们就可以将解析出来的数据进行相应的逻辑处理。</p><p>我们这里使用的一个开源的项目，它实现了springboot与canal的集成。比原生的canal更加优雅。springboot 没有这个包，需要自己下载并部署到本地仓库</p><ol><li><p>打开网址 <a href="https://github.com/chenqian56131/spring-boot-starter-canal">https://github.com/chenqian56131/spring-boot-starter-canal</a> 下载 spring-boot-starter-canal。（下载到本地的磁盘位置可随便选）</p></li><li><p>下载完成后解压，并打开文件夹到有pom.xml文件的那一级</p><img src="/images/image-20210730125655100.png" alt="image-20210730125655100" style="zoom:80%;" /></li><li><p>在此处输入mvn命令</p><p>注意：</p><ul><li>DskipTests 表明安装的时候跳过测试</li></ul><p><img src="/images/image-20210730125838140-1629279323872.png" alt="image-20210730125838140"></p></li><li><p>BUILD SUCCESS以后可以在本地的maven仓库看到一个xpand包</p><p><img src="/images/image-20210730130053149-1629279323872.png" alt="image-20210730130053149"></p></li></ol><h4 id="1-3-1-微服务搭建"><a href="#1-3-1-微服务搭建" class="headerlink" title="1.3.1 微服务搭建"></a>1.3.1 微服务搭建</h4><ol><li><p>创建工程模块changgou_canal，pom引入依赖</p><p>注意：</p><ul><li>上面那个包就是刚刚下载到本地的包，不然这里会报红</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xpand<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>starter-canal<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建包com.changgou.canal ，包下创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCanalClient</span> <span class="hljs-comment">//声明当前的服务是canal的客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanalApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(CanalApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加配置文件application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">canal.client.instances.example.host</span>=<span class="hljs-string">192.168.200.128</span><br><span class="hljs-meta">canal.client.instances.example.port</span>=<span class="hljs-string">11111</span><br><span class="hljs-meta">canal.client.instances.example.batchSize</span>=<span class="hljs-string">1000  # 这里不知道是什么意思</span><br><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.200.128</span><br></code></pre></td></tr></table></figure></li><li><p>创建com.changgou.canal.listener包，包下创建类</p><p>注意：</p><ul><li><code>@CanalEventListener</code>: 声明当前的类是canal的监听类</li><li><code>@ListenPoint(schema = &quot;changgou_business&quot;, table = &quot;tb_ad&quot;)</code>表明监听的是数据库changgou_business中的tb_ad表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CanalEventListener</span> <span class="hljs-comment">//声明当前的类是canal的监听类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessListener</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@ListenPoint(schema = &quot;changgou_business&quot;, table = &quot;tb_ad&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adUpdate</span><span class="hljs-params">(CanalEntry.EventType eventType, CanalEntry.RowData rowData)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;广告表数据发生改变&quot;</span>);<br>        <span class="hljs-comment">//获取改变之前的数据</span><br>        rowData.getBeforeColumnsList().forEach((c)-&gt; System.out.println(<span class="hljs-string">&quot;改变前的数据:&quot;</span>+c.getName()+<span class="hljs-string">&quot;::&quot;</span>+c.getValue()));<br>        System.out.println(<span class="hljs-string">&quot;===================&quot;</span>);<br>        <span class="hljs-comment">//获取改变之后的数据</span><br>        rowData.getAfterColumnsList().forEach((c) -&gt; System.out.println(<span class="hljs-string">&quot;改变之后的数据:&quot;</span>+c.getName()+<span class="hljs-string">&quot;::&quot;</span>+c.getValue())); <span class="hljs-comment">// 获取改变后的那一行的所有字段名和数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：启动数据监控微服务，修改changgou_business的tb_ad表，观察控制台输出</p></li></ol><h2 id="2-首页广告缓存更新"><a href="#2-首页广告缓存更新" class="headerlink" title="2. 首页广告缓存更新"></a>2. 首页广告缓存更新</h2><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>当tb_ad（广告）表的数据发生变化时，更新redis中的广告数据</p><h3 id="2-2-实现思路"><a href="#2-2-实现思路" class="headerlink" title="2.2 实现思路"></a>2.2 实现思路</h3><ol><li><p>修改数据监控微服务，监控tb_ad表，当发生增删改操作时，提取position值（广告位置key），发送到rabbitmq</p></li><li><p>从rabbitmq中提取消息，通过OkHttpClient调用ad_update来实现对广告缓存数据的更新。</p><img src="/images/image-20210730193803227.png" alt="image-20210730193803227" style="zoom:80%;" /></li></ol><p>这个图要理解</p><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><h4 id="2-3-1-发送消息到mq"><a href="#2-3-1-发送消息到mq" class="headerlink" title="2.3.1 发送消息到mq"></a>2.3.1 发送消息到mq</h4><ol><li>在rabbitmq管理后台创建队列 ad_update_queue ，用于接收广告更新通知</li></ol><img src="/images/image-20210730194058801.png" alt="image-20210730194058801" style="zoom:80%;" /><ol start="2"><li><p>引入rabbitmq起步依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件application.properties 添加内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.200.128</span><br></code></pre></td></tr></table></figure></li><li><p>新增rabbitMQ配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD_UPDATE_QUEUE=<span class="hljs-string">&quot;ad_update_queue&quot;</span>;<br>   <br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(AD_UPDATE_QUEUE);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改BusinessListener类</p><p>注意：</p><ul><li><code>@CanalEventListener</code>表明当前的类是canal的监听类</li><li><code>@ListenPoint(schema = &quot;changgou_business&quot;, table = &quot;tb_ad&quot;)</code>表明监听是哪一个数据库中的哪张表</li><li>关于<code>CanalEntry</code>具体的实现细节先不深入</li><li>RabbitMQ与springboot结合的用法还不熟</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CanalEventListener</span> <span class="hljs-comment">//声明当前的类是canal的监听类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessListener</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@ListenPoint(schema = &quot;changgou_business&quot;, table = &quot;tb_ad&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adUpdate</span><span class="hljs-params">(CanalEntry.EventType eventType, CanalEntry.RowData rowData)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;广告表数据发生改变&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (CanalEntry.Column column : rowData.getAfterColumnsList()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;position&quot;</span>.equals(column.getName()))&#123;<br>                System.out.println(<span class="hljs-string">&quot;发送最新的数据到MQ:&quot;</span>+column.getValue());<br><br>                <span class="hljs-comment">//发送消息</span><br>                rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;&quot;</span>, RabbitMQConfig.AD_UPDATE_QUEUE, column.getValue());<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-2-从mq中提取消息执行更新"><a href="#2-3-2-从mq中提取消息执行更新" class="headerlink" title="2.3.2 从mq中提取消息执行更新"></a>2.3.2 从mq中提取消息执行更新</h4><ol><li><p>changgou_service_business工程pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--消息队列依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在spring节点下添加rabbitmq配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">rabbitmq:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br></code></pre></td></tr></table></figure></li><li><p>com.changgou.business包下创建listener包，包下创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;ad_update_queue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到的消息为:&quot;</span>+message);<br><br>        <span class="hljs-comment">//发起远程调用</span><br>        OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient();<br>        String url = <span class="hljs-string">&quot;http://192.168.200.128/ad_update?position=&quot;</span>+message;<br>        Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).build();<br>        Call call = okHttpClient.newCall(request);<br>        call.enqueue(<span class="hljs-keyword">new</span> Callback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>&#123;<br>                <span class="hljs-comment">//请求失败</span><br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-comment">//请求成功</span><br>                System.out.println(<span class="hljs-string">&quot;请求成功:&quot;</span>+response.message());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，启动business微服务(前面已经启动了eureka, canal的微服务。不然达不成效果)，观察控制台输出和数据同步效果</p></li></ol><h2 id="3-商品上架索引库导入数据"><a href="#3-商品上架索引库导入数据" class="headerlink" title="3. 商品上架索引库导入数据"></a>3. 商品上架索引库导入数据</h2><h3 id="3-1-需求分析"><a href="#3-1-需求分析" class="headerlink" title="3.1 需求分析"></a>3.1 需求分析</h3><p>商品上架将商品的sku列表导入或更新索引库。</p><h3 id="3-2-实现思路"><a href="#3-2-实现思路" class="headerlink" title="3.2 实现思路"></a>3.2 实现思路</h3><ol><li><p>在数据监控微服务中监控tb_spu表的数据，当tb_spu发生更改且is_marketable为1时，表示商品上架，将spu的id发送到rabbitmq。</p></li><li><p>在rabbitmq管理后台创建商品上架交换器（fanout）。使用分列模式的交换器是考虑商品上架会有很多种逻辑需要处理，导入索引库只是其中一项，另外还有商品详细页静态化等操作。这样我们可以创建导入索引库的队列和商品详细页静态化队列并与商品上架交换器进行绑定。</p></li><li><p>搜索微服务从rabbitmq的导入索引库的队列中提取spu的id，通过feign调用商品微服务得到sku的列表，并且通过调用elasticsearch的高级restAPI 将sku列表导入到索引库。</p><p><img src="/images/image-20210803144338107-1629279323872.png" alt="image-20210803144338107"></p></li></ol><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><h4 id="3-3-1-发送消息到mq"><a href="#3-3-1-发送消息到mq" class="headerlink" title="3.3.1 发送消息到mq"></a>3.3.1 发送消息到mq</h4><ol><li><p>在rabbitmq后台创建交换器goods_up_exchange（类型为fanout），创建队列search_add_queue绑定交换器goods_up_exchange,更新rabbitmq配置类</p><p>注意：</p><ul><li><code>@Bean(SEARCH_ADD_QUEUE)</code>是用来声明这个方法返回的bean的名称，便于后面的绑定zhu入。</li><li><code>@Qualifier(SEARCH_ADD_QUEUE)</code>：qualifier注解是按照名称来注入引用类型的bean的，而autowire是按照bean的类型来注入的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_UP_EXCHANGE=<span class="hljs-string">&quot;goods_up_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//定义队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_ADD_QUEUE=<span class="hljs-string">&quot;search_add_queue&quot;</span>;<br><br>    <span class="hljs-comment">//大小写转换快捷键：CTRL+SHIFT+U</span><br>    <span class="hljs-comment">//定义队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD_UPDATE_QUEUE = <span class="hljs-string">&quot;ad_update_queue&quot;</span>;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(AD_UPDATE_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean(SEARCH_ADD_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_ADD_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_ADD_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(GOODS_UP_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_UP_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_UP_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-comment">//队列绑定交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">SEARCH_ADD_QUEUE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_ADD_QUEUE)</span> Queue queue, <span class="hljs-meta">@Qualifier(GOODS_UP_EXCHANGE)</span> Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数据监控微服务新增SpuListener，添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CanalEventListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpuListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@ListenPoint(schema = &quot;changgou_goods&quot;, table = &quot;tb_spu&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodsUp</span><span class="hljs-params">(CanalEntry.EventType eventType, CanalEntry.RowData rowData)</span></span>&#123;<br>        <span class="hljs-comment">//获取改变之前的数据并将这部分数据转换为map</span><br>        Map&lt;String, String&gt; oldData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        rowData.getBeforeColumnsList().forEach((c)-&gt;oldData.put(c.getName(), c.getValue()));<br><br>        <span class="hljs-comment">//获取改变之后的数据并这部分数据转换为map</span><br>        Map&lt;String,String&gt; newData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        rowData.getAfterColumnsList().forEach((c)-&gt;newData.put(c.getName(),c.getValue()));<br><br>        <span class="hljs-comment">//获取最新上架的商品 0-&gt;1</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;0&quot;</span>.equals(oldData.get(<span class="hljs-string">&quot;is_marketable&quot;</span>)) &amp;&amp; <span class="hljs-string">&quot;1&quot;</span>.equals(newData.get(<span class="hljs-string">&quot;is_marketable&quot;</span>)))&#123;<br>            <span class="hljs-comment">//将商品的spuid发送到mq</span><br>            rabbitTemplate.convertAndSend(RabbitMQConfig.GOODS_UP_EXCHANGE, <span class="hljs-string">&quot;&quot;</span>, newData.get(<span class="hljs-string">&quot;id&quot;</span>));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-2-创建索引结构"><a href="#3-3-2-创建索引结构" class="headerlink" title="3.3.2 创建索引结构"></a>3.3.2 创建索引结构</h4><p>新建changgou_service_search_api模块,并添加索引库实体类</p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建实体类</p><p>注意： </p><ul><li><code>@Document</code>标示映射到Elasticsearch文档上的领域对象, <code>indexName = &quot;skuinfo&quot;</code>表明这个索引库的名称是skuinfo，<code>docs</code>表明这个索引库的类型是<code>_doc</code></li><li><code>@Field(index = true, store = true, type = FieldType.Keyword)</code>, 依次表示建立倒排索引，存储文档数据，不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document(indexName = &quot;skuinfo&quot;, type = &quot;docs&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkuInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">//商品id，同时也是商品编号</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-comment">//SKU名称</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Text, analyzer = &quot;ik_smart&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">//商品价格，单位为：元</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Double)</span><br>    <span class="hljs-keyword">private</span> Long price;<br><br>    <span class="hljs-comment">//库存数量</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Integer)</span><br>    <span class="hljs-keyword">private</span> Integer num;<br><br>    <span class="hljs-comment">//商品图片</span><br>    <span class="hljs-meta">@Field(index = false, store = true, type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String image;<br><br>    <span class="hljs-comment">//商品状态，1-正常，2-下架，3-删除</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String status;<br><br>    <span class="hljs-comment">//创建时间</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">//更新时间</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-comment">//是否默认</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String isDefault;<br><br>    <span class="hljs-comment">//SPUID</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Long)</span><br>    <span class="hljs-keyword">private</span> Long spuId;<br><br>    <span class="hljs-comment">//类目ID</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Long)</span><br>    <span class="hljs-keyword">private</span> Long categoryId;<br><br>    <span class="hljs-comment">//类目名称</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String categoryName;<br><br>    <span class="hljs-comment">//品牌名称</span><br>    <span class="hljs-meta">@Field(index = true, store = true, type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String brandName;<br><br>    <span class="hljs-comment">//规格</span><br>    <span class="hljs-keyword">private</span> String spec;<br><br>    <span class="hljs-comment">//规格参数</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; specMap;<br>    <br>    <span class="hljs-comment">//getter &amp; setter略</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-3-搜索微服务搭建"><a href="#3-3-3-搜索微服务搭建" class="headerlink" title="3.3.3 搜索微服务搭建"></a>3.3.3 搜索微服务搭建</h4><ol><li><p>创建changgou_service_search模块，pom.xml引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_goods_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_search_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置changgou_service_search的application.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9009</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">search</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#当遇到同样名字的时候，是否允许覆盖注册</span><br>  <span class="hljs-attr">data:</span><br>    <span class="hljs-attr">elasticsearch:</span><br>      <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">elasticsearch</span><br>      <span class="hljs-attr">cluster-nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.128</span><span class="hljs-string">:9300</span><br>  <span class="hljs-attr">thymeleaf:</span><br>    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span>   <span class="hljs-comment">#配置全局的feign的调用超时时间  如果 有指定的服务配置 默认的配置不会生效</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">600000</span> <span class="hljs-comment"># 指定的是 消费者 连接服务提供者的连接超时时间 是否能连接  单位是毫秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">600000</span>  <span class="hljs-comment"># 指定的是调用服务提供者的 服务 的超时时间（）  单位是毫秒</span><br><span class="hljs-comment">#hystrix 配置</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">timeout:</span><br>          <span class="hljs-comment">#如果enabled设置为false，则请求超时交给ribbon控制</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">strategy:</span> <span class="hljs-string">SEMAPHORE</span><br></code></pre></td></tr></table></figure></li><li><p>创建com.changgou包，包下创建SearchApplication启动类</p><p>注意：</p><ul><li><code>@EnableFeignClients</code>使用<strong>basePackages</strong>属性字段去指明应用程序在启动的时候需要扫描服务中的标注了@FeignClient注解的接口的包路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &#123;&quot;com.changgou.goods.feign&quot;&#125;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchApplication</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SearchApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将rabbitmq配置类放入该模块下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//定义交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_UP_EXCHANGE=<span class="hljs-string">&quot;goods_up_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_DOWN_EXCHANGE=<span class="hljs-string">&quot;goods_down_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//定义队列名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD_UPDATE_QUEUE=<span class="hljs-string">&quot;ad_update_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_ADD_QUEUE=<span class="hljs-string">&quot;search_add_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_DEL_QUEUE=<span class="hljs-string">&quot;search_del_queue&quot;</span>;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(AD_UPDATE_QUEUE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(SEARCH_ADD_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_ADD_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_ADD_QUEUE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(SEARCH_DEL_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_DEL_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_DEL_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(GOODS_UP_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_UP_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_UP_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(GOODS_DOWN_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_DOWN_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_DOWN_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br><br>    <span class="hljs-comment">//队列与交换机的绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">GOODS_UP_EXCHANGE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_ADD_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_UP_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">GOODS_DOWN_EXCHANGE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_DEL_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_DOWN_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-4-商品服务查询商品信息"><a href="#3-3-4-商品服务查询商品信息" class="headerlink" title="3.3.4 商品服务查询商品信息"></a>3.3.4 商品服务查询商品信息</h4><ol><li><p>SkuController新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/spu/&#123;spuId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sku&gt; <span class="hljs-title">findSkuListBySpuId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String spuId)</span></span>&#123;<br>    Map&lt;String, Object&gt; searchMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>   <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;all&quot;</span>.equals(spuId))&#123;<br>        searchMap.put(<span class="hljs-string">&quot;spuId&quot;</span>,spuId);<br>    &#125;<br>    searchMap.put(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>    List&lt;Sku&gt; skuList = skuService.findList(searchMap);<br>   <br>    <span class="hljs-keyword">return</span> skuList;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods_api新增common依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>changgou_service_goods_api新增feign包并定义skuFegin接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;goods&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/sku&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SkuFeign</span> </span>&#123;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 多条件搜索品牌数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> spuId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/spu/&#123;spuId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sku&gt; <span class="hljs-title">findSkuListBySpuId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;spuId&quot;)</span> String spuId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-5-搜索微服务批量导入数据逻辑"><a href="#3-3-5-搜索微服务批量导入数据逻辑" class="headerlink" title="3.3.5 搜索微服务批量导入数据逻辑"></a>3.3.5 搜索微服务批量导入数据逻辑</h4><ol><li><p>创建 com.changgou.search.dao包,并新增ESManagerMapper接口（这里是操作es的详细步骤，其实和操作mysql的比较类似）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ESManagerMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">SkuInfo</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;  <span class="hljs-comment">// 括号里表示的是当前要操作的实体类和当前主键的数据类型</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建 com.changgou.search.service包，包下创建接口EsManagerService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ESManagerService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建索引库结构</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMappingAndIndex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 导入全部数据到ES索引库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">importAll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据spuid导入数据到ES索引库</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> spuId 商品id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">importDataBySpuId</span><span class="hljs-params">(String spuId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建com.changgou.search.service.impl包，包下创建服务实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ESManagerServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ESManagerService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SkuFeign skuFeign;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ESManagerMapper esManagerMapper;<br><br>    <span class="hljs-comment">//创建索引库结构</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMappingAndIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//创建索引</span><br>        elasticsearchTemplate.createIndex(SkuInfo.class);<br>        <span class="hljs-comment">//创建映射</span><br>        elasticsearchTemplate.putMapping(SkuInfo.class);<br>    &#125;<br><br>    <span class="hljs-comment">//导入全部sku集合进入到索引库</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">importAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//查询sku集合</span><br>        List&lt;Sku&gt; skuList = skuFeign.findSkuListBySpuId(<span class="hljs-string">&quot;all&quot;</span>);<br>        <span class="hljs-keyword">if</span> (skuList == <span class="hljs-keyword">null</span> || skuList.size()&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前没有数据被查询到,无法导入索引库&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//skulist转换为json</span><br>        String jsonSkuList = JSON.toJSONString(skuList);<br>        <span class="hljs-comment">//将json转换为skuinfo</span><br>        List&lt;SkuInfo&gt; skuInfoList = JSON.parseArray(jsonSkuList, SkuInfo.class);<br><br>        <span class="hljs-keyword">for</span> (SkuInfo skuInfo : skuInfoList) &#123;<br>            <span class="hljs-comment">//将规格信息转换为map</span><br>            Map specMap = JSON.parseObject(skuInfo.getSpec(), Map.class);<br>            skuInfo.setSpecMap(specMap);<br>        &#125;<br><br>        <span class="hljs-comment">//导入索引库</span><br>        esManagerMapper.saveAll(skuInfoList);<br>    &#125;<br><br>    <span class="hljs-comment">//根据spuid查询skuList,添加到索引库</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">importDataBySpuId</span><span class="hljs-params">(String spuId)</span> </span>&#123;<br>        List&lt;Sku&gt; skuList = skuFeign.findSkuListBySpuId(spuId);<br>        <span class="hljs-keyword">if</span> (skuList == <span class="hljs-keyword">null</span> || skuList.size()&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前没有数据被查询到,无法导入索引库&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//将集合转换为json</span><br>        String jsonSkuList = JSON.toJSONString(skuList);<br>        List&lt;SkuInfo&gt; skuInfoList = JSON.parseArray(jsonSkuList, SkuInfo.class);<br><br>        <span class="hljs-keyword">for</span> (SkuInfo skuInfo : skuInfoList) &#123;<br>            <span class="hljs-comment">//将规格信息进行转换</span><br>            Map specMap = JSON.parseObject(skuInfo.getSpec(), Map.class);<br>            skuInfo.setSpecMap(specMap);<br>        &#125;<br><br>        <span class="hljs-comment">//添加索引库</span><br>        esManagerMapper.saveAll(skuInfoList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建com.changgou.search.controller.定义ESManagerController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/manager&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ESManagerController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ESManagerService esManagerService;<br><br>    <span class="hljs-comment">//创建索引库结构</span><br>    <span class="hljs-meta">@GetMapping(&quot;/create&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;<br>        esManagerService.createMappingAndIndex();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;创建索引库结构成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//导入全部数据</span><br>    <span class="hljs-meta">@GetMapping(&quot;/importAll&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">importAll</span><span class="hljs-params">()</span></span>&#123;<br>        esManagerService.importAll();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;导入全部数据成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-6-接收mq消息执行导入"><a href="#3-3-6-接收mq消息执行导入" class="headerlink" title="3.3.6 接收mq消息执行导入"></a>3.3.6 接收mq消息执行导入</h4><p>changgou_service_search工程创建com.changgou.search.listener包，包下创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsUpListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ESManagerService esManagerService;<br><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.SEARCH_ADD_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String spuId)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到的消息为:   &quot;</span>+spuId);<br><br>        <span class="hljs-comment">//查询skulist,并导入到索引库</span><br>        esManagerService.importDataBySpuId(spuId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-7-测试"><a href="#3-3-7-测试" class="headerlink" title="3.3.7 测试"></a>3.3.7 测试</h4><ol><li><p>启动环境 eureka 、elasticsearch 、canal服务端、canal数据监控微服务、rabbitmq</p></li><li><p>启动商品微服务、搜索微服务</p></li><li><p>修改tb_spu某记录的is_marketable值为1，观察控制台输出，启动kibana查询记录是否导入成功</p><p>可以看到成功导入3条数据</p><p><img src="/images/image-20210804135358627-1629279323872.png" alt="image-20210804135358627"></p></li></ol><h2 id="4-商品下架索引库删除数据"><a href="#4-商品下架索引库删除数据" class="headerlink" title="4. 商品下架索引库删除数据"></a>4. 商品下架索引库删除数据</h2><h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>商品下架后将商品从索引库中移除。</p><h3 id="4-2-实现思路"><a href="#4-2-实现思路" class="headerlink" title="4.2 实现思路"></a>4.2 实现思路</h3><p>思路与商品上架思路非常相似</p><ol><li><p>在数据监控微服务中监控tb_spu表的数据，当tb_spu发生更改且is_marketable为0时，表示商品下架，将spu的id发送到rabbitmq。</p></li><li><p>在rabbitmq管理后台创建商品下架交换器（fanout）。使用分列模式的交换器是考虑商品下架会有很多种逻辑需要处理，索引库删除数据只是其中一项，另外还有删除商品详细页等操作</p></li><li><p>搜索微服务从rabbitmq的的队列中提取spu的id，通过调用elasticsearch的高级restAPI 将相关的sku列表从索引库删除</p><p><img src="/images/image-20210804135821285-1629279323872.png" alt="image-20210804135821285"></p></li></ol><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><ol><li><p><strong>创建交换器与队列</strong></p><p>完成商品下架交换器的创建，队列的创建与绑定，将spuId发送消息到mq</p><p>商品下架交换器：goods_down_exchange</p><p>队列名称： search_delete_queue</p><p>绑定 search_delete_queue到goods_down_exchange</p><p>完善RabbitMQConfig的代码</p><p><img src="/images/image-20210804140359619-1629279323872.png" alt="image-20210804140359619"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;<br>    <span class="hljs-comment">//交换机名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_UP_EXCHANGE=<span class="hljs-string">&quot;goods_up_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GOODS_DOWN_EXCHANGE=<span class="hljs-string">&quot;goods_down_exchange&quot;</span>;<br><br>    <span class="hljs-comment">//定义队列名称 (tips: 大小写转换快捷键：CTRL+SHIFT+U)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_ADD_QUEUE=<span class="hljs-string">&quot;search_add_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AD_UPDATE_QUEUE = <span class="hljs-string">&quot;ad_update_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SEARCH_DEL_QUEUE=<span class="hljs-string">&quot;search_del_queue&quot;</span>;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(AD_UPDATE_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明队列</span><br>    <span class="hljs-meta">@Bean(SEARCH_ADD_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_ADD_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_ADD_QUEUE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(SEARCH_DEL_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">SEARCH_DEL_QUEUE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(SEARCH_DEL_QUEUE);<br>    &#125;<br><br>    <span class="hljs-comment">//声明交换机</span><br>    <span class="hljs-meta">@Bean(GOODS_UP_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_UP_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_UP_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(GOODS_DOWN_EXCHANGE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">GOODS_DOWN_EXCHANGE</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(GOODS_DOWN_EXCHANGE).durable(<span class="hljs-keyword">true</span>).build();<br>    &#125;<br><br>    <span class="hljs-comment">//队列绑定交换机</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">SEARCH_ADD_QUEUE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_ADD_QUEUE)</span> Queue queue, <span class="hljs-meta">@Qualifier(GOODS_UP_EXCHANGE)</span> Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">GOODS_DOWN_EXCHANGE_BINDING</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(SEARCH_DEL_QUEUE)</span>Queue queue,<span class="hljs-meta">@Qualifier(GOODS_DOWN_EXCHANGE)</span>Exchange exchange)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">&quot;&quot;</span>).noargs();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>由于搜索微服务也会用到消息队列，因此把已经写好的配置类复制一份给它</p><p><img src="/images/image-20210804140812672-1629279323872.png" alt="image-20210804140812672"></p></li><li><p><strong>canal监听下架</strong></p><p>修改changgou_canal的SpuListener的spuUpdate方法，添加以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取最新下架的商品 1-&gt;0</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;1&quot;</span>.equals(oldData.get(<span class="hljs-string">&quot;is_marketable&quot;</span>)) &amp;&amp; <span class="hljs-string">&quot;0&quot;</span>.equals(newData.get(<span class="hljs-string">&quot;is_marketable&quot;</span>)))&#123;<br>    <span class="hljs-comment">//将商品的spuid发送到mq</span><br>    rabbitTemplate.convertAndSend(RabbitMQConfig.GOODS_DOWN_EXCHANGE,<span class="hljs-string">&quot;&quot;</span>,newData.get(<span class="hljs-string">&quot;id&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>根据spuId删除索引数据</strong></p><p>编写业务逻辑，实现根据spuId删除索引库数据的方法。</p><ol><li><p>ESManagerService新增方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据souid删除es索引库中相关的sku数据</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delDataBySpuId</span><span class="hljs-params">(String spuId)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>ESManagerServiceImpl实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delDataBySpuId</span><span class="hljs-params">(String spuId)</span> </span>&#123;<br>    List&lt;Sku&gt; skuList = skuFeign.findSkuListBySpuId(spuId);<br>    <span class="hljs-keyword">if</span> (skuList == <span class="hljs-keyword">null</span> || skuList.size()&lt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;当前没有数据被查询到,无法导入索引库&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Sku sku : skuList) &#123;<br>        esManagerMapper.deleteById(Long.parseLong(sku.getId()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>接受mq消息，执行索引库删除</strong></p><p>从rabbitmq中提取消息，调动根据spuId删除索引库数据的方法 changgou_service_search新增监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsDelListener</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ESManagerService esManagerService;<br><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQConfig.SEARCH_DEL_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String spuId)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;删除索引库监听类,接收到的spuId:  &quot;</span>+spuId);<br><br>        <span class="hljs-comment">//调用业务层完成索引库数据删除</span><br>        esManagerService.delDataBySpuId(spuId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>畅购商城项目第一部分</title>
    <link href="/2021/07/26/1.1%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2021/07/26/1.1%20%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-01-框架搭建"><a href="#Part-01-框架搭建" class="headerlink" title="Part-01 框架搭建"></a>Part-01 框架搭建</h1><h2 id="1-框架搭建"><a href="#1-框架搭建" class="headerlink" title="1. 框架搭建"></a>1. 框架搭建</h2><h3 id="1-1-项目结构说明"><a href="#1-1-项目结构说明" class="headerlink" title="1.1 项目结构说明"></a>1.1 项目结构说明</h3><p><img src="/images/image-20210726205356384.png" alt="image-20210726205356384"></p><p>各个包的用途</p><ul><li><p>changgou_auth:  用于授权认证</p></li><li><p>changgou_common: 用来放返回给前端的result</p></li></ul><p><img src="/images/image-20210726205734286.png" alt="image-20210726205734286"></p><ul><li>changgou_common_db:  目的是和mysql数据库打交道，在他的pom文件中导入通用mapper依赖，mysql数据库驱动依赖，以及mybatis分页插件依赖</li><li>changgou_eureka: 微服务的注册中心，获取不同微服务的地址，便于通信</li><li>changgou_gateway : 网关模块，根据网站的规模和需要，可以将综合逻辑相关的服务用网关路由组合到一起。在这里还可以做鉴权和限流相关操作。</li><li>changgou_reverser: (目前还不是太理解这一部分的作用)</li><li>changgou_service: 微服务模块，该模块用于存放所有独立的微服务工程。</li></ul><p><img src="/images/image-20210726210519758.png" alt="image-20210726210519758"></p><ul><li><p>changgou_service_api: 这里面放了各个微服务对应工程的pojo以及服务调用的客户端声明接口Feign，该工程主要对他具体的微服务提供依赖。</p></li><li><p>changgou_transaction_fescar: 分布式事务模块，将分布式事务抽取到该工程中，任何工程如需要使用分布式事务，只需依赖该工程即可。 (目前还不是太理解这一部分的作用)</p></li><li><p>changgou_web: web服务工程，对应功能模块如需要调用多个微服务，可以将他们写入到该模块中，例如网站后台、网站前台等。 (目前还不是太理解这一部分的作用)</p></li></ul><h3 id="1-2-父工程搭建"><a href="#1-2-父工程搭建" class="headerlink" title="1.2 父工程搭建"></a>1.2 父工程搭建</h3><p>首先，创建空项目changgou。下面的所有模块都是用的无模板maven创建的，没有用Spring Initializr。</p><h4 id="1-2-1-一级父工程搭建"><a href="#1-2-1-一级父工程搭建" class="headerlink" title="1.2.1  一级父工程搭建"></a>1.2.1  一级父工程搭建</h4><p>在项目下面创建父工程 changgou_parent</p><p>配置好pom.xml文件，将src文件夹给删除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--spring boot项目跳过测试，但是测试类会生成.class文件--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!--依赖包--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--测试包--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>       <span class="hljs-comment">&lt;!--这下面的几个包是因为我没加时出异常：“java.lang.TypeNotPresentException: Type javax.xml.bind.JAXBContext not present”   应该和jdk的版本有关系--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Greenwich.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-二级父工程模块搭建"><a href="#1-2-2-二级父工程模块搭建" class="headerlink" title="1.2.2 二级父工程模块搭建"></a>1.2.2 二级父工程模块搭建</h4><p>创建changgou_gateway、changgou_service、changgou_service_api、 </p><p>changgou_web工程，工程全部为pom工程，并将所有工程的src文件删除。</p><h3 id="1-3-Eureka微服务搭建"><a href="#1-3-Eureka微服务搭建" class="headerlink" title="1.3 Eureka微服务搭建"></a>1.3 <strong>Eureka</strong>微服务搭建</h3><ol><li><p>在一级父工程下创建模块changgou_eureka。这个模块是用来当做注册中心服务方的（eureka-server）</p></li><li><p>pom.xml文件引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--eureka-server依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 appliation.yml 配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">6868</span> <span class="hljs-comment"># 表明这个服务的端口号是6868，启动以后在网页端输入（localhost:6868）即可访问图形界面</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#由于他是注册中心，所以不用注册到eureka中</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#他是给client提供信息的，所以不用从eureka中获取信息</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 表明这是一个注册中心，但是要注意在网页端输入 localhost:6868 才能看到图形界面，而不是下面这个带/eureka/的url</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p><code>$&#123;server.port&#125;</code>也是一种语言，用来获取配置文件键值对中的值的字符串，在这里就是 6868。            </p></li><li><p>在 java 目录下创建包 com.changgou.eureka，并在 eureka 包下创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//表明这是一个服务的启动类</span><br><span class="hljs-meta">@EnableEurekaServer</span>     <span class="hljs-comment">//表明这是eureka-server</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>上述步骤完成以后，启动启动类。在浏览器输入<code>localhost:6868</code>, 看是否能顺利打开图形界面。</p><h3 id="1-4-公共模块服务搭建"><a href="#1-4-公共模块服务搭建" class="headerlink" title="1.4 公共模块服务搭建"></a>1.4 公共模块服务搭建</h3><h4 id="1-4-1-全局公共模块"><a href="#1-4-1-全局公共模块" class="headerlink" title="1.4.1 全局公共模块"></a>1.4.1 全局公共模块</h4><ol><li><p>在一级父工程下创建子模块 changgou_common</p></li><li><p>引入 pom.xml 文件依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--web起步依赖。这里导入他，是因为这个包的目的就是创建实体类并将结果封装返回给前端--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- redis 使用--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--这里的响应结果和前端请求的格式都是json格式，所以需要这个包--&gt;</span>    <br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.51<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- eureka 客户端依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- feign 服务调用依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建 com.changgou.entity 包，包下封装相关公共实体类。（这里的entity实体类就按照模板来就行了，因为它是用来和前端交互信息的，写法比较固定）</p><p><img src="/images/image-20210726220028054.png" alt="image-20210726220028054"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回结果实体类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag;<span class="hljs-comment">//是否成功</span><br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//返回码</span><br>    <span class="hljs-keyword">private</span> String message;<span class="hljs-comment">//返回消息</span><br><br>    <span class="hljs-keyword">private</span> T data;<span class="hljs-comment">//返回数据</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Result</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag, Integer code, String message, Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.message = message;<br>        <span class="hljs-keyword">this</span>.data = (T)data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Result</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag, Integer code, String message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Result</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.code = StatusCode.OK;<br>        <span class="hljs-keyword">this</span>.message = <span class="hljs-string">&quot;执行成功&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFlag</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.flag = flag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(Integer code)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页结果类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageResult</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long total;<span class="hljs-comment">//总记录数</span><br>    <span class="hljs-keyword">private</span> List&lt;T&gt; rows;<span class="hljs-comment">//记录</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">(Long total, List&lt;T&gt; rows)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.total = total;<br>        <span class="hljs-keyword">this</span>.rows = rows;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageResult</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.total = total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">getRows</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> rows;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRows</span><span class="hljs-params">(List&lt;T&gt; rows)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.rows = rows;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回码实体类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusCode</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OK=<span class="hljs-number">20000</span>;<span class="hljs-comment">//成功</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ERROR =<span class="hljs-number">20001</span>;<span class="hljs-comment">//失败</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LOGINERROR =<span class="hljs-number">20002</span>;<span class="hljs-comment">//用户名或密码错误</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ACCESSERROR =<span class="hljs-number">20003</span>;<span class="hljs-comment">//权限不足</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REMOTEERROR =<span class="hljs-number">20004</span>;<span class="hljs-comment">//远程调用失败</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REPERROR =<span class="hljs-number">20005</span>;<span class="hljs-comment">//重复操作</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-2-数据访问公共模块搭建"><a href="#1-4-2-数据访问公共模块搭建" class="headerlink" title="1.4.2 数据访问公共模块搭建"></a>1.4.2 数据访问公共模块搭建</h4><p>这个公共模块是连接mysql数据库的公共微服务模块，所以需要连接mysql的微服务都继承自此工程。 </p><ol><li><p>创建数据访问公共模块changgou_common_db</p></li><li><p>给 pom.xml 文件引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--通用mapper起步依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--MySQL数据库驱动--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--mybatis分页插件--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="1-5-商品微服务搭建"><a href="#1-5-商品微服务搭建" class="headerlink" title="1.5 商品微服务搭建"></a>1.5 商品微服务搭建</h3><h4 id="1-5-1-商品微服务API工程搭建"><a href="#1-5-1-商品微服务API工程搭建" class="headerlink" title="1.5.1 商品微服务API工程搭建"></a>1.5.1 商品微服务<strong>API</strong>工程搭建</h4><ol><li><p>二级父工程 changgou_service_api 的 pom.xml 引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--这个包的作用是持久化，具体的说就是在实体类中进行元数据标签的作用，是ORM框架中用到的--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.persistence<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>persistence-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ORM框架可以通过这个元数据标签，使得实体类与数据库中的表建立映射关系。<br>例如javax.persistence.Column标识实体类中的这个属性对应于数据库中的一个字段等等。</p></li><li><p>changgou_service_api 下创建 changgou_service_goods_api 子模块</p></li></ol><h4 id="1-5-2-微服务工程搭建"><a href="#1-5-2-微服务工程搭建" class="headerlink" title="1.5.2 微服务工程搭建"></a>1.5.2 微服务工程搭建</h4><ol><li><p>二级父工程 changgou_service 下创建 changgou_service_goods 子模块 ，pom.xml 文件引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--这个包需要和数据库打交道，所以导入了changgou_common_db依赖，因为在changgou_common_db这个包中导入了数据库的一些依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common_db<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--导入changgou_service_goods_api包，是因为这个包里面定义了商品的pojo--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_service_goods_api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建并配置文件application.yml </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span>      <span class="hljs-comment"># 配置这个商品微服务的端口为 9001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">goods</span>   <span class="hljs-comment"># 配置这个微服务的名称为 goods</span><br>  <span class="hljs-attr">datasource:</span>     <span class="hljs-comment"># 配置mysql数据库的连接，注意他比spring低一级，注意要连接的数据库的 url 和表名称</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.200.128:3306/changgou_goods?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">main:</span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#当遇到同样名字的时候，允许覆盖注册</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><span class="hljs-comment"># register-with-eureka，fetch-registry这俩不写的话默认为true，表示他需要从注册中获取信息，以及将自己注册到注册中心</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span> <span class="hljs-comment"># 声明注册中心</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 声明这个实例可以通过ip访问到，而不只是域名</span><br><span class="hljs-attr">feign:</span>   <br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment"># 开启熔断机制</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span>   <span class="hljs-comment">#配置全局的feign的调用超时时间  如果 有指定的服务配置 默认的配置不会生效</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">60000</span> <span class="hljs-comment"># 指定的是 消费者 连接服务提供者的连接超时时间 是否能连接  单位是毫秒</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">20000</span>  <span class="hljs-comment"># 指定的是调用服务提供者的 服务 的超时时间（）  单位是毫秒</span><br><span class="hljs-comment">#hystrix 配置</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">execution:</span><br>        <span class="hljs-attr">timeout:</span><br>          <span class="hljs-comment">#如果enabled设置为false，则请求超时交给ribbon控制</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">isolation:</span><br>          <span class="hljs-attr">strategy:</span> <span class="hljs-string">SEMAPHORE</span><br>          <span class="hljs-attr">thread:</span><br>            <span class="hljs-comment"># 熔断器超时时间，默认：1000/毫秒</span><br>            <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure></li><li><p>创建包com.changgou.goods，并在goods下创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">// 表明他是这个服务的启动类</span><br><span class="hljs-meta">@EnableEurekaClient</span>     <span class="hljs-comment">// 表明这个微服务是一个eureka-client</span><br><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.changgou.goods.dao&quot;&#125;)</span>  <span class="hljs-comment">//@MapperScan是tk.mybatis.spring.annotation包下的，用于扫描dao包下的Mapper接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run( GoodsApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-商品微服务-品牌增删改查"><a href="#2-商品微服务-品牌增删改查" class="headerlink" title="2. 商品微服务-品牌增删改查"></a>2. 商品微服务-品牌增删改查</h2><p>先实现他的基本需求</p><ol><li>查询全部列表数据 </li><li>根据ID查询实体数据 </li><li>增加 </li><li>修改</li><li>删除</li><li>条件查询</li><li>分页查询</li><li>分页+条件查询 </li></ol><p>再观察他的表结构   (<em>tips: ctrl+enter 是在表格内换行, 直接按 enter会退出表格</em>)</p><table><thead><tr><th>字段名称</th><th>字段含义</th><th>字段类型</th><th>字段长度</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>品牌id</td><td>INT</td><td></td><td></td></tr><tr><td>name</td><td>品牌名称</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>image</td><td>品牌图片地址</td><td>VARCHAR</td><td></td><td></td></tr><tr><td>letter</td><td>品牌的首字母</td><td>CHAR</td><td></td><td></td></tr><tr><td>seq</td><td>排序</td><td>INT</td><td></td><td></td></tr></tbody></table><h3 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h3><p>商品类的整体包结构还是三层架构</p><p><img src="/images/image-20210727122004680.png" alt="image-20210727122004680"></p><h4 id="2-1-1-品牌列表"><a href="#2-1-1-品牌列表" class="headerlink" title="2.1.1 品牌列表"></a>2.1.1 品牌列表</h4><ol><li>在changgou_service_goods_api创建com.changgou.goods.pojo包，pojo包下创建 Brand实体类</li></ol><p><img src="/images/image-20210727120159612.png" alt="image-20210727120159612"></p><p>​    <img src="/images/image-20210727120235587.png" alt="image-20210727120235587"></p><p>​    注意实体类中的<code>@Table(name=&quot;tb_brand&quot;)</code>和<code>@Id</code>这俩注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.changgou.goods.pojo;<br><br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * brand实体类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Table(name=&quot;tb_brand&quot;)</span>  <span class="hljs-comment">//表明这个类和mysql数据库中的 tb_brand 相对应</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br><span class="hljs-meta">@Id</span>  <span class="hljs-comment">//表明id是表的主键</span><br><span class="hljs-keyword">private</span> Integer id;<span class="hljs-comment">//品牌id</span><br><br><br><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//品牌名称</span><br><span class="hljs-keyword">private</span> String image;<span class="hljs-comment">//品牌图片地址</span><br><span class="hljs-keyword">private</span> String letter;<span class="hljs-comment">//品牌的首字母</span><br><span class="hljs-keyword">private</span> Integer seq;<span class="hljs-comment">//排序</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getImage</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> image;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImage</span><span class="hljs-params">(String image)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.image = image;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLetter</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> letter;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLetter</span><span class="hljs-params">(String letter)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.letter = letter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSeq</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> seq;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSeq</span><span class="hljs-params">(Integer seq)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.seq = seq;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>Dao创建 </p><p>在changgou_service_goods微服务下创建com.changgou.goods.dao.BrandMapper接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Mapper&lt;T&gt;是一个接口, 继承它以后可以用一些基本的对数据库单表的操作方法,如果查询比较复杂, 则可以自己在BrandMapper中定义方法在注解上完成sql语句的编写</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BrandMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Brand</span>&gt; </span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>业务层 (service层)</p><p>创建com.changgou.goods.service.BrandService接口，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BrandService</span> </span>&#123;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 查询所有</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Brand&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建 com.changgou.goods.service.impl 包，包下创建服务实现类 BrandServiceImpl， 代码如下：</p><p>注意: </p><ul><li>业务层实现类上的 bean 定义<code>@Service</code>不能忘了，把实现类装载到spring容器中</li><li>要记得用<code>@Autowired</code>注入BrandMapper这个接口,是通过这个接口去操控数据库的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BrandService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BrandMapper brandMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询全部列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Brand&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brandMapper.selectAll();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制层 </p><p>控制层 com.changgou.goods包下创建controller包 ，包下创建类</p><p>注意:</p><ul><li><code>@RestController</code> = <code>@ResponseBody</code>+<code>@Controller</code>, <code>@ResponseBody</code>表明这个方法的返回值不是去跳转页面,而是响应给客户端浏览器的响应体. <code>@Controller</code>则是把这个类创建成bean放入spring容器</li><li>由于项目一般前后端分离, 前端项目和后端项目会部署在不同的服务器上, 所以客户端浏览器的请求是跨域的, 会存在请求通过前端到达不了后端的情况,  <code>@CrossOrigin</code>则表明允许跨域, 会解决掉上述问题</li><li><code>@RequestMapping</code>限制了这个控制器的访问路径</li><li><code>@Autowired</code>则是注入<code>BrandService</code>接口, 使用其接口实现类的方法</li><li><code>@GetMapping</code>则是使用了Restful风格, Get 表明这次请求是一次查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@CrossOrigin</span><br><span class="hljs-meta">@RequestMapping(&quot;/brand&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrandController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BrandService brandService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询全部数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;Brand&gt; brandList = brandService.findAll();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK,<span class="hljs-string">&quot;查询成功&quot;</span>,brandList) ;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>以上是查询全部商品的一个流程, 其他的基本需求流程是一样的, 若需要仔细研究请查看本机上的changgou项目.</p><h2 id="3-公共异常处理"><a href="#3-公共异常处理" class="headerlink" title="3. 公共异常处理"></a>3. 公共异常处理</h2><p>为了代码更容易维护，创建一个类集中处理异常 </p><p>在com.changgou.goods.handler包下创建公共异常处理类BaseExceptionHandler (也可在controller包下直接创建,看自己喜好)</p><p>注意: </p><ul><li><code>@ControllerAdvice</code>表明这是一个增强的<code>@Controller</code>, 是对整个controller进行操作的一个类</li><li><code>@ExceptionHandler(value = Exception.class)</code>表明这个方法是用来处理为<code>Exception</code>的异常</li><li><code>@ResponseBody</code>则是把结果<code>new Result(false, StatusCode.ERROR, &quot;执行出错&quot;)</code>返回给前端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = Exception.class)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">error</span><span class="hljs-params">(Exception e)</span></span>&#123;<br>        e.printStackTrace();        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, StatusCode.ERROR, <span class="hljs-string">&quot;执行出错&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Part-02-分布式文件存储"><a href="#Part-02-分布式文件存储" class="headerlink" title="Part-02 分布式文件存储"></a>Part-02 分布式文件存储</h1><h2 id="1-跨域解决方案CORS"><a href="#1-跨域解决方案CORS" class="headerlink" title="1. 跨域解决方案CORS"></a>1. 跨域解决方案CORS</h2><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port） </p><p>跨域调用，会出现如下错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">No</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">is</span> present <span class="hljs-keyword">on</span> the requested resource. <br>Origin <span class="hljs-string">&#x27;http://localhost:9100&#x27;</span> <span class="hljs-keyword">is</span> therefore <span class="hljs-keyword">not</span> allowed <span class="hljs-keyword">access</span>. The response had HTTP status code <span class="hljs-number">400.</span><br></code></pre></td></tr></table></figure><h2 id="2-通用mapper自定义方法"><a href="#2-通用mapper自定义方法" class="headerlink" title="2. 通用mapper自定义方法"></a>2. 通用<strong>mapper</strong>自定义方法</h2><h3 id="2-1-根据商品分类名称查询品牌列表"><a href="#2-1-根据商品分类名称查询品牌列表" class="headerlink" title="2.1 根据商品分类名称查询品牌列表"></a>2.1 根据商品分类名称查询品牌列表</h3><h4 id="2-1-1-表结构分析"><a href="#2-1-1-表结构分析" class="headerlink" title="2.1.1 表结构分析"></a>2.1.1 表结构分析</h4><p>已知分类与品牌之间的关系属于多对多关系, 通过中间表建立关系</p><p><img src="/images/image-20210727132544864.png" alt="image-20210727132544864"></p><p>​    <img src="/images/image-20210727132633929.png" alt="image-20210727132633929"></p><p><img src="/images/image-20210727132720929.png" alt="image-20210727132720929"></p><p><img src="/images/image-20210727132809184.png" alt="image-20210727132809184"></p><h4 id="2-1-2-代码实现"><a href="#2-1-2-代码实现" class="headerlink" title="2.1.2 代码实现"></a>2.1.2 代码实现</h4><p>由于这是一个复杂查询, Mapper<T>接口中的方法无法直接实现, 所以需要自己定义</p><ol><li><p>修改dao包中的BrandMapper，BrandMapper中新增方法定义 </p><p>注意: </p><ul><li>由于name不能直接写在sql语句里面, 所以需要用变量<code>#&#123;name&#125;</code>代替, 这个参数通过<code>@Param(&quot;name&quot;) String categoryName</code>传过来.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;SELECT NAME, image FROM tb_brand WHERE id IN (SELECT brand_id FROM tb_category_brand WHERE category_id IN (SELECT id FROM tb_category WHERE NAME=#&#123;name&#125; ORDER BY seq));&quot;)</span><br>   <span class="hljs-function">List&lt;Brand&gt; <span class="hljs-title">findBrandListByCategoryName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String categoryName)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>service层, controller层的流程不变</p></li></ol><h2 id="3-分布式文件存储-FastDFS"><a href="#3-分布式文件存储-FastDFS" class="headerlink" title="3. 分布式文件存储-FastDFS"></a>3. 分布式文件存储-FastDFS</h2><h3 id="3-1-FastDFS简介"><a href="#3-1-FastDFS简介" class="headerlink" title="3.1 FastDFS简介"></a>3.1 FastDFS简介</h3><p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p><p>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><p>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。 可以将storage称为存储服务器。 </p><img src="/images/image-20210727134921556.png" alt="image-20210727134921556" style="zoom: 67%;" /><h3 id="3-2-上传流程"><a href="#3-2-上传流程" class="headerlink" title="3.2 上传流程"></a>3.2 上传流程</h3><img src="/images/image-20210727135143849.png" alt="image-20210727135143849" style="zoom:67%;" /><p>客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。 </p><p><img src="/images/image-20210727135358878.png" alt="image-20210727135358878"></p><p><strong>组名</strong>：文件上传后所在的 storage 组名称，在文件上传成功后有storage 服务器返回，需要客户端自行保存。</p><p><strong>虚拟磁盘路径</strong>：storage 配置的虚拟路径，与磁盘选项store_path对应。如果配置了store_path0 则是 M00，如果配置了 store_path1 则是 M01，以此类推。</p><p><strong>数据两级目录</strong>：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。</p><p><strong>文件名</strong>：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器 IP 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。</p><h3 id="3-3-文件存储微服务搭建"><a href="#3-3-文件存储微服务搭建" class="headerlink" title="3.3 文件存储微服务搭建"></a>3.3 文件存储微服务搭建</h3><ol><li><p>在二级父工程changgou_service下创建文件管理微服务changgou_service_file，该工程主要用于实现文件上传以及文件删除等功能。修改pom.xml，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.27.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在resources文件夹下创建fasfDFS的配置文件<code>fdfs_client.conf</code>, 这个名字要和代码中的对应  (<em>这里的配置端口还不太懂, 没搞清楚这俩端口的区别</em>)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">connect_timeout</span> = <span class="hljs-number">60</span><br><span class="hljs-attr">network_timeout</span> = <span class="hljs-number">60</span><br><span class="hljs-attr">charset</span> = UTF-<span class="hljs-number">8</span><br><span class="hljs-attr">http.tracker_http_port</span> = <span class="hljs-number">8080</span><br><span class="hljs-attr">tracker_server</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">200.128</span>:<span class="hljs-number">22122</span><br></code></pre></td></tr></table></figure></li><li><p>在resources文件夹下创建application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span>  <span class="hljs-comment">#限制单个上传的文件最大为10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">10MB</span> <span class="hljs-comment">#限制的总上传数据最大为10MB</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9008</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>创建com.changgou.file包，创建启动类FileApplication </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(FileApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-文件上传"><a href="#3-4-文件上传" class="headerlink" title="3.4 文件上传"></a>3.4 文件上传</h3><p>这里的步骤是固定的, 以后需要用到的话直接把这里的工具类给复制过去</p><ol><li><p>文件信息封装</p><p>文件上传一般都有文件的名字、文件的内容、文件的扩展名、文件的md5值、文件的作者等相关属性，我们可以创建一个对象封装这些属性，代码如下:</p><p>创建com.changgou.file.pojo.FastDFSFile </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastDFSFile</span> </span>&#123;<br>    <span class="hljs-comment">//文件名字</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//文件内容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;<br>    <span class="hljs-comment">//文件扩展名</span><br>    <span class="hljs-keyword">private</span> String ext;<br>    <span class="hljs-comment">//文件MD5摘要值</span><br>    <span class="hljs-keyword">private</span> String md5;<br>    <span class="hljs-comment">//文件创建作者</span><br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastDFSFile</span><span class="hljs-params">(String name, <span class="hljs-keyword">byte</span>[] content, String ext, String height,</span></span><br><span class="hljs-params"><span class="hljs-function">                       String width, String author)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.content = content;<br>        <span class="hljs-keyword">this</span>.ext = ext;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastDFSFile</span><span class="hljs-params">(String name, <span class="hljs-keyword">byte</span>[] content, String ext)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.content = content;<br>        <span class="hljs-keyword">this</span>.ext = ext;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getExt</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ext;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExt</span><span class="hljs-params">(String ext)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ext = ext;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMd5</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> md5;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMd5</span><span class="hljs-params">(String md5)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.md5 = md5;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> author;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthor</span><span class="hljs-params">(String author)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.author = author;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>文件操作</p><p>创建FastDFSClient类,放在com.changgou.file.util下在该类中实现FastDFS信息获取以及文件的相关操作，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.changgou.file.util;<br><br><span class="hljs-keyword">import</span> org.csource.common.NameValuePair;<br><span class="hljs-keyword">import</span> org.csource.fastdfs.*;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastDFSClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> org.slf4j.Logger logger = LoggerFactory.getLogger(FastDFSClient.class);<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 初始化加载FastDFS的TrackerServer配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String filePath = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;fdfs_client.conf&quot;</span>).getFile().getAbsolutePath();<br>            ClientGlobal.init(filePath);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;FastDFS Client Init Fail!&quot;</span>,e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 文件上传</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 1.文件的组名  2.文件的路径信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] upload(FastDFSFile file) &#123;<br>        <span class="hljs-comment">//获取文件的作者</span><br>        NameValuePair[] meta_list = <span class="hljs-keyword">new</span> NameValuePair[<span class="hljs-number">1</span>];<br>        meta_list[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> NameValuePair(<span class="hljs-string">&quot;author&quot;</span>, file.getAuthor());<br><br>        <span class="hljs-comment">//接收返回数据</span><br>        String[] uploadResults = <span class="hljs-keyword">null</span>;<br>        StorageClient storageClient=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建StorageClient客户端对象</span><br>            storageClient = getTrackerClient();<br><br>            <span class="hljs-comment">/***</span><br><span class="hljs-comment">             * 文件上传</span><br><span class="hljs-comment">             * 1)文件字节数组</span><br><span class="hljs-comment">             * 2)文件扩展名</span><br><span class="hljs-comment">             * 3)文件作者</span><br><span class="hljs-comment">             */</span><br>            uploadResults = storageClient.upload_file(file.getContent(), file.getExt(), meta_list);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Exception when uploadind the file:&quot;</span> + file.getName(), e);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (uploadResults == <span class="hljs-keyword">null</span> &amp;&amp; storageClient!=<span class="hljs-keyword">null</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;upload file fail, error code:&quot;</span> + storageClient.getErrorCode());<br>        &#125;<br>        <span class="hljs-comment">//获取组名</span><br>        String groupName = uploadResults[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//获取文件存储路径</span><br>        String remoteFileName = uploadResults[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> uploadResults;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取文件信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName:组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName：文件存储完整名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileInfo <span class="hljs-title">getFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            StorageClient storageClient = getTrackerClient();<br>            <span class="hljs-keyword">return</span> storageClient.get_file_info(groupName, remoteFileName);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Exception: Get File from Fast DFS failed&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 文件下载</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title">downFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建StorageClient</span><br>            StorageClient storageClient = getTrackerClient();<br><br>            <span class="hljs-comment">//下载文件</span><br>            <span class="hljs-keyword">byte</span>[] fileByte = storageClient.download_file(groupName, remoteFileName);<br>            InputStream ins = <span class="hljs-keyword">new</span> ByteArrayInputStream(fileByte);<br>            <span class="hljs-keyword">return</span> ins;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Exception: Get File from Fast DFS failed&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 文件删除</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建StorageClient</span><br>        StorageClient storageClient = getTrackerClient();<br><br>        <span class="hljs-comment">//删除文件</span><br>        <span class="hljs-keyword">int</span> i = storageClient.delete_file(groupName, remoteFileName);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取Storage组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StorageServer[] getStoreStorages(String groupName)<br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//创建TrackerClient</span><br>        TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>        <span class="hljs-comment">//获取TrackerServer</span><br>        TrackerServer trackerServer = trackerClient.getConnection();<br>        <span class="hljs-comment">//获取Storage组</span><br>        <span class="hljs-keyword">return</span> trackerClient.getStoreStorages(trackerServer, groupName);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取Storage信息,IP和端口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerInfo[] getFetchStorages(String groupName,<br>                                                String remoteFileName) <span class="hljs-keyword">throws</span> IOException &#123;<br>        TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>        TrackerServer trackerServer = trackerClient.getConnection();<br>        <span class="hljs-keyword">return</span> trackerClient.getFetchStorages(trackerServer, groupName, remoteFileName);<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取Tracker服务地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTrackerUrl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;http://&quot;</span>+getTrackerServer().getInetSocketAddress().getHostString()+<span class="hljs-string">&quot;:&quot;</span>+ClientGlobal.getG_tracker_http_port()+<span class="hljs-string">&quot;/&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取Storage客户端</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StorageClient <span class="hljs-title">getTrackerClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        TrackerServer trackerServer = getTrackerServer();<br>        StorageClient storageClient = <span class="hljs-keyword">new</span> StorageClient(trackerServer, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">return</span>  storageClient;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 获取Tracker</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TrackerServer <span class="hljs-title">getTrackerServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>        TrackerServer trackerServer = trackerClient.getConnection();<br>        <span class="hljs-keyword">return</span>  trackerServer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>文件上传 </p><p>创建一个FileController，在该控制器中实现文件上传操作，代码如下</p><p>注意:</p><ul><li>Post表示数据提交</li><li>controller方法里的参数一定是从前端传递过来的, 注意参数的名称要和前端取名对应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/file&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">uploadFile</span><span class="hljs-params">(MultipartFile file)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(file == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>            &#125;<br><br>            String originalFilename = file.getOriginalFilename();<br>            <span class="hljs-keyword">if</span>(StringUtils.isEmpty(originalFilename))&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>            &#125;<br><br>            String extName = originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">byte</span>[] content = file.getBytes();<br><br>            FastDFSFile fastDFSFile = <span class="hljs-keyword">new</span> FastDFSFile(originalFilename, content, extName);<br><br>            String[] uploadResults = FastDFSClient.upload(fastDFSFile);<br><br>            String url = FastDFSClient.getTrackerUrl() + uploadResults[<span class="hljs-number">0</span>] + uploadResults[<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;文件上传成功&quot;</span>, url);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, StatusCode.ERROR, <span class="hljs-string">&quot;文件上传失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Postman</strong>测试文件上传 </p><p>测试的时候记得文件名称也取成file, 不然请求参数传到controller那里由于参数和方法里的形参对不上会报错</p></li></ol><h1 id="Part-03-微服务网关鉴权JWT"><a href="#Part-03-微服务网关鉴权JWT" class="headerlink" title="Part-03 微服务网关鉴权JWT"></a>Part-03 微服务网关鉴权JWT</h1><h2 id="1-BCrypt密码加密"><a href="#1-BCrypt密码加密" class="headerlink" title="1. BCrypt密码加密"></a>1. BCrypt密码加密</h2><h3 id="1-1-Bcypt快速入门"><a href="#1-1-Bcypt快速入门" class="headerlink" title="1.1 Bcypt快速入门"></a>1.1 Bcypt快速入门</h3><p>在用户模块，对于用户密码的保护，通常都会进行加密。我们通常对密码进行加密，然后存放在数据库中，在用户进行登录的时候，将其输入的密码进行加密然后与数据库中存放的密文进行比较，以验证用户密码是否正确。目前，MD5和BCrypt比较流行。相对来说, BCrypt比MD5更安全。因为其内部引入的加盐机制. (加盐实际上是随机生成一个29位字符的字符串) </p><p>官网: <a href="http://www.mindrot.org/projects/jBCrypt/">http://www.mindrot.org/projects/jBCrypt/</a></p><p>测试用例</p><p>注意: </p><ul><li>每次程序执行时生成盐值的密文是会变的</li><li>BCrypt不支持反运算(即通过密文得到明文), 只支持密码校验</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCrypt; <span class="hljs-comment">//注意这里的包别导错了</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBCrypt</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1.生成盐</span><br>        String gensalt = BCrypt.gensalt();<br>        System.out.println(<span class="hljs-string">&quot;salt:&quot;</span> + gensalt);<br><br>        <span class="hljs-comment">// 2.生成密码</span><br>        String saltPassword = BCrypt.hashpw(<span class="hljs-string">&quot;123456&quot;</span>, gensalt);<br>        System.out.println(<span class="hljs-string">&quot;密码：&quot;</span> + saltPassword);<br>        <br>        <span class="hljs-comment">// 3.对密码进行校验</span><br>        <span class="hljs-keyword">boolean</span> checkpw = BCrypt.checkpw(<span class="hljs-string">&quot;123456&quot;</span>, saltPassword);<br>        System.out.println(checkpw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-商城新增管理员密码加密"><a href="#1-2-商城新增管理员密码加密" class="headerlink" title="1.2 商城新增管理员密码加密"></a>1.2 商城新增管理员密码加密</h3><p>代码实现</p><p>注意:</p><ul><li>大致的框架都已经完成了,这里只是实现让密码加密这一部分过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 增加</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> admin</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Admin admin)</span></span>&#123;<br>      <span class="hljs-comment">//获取盐</span><br>      String gensalt = BCrypt.gensalt();<br>      <span class="hljs-comment">//对用户的密码进行加密</span><br>      String hashpw = BCrypt.hashpw(admin.getPassword(), gensalt);<br>      admin.setPassword(hashpw);<br>      adminMapper.insert(admin);<br>  &#125;<br></code></pre></td></tr></table></figure><p>cotroller层代码讲解</p><p>注意：</p><ul><li><code>@RequestBody</code>: 对前端传过来的json串自动赋值给这里的admin新参对象</li><li>数据库表的登录字段名称是<code>login_name</code>, 但是Admin类里是<code>loginName</code>, 不知道为啥这样也可以对应</li><li>启动服务的时候先启动注册中心的，在启动相应的微服务的类，不然会报错 <code>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment">    * 新增数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> admin</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Admin admin)</span></span>&#123;<br>       adminService.add(admin);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>,StatusCode.OK,<span class="hljs-string">&quot;添加成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-管理员登录密码验证"><a href="#1-3-管理员登录密码验证" class="headerlink" title="1.3 管理员登录密码验证"></a>1.3 管理员登录密码验证</h3><p>需求分析:</p><p>用户发送请求，输入用户名和密码。后台管理微服务controller接收参数，验证用户名和密码是否正确，如果正确则返回用户登录成功结果, 如果错误则返回登陆失败信息。 </p><p>代码实现</p><ol><li><p>AdminService新增方法定义 login()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户登录</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> admin</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Admin admin)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>AdminServiceImpl实现此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(Admin admin)</span> </span>&#123;<br>       <span class="hljs-comment">// 根据登录名查询管理员</span><br>       Admin admin1 = <span class="hljs-keyword">new</span> Admin();<br>       admin1.setLoginName(admin.getLoginName());<br>       admin1.setStatus(<span class="hljs-string">&quot;1&quot;</span>);<br>       Admin admin2 = adminMapper.selectOne(admin1);<br>       <br>       <span class="hljs-comment">//比对数据库查询出的对象是否存在，存在则返回真，不存在则返回假</span><br>       <span class="hljs-keyword">if</span>(admin2 == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> BCrypt.checkpw(admin.getPassword(), admin2.getPassword());<br>       &#125;<br>   <br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>AdminController新增方法</p><p>注意：</p><ul><li><code>@RequestBody</code>不能少，不然前端传过来的json串无法赋值给admin对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span>  <span class="hljs-comment">//post 表示会传递json串过来</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Admin admin)</span></span>&#123;<br>       <span class="hljs-keyword">boolean</span> login = adminService.login(admin);<br>       <span class="hljs-keyword">if</span> (login)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, StatusCode.LOGINERROR, <span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-JWT-实现微服务鉴权"><a href="#2-JWT-实现微服务鉴权" class="headerlink" title="2. JWT 实现微服务鉴权"></a>2. <strong>JWT</strong> 实现微服务鉴权</h2><h3 id="2-1-什么是微服务鉴权"><a href="#2-1-什么是微服务鉴权" class="headerlink" title="2.1 什么是微服务鉴权"></a>2.1 什么是微服务鉴权</h3><img src="/images/image-20210727205423816.png" alt="image-20210727205423816"  /><p>我们可以采用JWT的方式来实现鉴权校验。</p><h3 id="2-2-JWT"><a href="#2-2-JWT" class="headerlink" title="2.2 JWT"></a>2.2 <strong>JWT</strong></h3><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><ul><li><p><strong>头部</strong>（<strong>Header</strong>） </p><p>头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;typ&quot;</span>:<span class="hljs-string">&quot;JWT&quot;</span>,<span class="hljs-attr">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>在头部指明了签名算法是HS256算法。 我们进行BASE64编码，编码后的字符串如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span><br></code></pre></td></tr></table></figure></li><li><p><strong>载荷</strong>（<strong>payload</strong>）</p><p>载荷就是存放有效信息的地方。</p><p>定义一个payload:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;sub&quot;</span>:<span class="hljs-string">&quot;1234567890&quot;</span>,<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;John Doe&quot;</span>,<span class="hljs-attr">&quot;admin&quot;</span>:<span class="hljs-literal">true</span>&#125;<br></code></pre></td></tr></table></figure><p>然后将其进行base64编码，得到Jwt的第二部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiYWRtaW<span class="hljs-number">4</span>iO<span class="hljs-symbol">nRydWV9</span><br></code></pre></td></tr></table></figure></li><li><p><strong>签证</strong>（<strong>signature</strong>）</p><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">header</span></span> (base<span class="hljs-number">64</span>后的)<br><span class="hljs-attribute">payload</span> (base<span class="hljs-number">64</span>后的)<br><span class="hljs-attribute">secret</span> <br></code></pre></td></tr></table></figure><p>然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分（第三部分就包括了一二部分）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">TJVA<span class="hljs-number">95</span><span class="hljs-keyword">Or</span><span class="hljs-name">M7</span>E<span class="hljs-number">2</span>cBab<span class="hljs-number">30</span>RMHrHDcEfxjoYZgeFO<span class="hljs-symbol">NFh7</span>HgQ<br></code></pre></td></tr></table></figure></li></ul><p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt: </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.eyJzdWIiOiIxMjM<span class="hljs-number">0</span>NTY<span class="hljs-number">3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>IkpvaG<span class="hljs-number">4</span>gRG<span class="hljs-number">9</span>lIiwiYWRtaW<span class="hljs-number">4</span>iOnRydWV<span class="hljs-number">9</span>.TJVA<span class="hljs-number">95</span>OrM<span class="hljs-number">7</span>E<span class="hljs-number">2</span>cBab<span class="hljs-number">30</span>RMHrHDcEfxjoYZgeFONFh<span class="hljs-number">7</span>HQ<br></code></pre></td></tr></table></figure><h3 id="2-3-JJWT签发与验证token"><a href="#2-3-JJWT签发与验证token" class="headerlink" title="2.3 JJWT签发与验证token"></a>2.3 <strong>JJWT</strong>签发与验证<strong>token</strong></h3><p>JJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JJWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。 </p><p>官方文档： <a href="https://github.com/jwtk/jjwt">https://github.com/jwtk/jjwt</a> </p><h4 id="2-3-1-创建token"><a href="#2-3-1-创建token" class="headerlink" title="2.3.1 创建token"></a>2.3.1 创建<strong>token</strong></h4><ol><li><p>新建项目jwtTest中的pom.xml中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建测试类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        JwtBuilder builder = Jwts.builder()<br>                                .setId(<span class="hljs-string">&quot;888&quot;</span>)<br>                                .setSubject(<span class="hljs-string">&quot;小白&quot;</span>)<br>                                .setIssuedAt(<span class="hljs-keyword">new</span> Date())<br>                                .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;itcast&quot;</span>);<br><br>        System.out.println(builder.compact());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行打印结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eyJhbGciOiJIUzI1NiJ9</span>.eyJqdGkiOiI<span class="hljs-number">4</span>ODgiLCJzdWIiOiLlsI_nmb<span class="hljs-number">0</span>iLCJpYXQiOjE<span class="hljs-number">2</span>MjczOTI<span class="hljs-number">3</span>MzR<span class="hljs-number">9</span>.Je<span class="hljs-number">1</span>REFE<span class="hljs-number">0</span>D<span class="hljs-number">0</span>w<span class="hljs-number">9</span>eV<span class="hljs-number">3</span>rUl<span class="hljs-number">6</span>sqQN<span class="hljs-number">4</span>m<span class="hljs-number">3</span>Z-LSShbyn<span class="hljs-number">8</span>JGleEgw<br></code></pre></td></tr></table></figure><p>由于载荷中包含时间，每次生成的jwt是不一样的。</p></li></ol><h4 id="2-3-2-解析token"><a href="#2-3-2-解析token" class="headerlink" title="2.3.2 解析token"></a>2.3.2 解析<strong>token</strong></h4><p>我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token，那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        JwtBuilder builder = Jwts.builder()<br>                                .setId(<span class="hljs-string">&quot;888&quot;</span>)<br>                                .setSubject(<span class="hljs-string">&quot;小白&quot;</span>)<br>                                .setIssuedAt(<span class="hljs-keyword">new</span> Date())<br>                                .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;itcast&quot;</span>);<br><br>        String compactJwt = builder.compact();<br>        System.out.println(compactJwt);<br><br>        Claims claims = Jwts.parser().setSigningKey(<span class="hljs-string">&quot;itcast&quot;</span>).parseClaimsJws(compactJwt).getBody();<br>        System.out.println(claims);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span>.eyJqdGkiOiI<span class="hljs-number">4</span>ODgiLCJzdWIiOiLlsI_<span class="hljs-symbol">nmb0</span>iLCJpYXQiOjE<span class="hljs-number">2</span>MjczOT<span class="hljs-name">M2</span><span class="hljs-symbol">NDN9</span><span class="hljs-number">.2</span>QzU<span class="hljs-number">2</span>Z-MSSGpspIe<span class="hljs-number">9</span>za<span class="hljs-number">7</span>SmkLJT<span class="hljs-number">2</span>tqHv<span class="hljs-number">9</span>mOBQ<span class="hljs-symbol">N1</span>JWqBU<br>&#123;jti=<span class="hljs-number">888</span>, <span class="hljs-keyword">sub</span>=小白, iat=<span class="hljs-number">1627393643</span>&#125;<br></code></pre></td></tr></table></figure><p>试着将token或签名秘钥(代码里面的<code>&quot;itcast&quot;</code>字符串)篡改一下，会发现运行时就会报错，所以解析token也就是验证token.</p><p>还可以设置token的过期时间，自定义claims(载荷里的键值对)等。具体用法可以上网查也可以看本地笔记。</p><h3 id="2-4-畅购微服务鉴权代码实现"><a href="#2-4-畅购微服务鉴权代码实现" class="headerlink" title="2.4 畅购微服务鉴权代码实现"></a>2.4 畅购微服务鉴权代码实现</h3><h4 id="2-4-1-思路分析"><a href="#2-4-1-思路分析" class="headerlink" title="2.4.1 思路分析"></a>2.4.1 思路分析</h4><img src="/images/image-20210727225002149.png" alt="image-20210727225002149" style="zoom:80%;" /><ol><li>用户进入网关开始登陆，网关过滤器进行判断，如果是登录，则路由到后台管理微服务进行登录</li><li>用户登录成功，后台管理微服务签发JWT TOKEN信息返回给用户 </li><li>用户再次进入网关开始访问，网关过滤器接收用户携带的TOKEN </li><li>网关过滤器解析TOKEN ，判断是否有权限，如果有，则放行，如果没有则返回未认证错误</li></ol><h4 id="2-4-2-系统微服务签发token"><a href="#2-4-2-系统微服务签发token" class="headerlink" title="2.4.2 系统微服务签发token"></a>2.4.2 系统微服务签发<strong>token</strong></h4><ol><li><p>在changgou_service_system添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在changgou_service_system的util包中创建类： JwtUtil (这个工具类会用就行，需要深入学习的时候再学)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JWT工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//有效期为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long JWT_TTL = <span class="hljs-number">3600000L</span>;<span class="hljs-comment">// 60 * 60 *1000  一个小时</span><br>    <span class="hljs-comment">//设置秘钥明文</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JWT_KEY = <span class="hljs-string">&quot;itcast&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subject</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ttlMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createJWT</span><span class="hljs-params">(String id, String subject, Long ttlMillis)</span> </span>&#123;<br><br>        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;<br>        <span class="hljs-keyword">long</span> nowMillis = System.currentTimeMillis();<br>        Date now = <span class="hljs-keyword">new</span> Date(nowMillis);<br>        <span class="hljs-keyword">if</span>(ttlMillis==<span class="hljs-keyword">null</span>)&#123;<br>            ttlMillis=JwtUtil.JWT_TTL;<br>        &#125;<br>        <span class="hljs-keyword">long</span> expMillis = nowMillis + ttlMillis;<br>        Date expDate = <span class="hljs-keyword">new</span> Date(expMillis);<br>        SecretKey secretKey = generalKey();<br><br>        JwtBuilder builder = Jwts.builder()<br>                .setId(id)              <span class="hljs-comment">//唯一的ID</span><br>                .setSubject(subject)   <span class="hljs-comment">// 主题  可以是JSON数据</span><br>                .setIssuer(<span class="hljs-string">&quot;admin&quot;</span>)     <span class="hljs-comment">// 签发者</span><br>                .setIssuedAt(now)      <span class="hljs-comment">// 签发时间</span><br>                .signWith(signatureAlgorithm, secretKey) <span class="hljs-comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span><br>                .setExpiration(expDate);<span class="hljs-comment">// 设置过期时间</span><br>        <span class="hljs-keyword">return</span> builder.compact();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成加密后的秘钥 secretKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecretKey <span class="hljs-title">generalKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);<br>        SecretKey key = <span class="hljs-keyword">new</span> SecretKeySpec(encodedKey, <span class="hljs-number">0</span>, encodedKey.length, <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改AdminController的login方法, 用户登录成功 则签发TOKEN</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span>  <span class="hljs-comment">//post 表示会传递json串过来</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Admin admin)</span></span>&#123;<br>       <span class="hljs-keyword">boolean</span> login = adminService.login(admin);<br>       <span class="hljs-keyword">if</span> (login)&#123;  <span class="hljs-comment">//如果验证成功</span><br>           Map&lt;String, String&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>           info.put(<span class="hljs-string">&quot;username&quot;</span>, admin.getLoginName());<br>           String token = JwtUtil.createJWT(UUID.randomUUID().toString(), admin.getLoginName(), <span class="hljs-keyword">null</span>);<br>           info.put(<span class="hljs-string">&quot;token&quot;</span>, token);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;登录成功&quot;</span>, info);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, StatusCode.LOGINERROR, <span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><p>使用postman测试</p><h4 id="2-4-3-网关过滤器验证token"><a href="#2-4-3-网关过滤器验证token" class="headerlink" title="2.4.3 网关过滤器验证token"></a>2.4.3 网关过滤器验证<strong>token</strong></h4><ol><li><p>在changgou_gateway_system网关系统添加依赖 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>util包下创建JWTUtil类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JWT工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">//有效期为</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long JWT_TTL = <span class="hljs-number">3600000L</span>;<span class="hljs-comment">// 60 * 60 *1000  一个小时</span><br>    <span class="hljs-comment">//设置秘钥明文</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JWT_KEY = <span class="hljs-string">&quot;itcast&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建token</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> subject</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ttlMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createJWT</span><span class="hljs-params">(String id, String subject, Long ttlMillis)</span> </span>&#123;<br><br>        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;<br>        <span class="hljs-keyword">long</span> nowMillis = System.currentTimeMillis();<br>        Date now = <span class="hljs-keyword">new</span> Date(nowMillis);<br>        <span class="hljs-keyword">if</span>(ttlMillis==<span class="hljs-keyword">null</span>)&#123;<br>            ttlMillis=JwtUtil.JWT_TTL;<br>        &#125;<br>        <span class="hljs-keyword">long</span> expMillis = nowMillis + ttlMillis;<br>        Date expDate = <span class="hljs-keyword">new</span> Date(expMillis);<br>        SecretKey secretKey = generalKey();<br><br>        JwtBuilder builder = Jwts.builder()<br>                .setId(id)              <span class="hljs-comment">//唯一的ID</span><br>                .setSubject(subject)   <span class="hljs-comment">// 主题  可以是JSON数据</span><br>                .setIssuer(<span class="hljs-string">&quot;admin&quot;</span>)     <span class="hljs-comment">// 签发者</span><br>                .setIssuedAt(now)      <span class="hljs-comment">// 签发时间</span><br>                .signWith(signatureAlgorithm, secretKey) <span class="hljs-comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span><br>                .setExpiration(expDate);<span class="hljs-comment">// 设置过期时间</span><br>        <span class="hljs-keyword">return</span> builder.compact();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成加密后的秘钥 secretKey</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecretKey <span class="hljs-title">generalKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);<br>        SecretKey key = <span class="hljs-keyword">new</span> SecretKeySpec(encodedKey, <span class="hljs-number">0</span>, encodedKey.length, <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建过滤器，用于token验证</p><p>注意：</p><ul><li>记得把过滤类放入spring容器中，不要忘了<code>@Component</code>注解</li><li><code>AuthorizeFilter</code>要实现<code>GlobalFilter</code>, <code>Ordered</code>这两个类</li><li><code>Ordered</code>数值越小这个过滤类的优先级越高</li><li><code>request.getHeaders()</code>返回的是实现了<code>MultiValueMap&lt;String, String&gt;</code>的<code>HttpHeaders</code></li><li><code>headers.getFirst(&quot;Authorization&quot;)</code>获取请求头中键为Authorization的对应的值</li><li>http请求包括请求行，请求头和请求体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">//1.获取请求</span><br>        ServerHttpRequest request = exchange.getRequest();<br>        <span class="hljs-comment">//2.获取响应</span><br>        ServerHttpResponse response = exchange.getResponse();<br>        <span class="hljs-comment">//3.如果是登录请求则放行</span><br>        <span class="hljs-keyword">if</span>(request.getURI().getPath().contains(<span class="hljs-string">&quot;/admin/login&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">//4.获取请求头</span><br>        HttpHeaders headers = request.getHeaders();<br>        <span class="hljs-comment">//5.获取请求头中的令牌。自己写路径的时候记得按照key=Authorization, value=token的形式来，不要瞎起名字</span><br>        String token = headers.getFirst(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-comment">//6.判断请求头中是否有令牌</span><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(token))&#123;<br>            <span class="hljs-comment">//7. 响应中放入返回的状态吗, 没有权限访问</span><br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-comment">//8.返回</span><br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br>        <span class="hljs-comment">//9.如果请求头中有令牌则解析令牌</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JwtUtil.parseJWT(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">//10. 解析jwt令牌出错, 说明令牌过期或者伪造等不合法情况出现</span><br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-comment">//11.返回</span><br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br><br>        <span class="hljs-comment">//12.放行</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>最后再postman中进行测试</p>]]></content>
    
    
    <categories>
      
      <category>畅购商城项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fluid样式修改</title>
    <link href="/2021/06/28/0.%20fluid%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/"/>
    <url>/2021/06/28/0.%20fluid%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="修改fluid主题样式大致流程"><a href="#修改fluid主题样式大致流程" class="headerlink" title="修改fluid主题样式大致流程"></a>修改fluid主题样式大致流程</h1><h2 id="1-定位资源"><a href="#1-定位资源" class="headerlink" title="1. 定位资源"></a>1. 定位资源</h2><ol><li>打开下图文件夹处</li></ol><p><img src="/images/image-20210806152838538.png" alt="image-20210806152838538"></p><ol start="2"><li><p>在此处打开git bash 命令行，并通过<code>code ./</code>打开vscode进行编辑</p><p><img src="/images/image-20210806153104629.png" alt="image-20210806153104629"></p></li></ol><h2 id="2-修改样式"><a href="#2-修改样式" class="headerlink" title="2. 修改样式"></a>2. 修改样式</h2><ol><li><p>在 plugin.js文件中，我去掉了标题的超链接样式，代码如下(注意他的相对位置)</p><p>165行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//下面这个函数注释掉最后一行</span><br>initAnchor: function() &#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;anchors&#x27;</span> <span class="hljs-keyword">in</span> window)) &#123; return; &#125;<br>   <br>  window<span class="hljs-selector-class">.anchors</span><span class="hljs-selector-class">.options</span> = &#123;<br>    placement: CONFIG<span class="hljs-selector-class">.anchorjs</span><span class="hljs-selector-class">.placement</span>,<br>    visible  : CONFIG<span class="hljs-selector-class">.anchorjs</span><span class="hljs-selector-class">.visible</span><br>    <br>  &#125;;<br>  <span class="hljs-keyword">if</span> (CONFIG<span class="hljs-selector-class">.anchorjs</span>.<span class="hljs-attribute">icon</span>) &#123;<br>    window<span class="hljs-selector-class">.anchors</span><span class="hljs-selector-class">.options</span><span class="hljs-selector-class">.icon</span> = CONFIG<span class="hljs-selector-class">.anchorjs</span>.<span class="hljs-attribute">icon</span>;<br>  &#125;<br>  <span class="hljs-selector-tag">var</span> el = (CONFIG<span class="hljs-selector-class">.anchorjs</span><span class="hljs-selector-class">.element</span> || <span class="hljs-string">&#x27;h1,h2,h3,h4,h5,h6&#x27;</span>)<span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>  <span class="hljs-selector-tag">var</span> res = <span class="hljs-selector-attr">[]</span>;<br>  <span class="hljs-keyword">for</span> (const item of el) &#123;<br>    res<span class="hljs-selector-class">.push</span>(<span class="hljs-string">&#x27;.markdown-body &gt; &#x27;</span> + item);<br>  &#125;<br>  <span class="hljs-comment">//window.anchors.add(res.join(&#x27;, &#x27;));</span><br>&#125;, <br></code></pre></td></tr></table></figure></li><li><p>在copy.stl文件中，我去掉了代码框右上角的鼠标悬停显示copy的样式，代码如下(注意他的相对位置)</p><p>第一行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.copy-btn</span><br>  <span class="hljs-comment">//display inline-block</span><br>  <span class="hljs-attribute">display</span> none<br></code></pre></td></tr></table></figure><p><img src="/images/image-20210806153755890.png" alt="image-20210806153755890"></p></li><li><p>在 rewrite.styl文件中，去掉图片的边框阴影</p><p>代码如下 (注释的那一行就是去掉阴影效果)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> &gt; <span class="hljs-selector-tag">img</span>, <span class="hljs-selector-tag">p</span> &gt; <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">img</span><br>  <span class="hljs-attribute">max-width</span> <span class="hljs-number">90%</span><br>  <span class="hljs-attribute">margin</span> <span class="hljs-number">1.5rem</span> auto<br>  <span class="hljs-attribute">display</span> block<br>  <span class="hljs-comment">//box-shadow $img-shadow  // 增加边框阴影效果</span><br>  <span class="hljs-attribute">border-radius</span> <span class="hljs-number">3px</span><br></code></pre></td></tr></table></figure></li><li><p>在 post.styl文件中，去掉图片下方名称和间距</p><p>添加了<code>display: none</code>, 表示不显示image-caption</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.markdown-body</span> <span class="hljs-selector-class">.image-caption</span><br>  <span class="hljs-attribute">display</span>: none<br>  <span class="hljs-attribute">font-size</span> .<span class="hljs-number">8rem</span><br>  <span class="hljs-attribute">color</span> var(--post-text-color)<br>  <span class="hljs-attribute">opacity</span> <span class="hljs-number">0.65</span><br>  <span class="hljs-attribute">line-height</span> <span class="hljs-number">1</span><br>  <span class="hljs-attribute">margin</span> -<span class="hljs-number">0.75rem</span> auto <span class="hljs-number">2rem</span><br>  <span class="hljs-attribute">text-align</span> center<br></code></pre></td></tr></table></figure></li><li><p>在 plugins.js文件中，去掉图片的title属性</p><p>88行开始，将下面一段代码注释掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* var imageTitle = $image.attr(&#x27;title&#x27;) || $image.attr(&#x27;alt&#x27;);</span><br><span class="hljs-comment"> if (imageTitle) &#123;</span><br><span class="hljs-comment">   $imageWrap.append(`&lt;p class=&quot;image-caption&quot;&gt;$&#123;imageTitle&#125;&lt;/p&gt;`);</span><br><span class="hljs-comment">   $imageWrap.attr(&#x27;title&#x27;, imageTitle).attr(&#x27;data-caption&#x27;, imageTitle);</span><br><span class="hljs-comment"> &#125; */</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-完成页面部署"><a href="#3-完成页面部署" class="headerlink" title="3. 完成页面部署"></a>3. 完成页面部署</h2><p>待样式更改完毕后，在blog的下一级目录开启git命令行，输入命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g <span class="hljs-comment"># 生成页面</span><br></code></pre></td></tr></table></figure><p>然后开启hexo本地服务,</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>浏览器输入网址：localhost:4000，访问博客。可以发现，此时样式已经发生变化</p><p>最后部署到远端仓库</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
